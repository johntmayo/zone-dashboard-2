<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Altagether Zone Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/x-icon" href="public/images/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Chivo:wght@400;700;900&family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@mapbox/togeojson@0.16.0/togeojson.js"></script>
  <script src="https://unpkg.com/leaflet-kml@1.0.0/dist/leaflet-kml.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <link rel="stylesheet" href="public/css/styles.css">
  <script src="public/js/utils.js"></script>
</head>

<body>
    <!-- Persistent Filter Bar -->
    <div class="filter-bar hidden" id="filterBar">
      <div class="filter-bar-content" id="filterBarContent">
        <!-- Filters will be inserted here -->
      </div>
    </div>

    <!-- Welcome Message Overlay (shown when spreadsheet not linked) -->
    <div class="welcome-overlay hidden" id="welcomeOverlay">
      <div class="welcome-message">
        <h2>Welcome to the Altagether Zone Dashboard</h2>
        <p>Get started in two simple steps:</p>
        
        <!-- Step 1: Sign In -->
        <div class="welcome-step" id="welcomeStep1">
          <div class="welcome-step-header">
            <span class="welcome-step-number">1</span>
            <h3>Sign in with Google</h3>
          </div>
          <p class="welcome-step-description">Sign in to access and edit your zone spreadsheet data.</p>
          <button class="btn-signin welcome-signin-btn" id="welcomeSignInBtn">
            <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#fff" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z" fill-rule="evenodd"/><path fill="#fff" d="M9 18c2.43 0 4.467-.806 5.96-2.184l-2.908-2.258c-.806.54-1.837.86-3.052.86-2.347 0-4.33-1.584-5.04-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z" fill-rule="evenodd"/><path fill="#fff" d="M3.96 10.707c-.18-.54-.282-1.117-.282-1.707s.102-1.167.282-1.707V4.961H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.039l3.003-2.332z" fill-rule="evenodd"/><path fill="#fff" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.961L3.96 7.293C4.67 5.163 6.653 3.58 9 3.58z" fill-rule="evenodd"/></svg>
            Sign in with Google
          </button>
          <div class="welcome-step-status hidden" id="welcomeStep1Status">
            <span class="welcome-checkmark">‚úì</span> Signed in
          </div>
        </div>

        <!-- Step 2: Link Spreadsheet -->
        <div class="welcome-step hidden" id="welcomeStep2">
          <div class="welcome-step-header">
            <span class="welcome-step-number">2</span>
            <h3>Link your zone spreadsheet</h3>
          </div>
          <p class="welcome-step-description">Paste the web address to your Google Sheets spreadsheet below.</p>
          <div class="welcome-input-group">
            <input id="welcomeSheetUrlInput" class="welcome-sheet-input" placeholder="Paste Google Sheet URL" />
            <button class="welcome-load-btn" id="welcomeLoadBtn">Load</button>
          </div>
        </div>
        
        <div class="welcome-help-link">
          <a href="#" id="getHelpBtn">Get Help</a>
        </div>
      </div>
    </div>

    <!-- App Container -->
    <div class="app-container">
    <!-- Left Navigation Bar -->
    <nav class="left-nav">
      <div class="nav-header">
        <div class="nav-header-zone" id="navHeaderZone">Zone XX</div>
        <div class="nav-header-org">Altagether</div>
      </div>
      <div class="nav-section">
        <button class="nav-item active" data-view="home" id="navHome">Home</button>
        <button class="nav-item" data-view="map" id="navMap">Map</button>
        <button class="nav-item" data-view="people" id="navPeople">Neighbors</button>
        <button class="nav-item" data-view="meetups" id="navMeetups">Actions</button>
        <button class="nav-item" data-view="tools" id="navTools">Tools</button>
        <button class="nav-item" data-view="resources" id="navResources">Resources</button>
        <button class="nav-item" data-view="profile" id="navProfile">My NC Profile</button>
        <a href="about.html" target="_blank" rel="noopener noreferrer" class="nav-item nav-item-link">About the Dashboard</a>
      </div>
      <div class="nav-section nav-section-bottom">
        <div class="nav-logo">
          <img src="public/images/logo_white_transparent.png" alt="Altagether Logo">
        </div>
        <div class="sheet-link-section">
          <label class="sheet-link-label" id="sheetLinkLabel">Link your zone spreadsheet</label>
          <input id="sheetUrlInput" class="nav-sheet-input" placeholder="Paste Google Sheet URL" />
          <button class="nav-load-btn" id="loadSheetBtn">Load</button>
        </div>
        <div class="nav-feedback-wrap">
          <a href="https://airtable.com/appLrjspqPboCt2ma/pagutixyE91qfPMVd/form" target="_blank" rel="noopener noreferrer" class="nav-feedback-link">Send feedback</a>
        </div>
      </div>
    </nav>

    <!-- Full Screen Map -->
    <div class="map-container">
      <div id="zoneMap"></div>
    </div>

    <!-- Floating Right Panel (Addresses/Zone Notes/Contact Mode) -->
    <div class="floating-panel" id="floatingPanel">
      <div class="address-panel">
        <div class="address-panel-tabs">
          <div class="details-header">Details</div>
          <button class="tab-btn hidden" id="zoneNotesTab" data-tab="notes">Zone Notes</button>
          <div class="header-controls">
            <button class="btn-contact-mode" id="contactModeBtn" title="Toggle contact tracking mode">üìû Contact Mode</button>
          </div>
        </div>
        <div class="address-panel-content" id="addressPanelContent">
          <div class="empty">Load a spreadsheet to see addresses</div>
        </div>
        <div class="zone-notes-content hidden" id="zoneNotesContent">
          <textarea id="zoneNotesText" class="zone-notes-text" placeholder="Zone-level notes appear here..."></textarea>
          <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center;">
            <div class="save-status-small" id="zoneNotesStatus"></div>
            <button class="btn-save-small" id="saveZoneNotesBtn" title="Save notes">üíæ Save</button>
          </div>
        </div>
        <div id="signinPrompt" class="signin-prompt hidden">
          <p><strong>Sign in to edit</strong><br>Click below to sign in with Google and enable editing</p>
          <button class="btn-signin" id="signInBtn">
            <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#fff" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z" fill-rule="evenodd"/><path fill="#fff" d="M9 18c2.43 0 4.467-.806 5.96-2.184l-2.908-2.258c-.806.54-1.837.86-3.052.86-2.347 0-4.33-1.584-5.04-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z" fill-rule="evenodd"/><path fill="#fff" d="M3.96 10.707c-.18-.54-.282-1.117-.282-1.707s.102-1.167.282-1.707V4.961H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.039l3.003-2.332z" fill-rule="evenodd"/><path fill="#fff" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.961L3.96 7.293C4.67 5.163 6.653 3.58 9 3.58z" fill-rule="evenodd"/></svg>
            Sign in with Google
          </button>
        </div>
      </div>
    </div>

    <!-- Global sign-in prompt overlay (shown when spreadsheet linked but not signed in, on any tab) -->
    <div id="homeSigninPrompt" class="home-signin-prompt hidden">
      <div class="home-signin-content">
        <p><strong>Sign in to view data</strong><br>Click below to sign in with Google and enable viewing and editing</p>
        <button class="btn-signin" id="homeSignInBtn">
          <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#fff" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z" fill-rule="evenodd"/><path fill="#fff" d="M9 18c2.43 0 4.467-.806 5.96-2.184l-2.908-2.258c-.806.54-1.837.86-3.052.86-2.347 0-4.33-1.584-5.04-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z" fill-rule="evenodd"/><path fill="#fff" d="M3.96 10.707c-.18-.54-.282-1.117-.282-1.707s.102-1.167.282-1.707V4.961H.957C.348 6.175 0 7.55 0 9s.348 2.825.957 4.039l3.003-2.332z" fill-rule="evenodd"/><path fill="#fff" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.961L3.96 7.293C4.67 5.163 6.653 3.58 9 3.58z" fill-rule="evenodd"/></svg>
          Sign in with Google
        </button>
      </div>
    </div>

    <!-- Content Views -->
    <!-- Home Dashboard View -->
    <div class="content-view hidden" id="homeView">
      
      <div class="home-dashboard">
        <div class="home-panels-grid">
          <!-- Panel A: Zone Overview -->
          <div class="home-panel">
            <div class="home-panel-header">
              <h2>Zone Overview</h2>
            </div>
            <div class="home-panel-content" id="zoneSnapshotContent">
              <div class="loading">Loading zone data...</div>
            </div>
            <div class="zone-overview-charts hidden" id="zoneOverviewCharts">
              <!-- Left Chart Carousel -->
              <div class="chart-carousel-wrapper">
                <div class="chart-carousel-container">
                  <button class="chart-carousel-arrow chart-carousel-arrow-left" aria-label="Previous chart">
                    <span class="chart-carousel-arrow-symbol">‚Äπ</span>
                  </button>
                  <div class="chart-carousel-track">
                    <div class="chart-container-small chart-carousel-slide active" data-chart-index="0">
                      <div class="chart-title">Addresses Contacted</div>
                      <canvas id="zoneOverviewLeftAddressesChart"></canvas>
                    </div>
                    <div class="chart-container-small chart-carousel-slide" data-chart-index="1">
                      <div class="chart-title">Streets Distribution</div>
                      <canvas id="zoneOverviewLeftStreetsChart"></canvas>
                    </div>
                    <div class="chart-container-small chart-carousel-slide" data-chart-index="2">
                      <div class="chart-title">People per Address</div>
                      <canvas id="zoneOverviewLeftPeopleChart"></canvas>
                    </div>
                  </div>
                  <button class="chart-carousel-arrow chart-carousel-arrow-right" aria-label="Next chart">
                    <span class="chart-carousel-arrow-symbol">‚Ä∫</span>
                  </button>
                  <div class="chart-carousel-dots" data-carousel="left"></div>
                </div>
              </div>
              
              <!-- Right Chart Carousel -->
              <div class="chart-carousel-wrapper">
                <div class="chart-carousel-container">
                  <button class="chart-carousel-arrow chart-carousel-arrow-left" aria-label="Previous chart">
                    <span class="chart-carousel-arrow-symbol">‚Äπ</span>
                  </button>
                  <div class="chart-carousel-track">
                    <div class="chart-container-small chart-carousel-slide active" data-chart-index="0">
                      <div class="chart-title">Damage Status</div>
                      <canvas id="zoneOverviewRightDamageChart"></canvas>
                    </div>
                    <div class="chart-container-small chart-carousel-slide" data-chart-index="1">
                      <div class="chart-title">Build Status</div>
                      <canvas id="zoneOverviewRightRebuildChart"></canvas>
                    </div>
                    <div class="chart-container-small chart-carousel-slide" data-chart-index="2">
                      <div class="chart-title">Address Plan</div>
                      <canvas id="zoneOverviewRightHouseholdChart"></canvas>
                    </div>
                  </div>
                  <button class="chart-carousel-arrow chart-carousel-arrow-right" aria-label="Next chart">
                    <span class="chart-carousel-arrow-symbol">‚Ä∫</span>
                  </button>
                  <div class="chart-carousel-dots" data-carousel="right"></div>
                </div>
              </div>
            </div>
            <div class="zone-overview-footer hidden" id="zoneOverviewFooter">
              <div class="stat-item">
                <span class="stat-label">Last updated</span>
                <span class="stat-value">-</span>
              </div>
            </div>
          </div>
          
          <!-- Alert Card (dynamically shown when alert is active) -->
          <div class="alert-card-urgent hidden" id="alertCard">
            <h3>Important Update</h3>
            <div class="alert-content" id="alertCardContent"></div>
            <button class="btn-acknowledge" id="alertAcknowledgeBtn">Acknowledge</button>
          </div>

          <!-- Panel B: From Altagether -->
          <div class="home-panel altagether-panel">
            <div class="home-panel-header">
              <h2>From Altagether</h2>
            </div>
            <div class="home-panel-content" id="altagetherContent">
              <div class="loading">Loading announcements...</div>
            </div>
          </div>
          
          <!-- Panel B2: Quick Actions -->
          <div class="home-panel">
            <div class="home-panel-header">
              <h2>Quick Actions</h2>
            </div>
            <div class="home-panel-content" id="quickActionsContent">
              <div class="loading">Loading quick actions...</div>
            </div>
          </div>
          
          <!-- Panel C: Zone Map -->
          <div class="home-panel home-panel-map">
            <div class="home-panel-header">
              <h2>Zone Map</h2>
            </div>
            <div class="home-panel-content home-map-container" id="homeMapContainer">
              <div id="homeMap" style="width: 100%; height: 100%;"></div>
            </div>
          </div>
          
          <!-- Panel D: Build Progress Charts -->
          <div class="home-panel home-panel-wide">
            <div class="home-panel-header">
              <h2>Build Progress</h2>
            </div>
            <div class="home-panel-content">
              <div class="charts-grid" id="homeChartsGrid">
                <div class="chart-container">
                  <div class="chart-title">Address Plan</div>
                  <canvas id="householdStatusChart"></canvas>
                </div>
                <div class="chart-container">
                  <div class="chart-title">Build Status</div>
                  <canvas id="rebuildStatusChart"></canvas>
                </div>
              </div>
              <div class="charts-grid charts-grid-wide hidden" id="homeChartsGridWide">
                <div class="chart-container chart-container-fullwidth">
                  <div class="chart-title">Build Status (Funnel)</div>
                  <canvas id="rebuildStatusFunnelChart"></canvas>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Panel E: Zone Leadership -->
          <div class="home-panel">
            <div class="home-panel-header">
              <h2>Zone Leadership</h2>
            </div>
            <div class="home-panel-content" id="zoneLeadershipContent">
              <div class="loading">Loading zone leadership...</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Map View (just shows map, no overlay) -->
    <div class="content-view hidden" id="mapView">
      <!-- Map view doesn't need content - map is always visible in background -->
    </div>

    <!-- Addresses & People View (Table) -->
    <div class="content-view hidden" id="peopleView">
      <div class="people-view-header">
        <h2 style="margin: 0; color: var(--primary-dark); font-size: 1.8rem; letter-spacing: 0.5px; font-family: 'Chivo', sans-serif;">Neighbors</h2>
        <div class="people-view-actions">
          <button class="btn-print-export" id="btnAddRecord">‚ûï Add Record</button>
          <button class="btn-print-export" id="btnPrintAddresses">üñ®Ô∏è Print</button>
          <button class="btn-print-export" id="btnExportAddresses">üì• Export CSV</button>
        </div>
      </div>
      <div id="peopleTableView"></div>
    </div>

    <!-- Resources View -->
    <div class="content-view hidden" id="resourcesView">
      <h2 class="page-title">Resources</h2>
      
      <!-- ===== ALTAGETHER RESOURCES SECTION ===== -->
      <div class="tools-section">
        <h3 class="tools-section__header">Altagether Resources</h3>
        <div class="tools-grid">

          <!-- Neighborhood Captain Directory Link Module -->
          <div class="tool-module" id="captainDirectoryLink" data-no-expand="true">
            <div class="tool-module-header">
              <h3>Neighborhood Captain Directory</h3>
              <p>Find and connect with volunteer neighborhood captains across Altadena zones.</p>
            </div>
            <div style="margin-top: 16px;">
              <a href="nc-directory.html" target="_blank" rel="noopener noreferrer" class="tool-link-btn">
                üë• Open Captain Directory
              </a>
            </div>
          </div>

        </div>
      </div>

      <!-- ===== COMMUNITY RESOURCES SECTION ===== -->
      <div class="tools-section">
        <h3 class="tools-section__header">Community Resources</h3>
        <div class="tools-grid">

          <!-- Altadena Community Recovery Calendar Module -->
          <div class="tool-module" id="altadenaCalendar" data-no-expand="true">
            <div class="tool-module-header">
              <h3>Altadena Community Recovery Calendar</h3>
              <p>The most comprehensive public calendar of events around town. Brought to you by Courage (Zone 48) and Altadena Rising.</p>
            </div>
            <div style="margin-top: 16px;">
              <a href="https://altadenacalendar.org/" target="_blank" rel="noopener noreferrer" class="tool-link-btn">
                üìÖ Open Calendar
              </a>
            </div>
          </div>

          <!-- Altadena Recovery Wiki Module -->
          <div class="tool-module" id="altadenaRecoveryWiki" data-no-expand="true">
            <div class="tool-module-header">
              <h3>Altadena Recovery Wiki</h3>
              <p>Comprehensive community resource for Eaton Fire recovery information, including rebuilding guides, permits, financial relief, community support, and professional resources.</p>
            </div>
            <div style="margin-top: 16px;">
              <a href="https://altadenawiki.com/wiki/Main_Page" target="_blank" rel="noopener noreferrer" class="tool-link-btn">
                üìñ Open Recovery Wiki
              </a>
            </div>
          </div>

          <!-- LA County Resources -->
          <div class="tool-module" id="laCountyResources" data-no-expand="true">
            <div class="tool-module-header">
              <h3>LA County</h3>
              <p>Official LA County resources for rebuilding permits, recovery cases, and public data.</p>
            </div>
            <div style="margin-top: 16px; display: flex; flex-direction: column; gap: 8px;">
              <a href="https://recovery.lacounty.gov/rebuilding/permitting-progress-dashboard/" target="_blank" rel="noopener noreferrer" style="font-weight: bold; color: var(--primary-dark); text-decoration: underline; font-size: 0.95rem;">
                Permitting Progress Dashboard
              </a>
              <a href="https://experience.arcgis.com/experience/bae937de066d46e28d9259e81fddce34" target="_blank" rel="noopener noreferrer" style="font-weight: bold; color: var(--primary-dark); text-decoration: underline; font-size: 0.95rem;">
                EPIC-LA Permit Finder
              </a>
              <a href="https://data.lacounty.gov/pages/emergency" target="_blank" rel="noopener noreferrer" style="font-weight: bold; color: var(--primary-dark); text-decoration: underline; font-size: 0.95rem;">
                Emergency-Related Data Sharing
              </a>
              <a href="https://egis-lacounty.hub.arcgis.com/datasets/e87c8fcf5a2c4f7e87198b0c208d3d9f_0/explore?location=34.125428%2C-118.388982%2C10" target="_blank" rel="noopener noreferrer" style="font-weight: bold; color: var(--primary-dark); text-decoration: underline; font-size: 0.95rem;">
                EPIC-LA Fire Recovery Cases
              </a>
            </div>
          </div>

          <!-- Property Sales Info Module - Compact utility card -->
          <div class="tool-module tool-module--compact" id="propertySalesInfo" data-no-expand="true">
            <div class="tool-module-header">
              <h3>Property Sales Info</h3>
            </div>
            <div style="margin-top: 12px; display: flex; flex-direction: column; gap: 8px;">
              <a href="https://www.zillow.com/altadena-ca-91001/land/?searchQueryState=%7B%22pagination%22%3A%7B%7D%2C%22isMapVisible%22%3Atrue%2C%22mapBounds%22%3A%7B%22west%22%3A-118.21982382767011%2C%22east%22%3A-118.06447028152753%2C%22south%22%3A34.15266683718172%2C%22north%22%3A34.23572954575837%7D%2C%22mapZoom%22%3A14%2C%22usersSearchTerm%22%3A%22Altadena%20CA%2091001%22%2C%22regionSelection%22%3A%5B%7B%22regionId%22%3A96265%2C%22regionType%22%3A7%7D%5D%2C%22filterState%22%3A%7B%22sort%22%3A%7B%22value%22%3A%22globalrelevanceex%22%7D%2C%22sf%22%3A%7B%22value%22%3Afalse%7D%2C%22tow%22%3A%7B%22value%22%3Afalse%7D%2C%22mf%22%3A%7B%22value%22%3Afalse%7D%2C%22con%22%3A%7B%22value%22%3Afalse%7D%2C%22apa%22%3A%7B%22value%22%3Afalse%7D%2C%22manu%22%3A%7B%22value%22%3Afalse%7D%2C%22apco%22%3A%7B%22value%22%3Afalse%7D%2C%22doz%22%3A%7B%22value%22%3A%227%22%7D%7D%2C%22isListVisible%22%3Atrue%7D" target="_blank" rel="noopener noreferrer" style="font-weight: bold; color: var(--primary-dark); text-decoration: underline; font-size: 0.95rem;">
                New Lots For Sale (last 7 days)
              </a>
              <a href="https://www.zillow.com/altadena-ca-91001/land/?searchQueryState=%7B%22pagination%22%3A%7B%7D%2C%22isMapVisible%22%3Atrue%2C%22mapBounds%22%3A%7B%22west%22%3A-118.21982382767011%2C%22east%22%3A-118.06447028152753%2C%22south%22%3A34.153874316895426%2C%22north%22%3A34.23452323757735%7D%2C%22mapZoom%22%3A14%2C%22usersSearchTerm%22%3A%22Altadena%20CA%2091001%22%2C%22regionSelection%22%3A%5B%7B%22regionId%22%3A96265%2C%22regionType%22%3A7%7D%5D%2C%22filterState%22%3A%7B%22sort%22%3A%7B%22value%22%3A%22globalrelevanceex%22%7D%2C%22sf%22%3A%7B%22value%22%3Afalse%7D%2C%22tow%22%3A%7B%22value%22%3Afalse%7D%2C%22mf%22%3A%7B%22value%22%3Afalse%7D%2C%22con%22%3A%7B%22value%22%3Afalse%7D%2C%22apa%22%3A%7B%22value%22%3Afalse%7D%2C%22manu%22%3A%7B%22value%22%3Afalse%7D%2C%22apco%22%3A%7B%22value%22%3Afalse%7D%7D%2C%22isListVisible%22%3Atrue%7D" target="_blank" rel="noopener noreferrer" style="font-weight: bold; color: var(--primary-dark); text-decoration: underline; font-size: 0.95rem;">
                All Lots for Sale
              </a>
              <a href="https://www.zillow.com/altadena-ca-91001/?searchQueryState=%7B%22isMapVisible%22%3Atrue%2C%22mapBounds%22%3A%7B%22north%22%3A34.232110569367%2C%22south%22%3A34.15628922453173%2C%22east%22%3A-118.0801343821745%2C%22west%22%3A-118.20415972702314%7D%2C%22mapZoom%22%3A14%2C%22usersSearchTerm%22%3A%22Altadena%20CA%2091001%22%2C%22filterState%22%3A%7B%22sort%22%3A%7B%22value%22%3A%22globalrelevanceex%22%7D%7D%2C%22isListVisible%22%3Atrue%2C%22regionSelection%22%3A%5B%7B%22regionId%22%3A96265%2C%22regionType%22%3A7%7D%5D%2C%22pagination%22%3A%7B%7D%7D" target="_blank" rel="noopener noreferrer" style="font-weight: bold; color: var(--primary-dark); text-decoration: underline; font-size: 0.95rem;">
                Everything for Sale
              </a>
              <a href="https://docs.google.com/spreadsheets/d/1qDFwOTnUq87o12n-EeFIZ0xfcqpGOEoNIGFbDJe33a8/edit?gid=757210531#gid=757210531" target="_blank" rel="noopener noreferrer" style="font-weight: bold; color: var(--primary-dark); text-decoration: underline; font-size: 0.95rem;">
                Sold Properties List
              </a>
            </div>
          </div>

        </div>
      </div>

    </div>

    <!-- Tools View -->
    <!-- 
      ================================================================================
      TOOLS PAGE LAYOUT GUIDE
      ================================================================================
      
      This page uses a SECTION + SIZE MODIFIER system to create visual hierarchy
      while maintaining the bento box aesthetic.
      
      STRUCTURE:
      - Each section has a .tools-section wrapper with a .tools-section__header
      - Tools within each section live in a .tools-grid
      
      SIZE MODIFIERS (add to .tool-module):
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ CLASS                    ‚îÇ USE FOR                      ‚îÇ VISUAL WEIGHT    ‚îÇ
      ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
      ‚îÇ .tool-module--featured   ‚îÇ Built-in interactive tools   ‚îÇ Spans 2 columns  ‚îÇ
      ‚îÇ                          ‚îÇ (Zone Analysis, Flyer Creator)‚îÇ on desktop       ‚îÇ
      ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
      ‚îÇ .tool-module (default)   ‚îÇ External resource links      ‚îÇ Standard size    ‚îÇ
      ‚îÇ                          ‚îÇ (Calendar, Wiki, Directory)   ‚îÇ                  ‚îÇ
      ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
      ‚îÇ .tool-module--compact    ‚îÇ Utility/reference links      ‚îÇ Smaller, tighter ‚îÇ
      ‚îÇ                          ‚îÇ (Property Sales, quick refs)  ‚îÇ                  ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      
      TO ADD A NEW TOOL:
      1. Decide which section it belongs to (Zone Tools vs Community Resources)
      2. Choose the appropriate size modifier based on what it IS:
         - Interactive/built-in feature ‚Üí tool-module--featured
         - External resource link ‚Üí tool-module (default)
         - Reference/utility links ‚Üí tool-module--compact
      3. Add it inside the appropriate .tools-grid
      
      MOBILE: All cards collapse to single column. Featured cards lose span-2.
      Section headers help users navigate the vertical stack.
      ================================================================================
    -->
    <div class="content-view hidden" id="toolsView">
      <h2 class="page-title">Tools</h2>
      
      <!-- ===== ZONE TOOLS SECTION ===== -->
      <!-- Interactive tools built into the dashboard. Use tool-module--featured for these. -->
      <div class="tools-section">
        <h3 class="tools-section__header">Zone Tools</h3>
        <div class="tools-grid">
          
          <!-- Zone Analysis Generator Module -->
          <div class="tool-module tool-module--featured" id="zoneReportGenerator">
            <div class="tool-module-header" style="cursor: pointer;">
              <h3>Zone Analysis <span class="tool-module-toggle">‚ñº</span></h3>
              <p>Create a comprehensive PDF report with all zone data, statistics, analysis, and insights. Perfect for printing, sharing, or archiving.</p>
            </div>
            
            <div class="tool-module-content">
              <div class="zone-report-controls">
                <button class="btn-generate-report" id="btnGenerateReport">üìä Generate Zone Analysis</button>
                <div class="zone-report-status" id="zoneReportStatus"></div>
              </div>
              
              <div class="zone-report-container hidden" id="zoneReportContainer">
                <div class="zone-report-actions" style="margin-bottom: 24px; padding: 16px; background: rgba(96, 108, 56, 0.05); border-radius: 8px; border: 2px solid var(--primary);">
                  <button class="btn-export" id="btnExportReportPDF" style="font-size: 1.1rem; padding: 14px 28px;">üì• Export to PDF</button>
                </div>
                <div class="zone-report-content" id="zoneReportContent">
                  <!-- Report will be generated here -->
                </div>
              </div>
            </div>
          </div>

          <!-- Batch Tagging Module -->
          <div class="tool-module tool-module--featured" id="batchTaggingTool">
            <div class="tool-module-header" style="cursor: pointer;">
              <h3>Batch Tagging <span class="tool-module-toggle">‚ñº</span></h3>
              <p>Quickly set Damage, Address Plan, and Build Status for many addresses at once. Select addresses (optionally filter first in Neighbors), choose values, then Apply.</p>
            </div>
            <div class="tool-module-content">
              <div id="batchTaggingError" class="hidden" style="padding:12px; margin-bottom:16px; background:rgba(200,0,0,0.1); border:1px solid #c00; border-radius:8px; color:#c00; font-weight:600;"></div>
              <div id="batchTaggingBody">
                <p style="margin:0 0 12px 0; color:var(--text-light);">Addresses shown match your current Neighbors filters. Check the ones you want to tag.</p>
                <!-- List view: checkboxes -->
                <div id="batchTaggingListView">
                  <div style="margin-bottom:12px;">
                    <button type="button" class="btn-copy-emails" id="batchTaggingSelectAll" style="margin-right:8px;">Select all</button>
                    <button type="button" class="btn-copy-emails" id="batchTaggingSelectNone">Select none</button>
                    <button type="button" class="btn-copy-emails" id="batchTaggingDrawOnMap" style="margin-left:8px;">Draw on map</button>
                  </div>
                  <p id="batchTaggingNoCoordsNote" class="hidden" style="margin:0 0 8px 0; font-size:0.85rem; color:var(--text-light);"></p>
                  <div id="batchTaggingAddressList" style="max-height:280px; overflow-y:auto; border:1px solid var(--border-soft); border-radius:8px; padding:12px; margin-bottom:20px; background:rgba(255,255,255,0.5);">
                    <!-- Populated by JS -->
                  </div>
                </div>
                <!-- Map view: polygon drawing -->
                <div id="batchTaggingMapView" class="hidden" style="margin-bottom:20px;">
                  <p style="margin:0 0 8px 0; font-size:0.9rem; color:var(--text-light);">Click on the map to add polygon points. Click the first point again to close the shape (or use the button). Selected addresses turn red; choose values below and click Apply when ready.</p>
                  <div style="margin-bottom:8px;">
                    <button type="button" class="btn-copy-emails" id="batchTaggingMapBackToList" style="margin-right:8px;">Back to list</button>
                    <button type="button" class="btn-copy-emails" id="batchTaggingMapClosePolygon" style="margin-right:8px;">Close polygon &amp; select</button>
                    <button type="button" class="btn-copy-emails" id="batchTaggingMapClear">Clear shape</button>
                  </div>
                  <div id="batchTaggingMapContainer" style="height:420px; border:1px solid var(--border-soft); border-radius:8px; overflow:hidden;"></div>
                  <p id="batchTaggingMapStatus" style="margin:8px 0 0 0; font-size:0.9rem; color:var(--text-light);"></p>
                </div>
                <div style="display:flex; flex-wrap:wrap; gap:20px; align-items:flex-end; margin-bottom:16px;">
                  <div>
                    <label style="display:block; margin-bottom:4px; font-weight:600;">Damage</label>
                    <select id="batchTaggingDamage" class="add-record-select" style="min-width:160px;"></select>
                  </div>
                  <div>
                    <label style="display:block; margin-bottom:4px; font-weight:600;">Address Plan</label>
                    <select id="batchTaggingAddressPlan" class="add-record-select" style="min-width:160px;"></select>
                  </div>
                  <div>
                    <label style="display:block; margin-bottom:4px; font-weight:600;">Build Status</label>
                    <select id="batchTaggingRebuild" class="add-record-select" style="min-width:200px;"></select>
                  </div>
                </div>
                <button type="button" class="btn-generate-report" id="batchTaggingApply">Apply to selected addresses</button>
                <div id="batchTaggingStatusMsg" style="margin-top:12px; font-size:0.9rem;"></div>
              </div>
            </div>
          </div>

          <!-- Flyer Creator Link Module -->
          <div class="tool-module tool-module--featured" id="flyerCreatorLink" data-no-expand="true">
            <div class="tool-module-header">
              <h3>Flyer Creator</h3>
              <p>Create professional event flyers with customizable designs. Perfect for community meetings, resource distribution, and neighborhood events.</p>
            </div>
            <div style="margin-top: 16px;">
              <a href="flyer_tool.html" target="_blank" rel="noopener noreferrer" class="tool-link-btn" id="flyerCreatorLinkBtn">
                üé® Open Flyer Creator
              </a>
            </div>
          </div>

        </div>
      </div>


      <!-- ===== COMMUNITY TOOLS SECTION ===== -->
      <div class="tools-section">
        <h3 class="tools-section__header">Community Tools</h3>
        <div class="tools-grid">

          <!-- PostFire Rebuild Calculator -->
          <div class="tool-module" id="postfireRebuildCalculator" data-no-expand="true">
            <div class="tool-module-header">
              <h3>PostFire Rebuild Calculator</h3>
              <p>PostFire has built a calculator that gives you a rough idea of your building budget. Adjust the inputs to see what‚Äôs possible.</p>
            </div>
            <div style="margin-top: 16px;">
              <a href="https://postfire.org/rebuildcalculator" target="_blank" rel="noopener noreferrer" class="tool-link-btn">
                üßÆ Rebuild Calculator
              </a>
            </div>
          </div>

          <!-- SCE Wildfire Recovery Compensation Program Estimator -->
          <div class="tool-module" id="sceWildfireRecoveryEstimator" data-no-expand="true">
            <div class="tool-module-header">
              <h3>SCE WILDFIRE RECOVERY COMPENSATION PROGRAM ESTIMATOR</h3>
              <p>A volunteer-made tool to help people assess whether SCE's Wildfire Recovery Compensation Program is right for them. For informational purposes only.</p>
            </div>
            <div style="margin-top: 16px;">
              <a href="https://docs.google.com/spreadsheets/d/1cDOIXEPTTkqEVNe8PaDzk7PfncfIXIwiQXlo_Y7li8M/edit?gid=1649567335#gid=1649567335" target="_blank" rel="noopener noreferrer" class="tool-link-btn">
                üìÑ SCE Wildfire Recovery Compensation Program Tool
              </a>
            </div>
          </div>

        </div>
      </div>

      <!-- ===== HIDDEN TOOLS ===== -->
      <!-- Tools that are hidden but kept in code for future use -->
      
      <!-- Buildnotes Module (Hidden for now) -->
      <div class="tool-module hidden" id="buildnotes" data-no-expand="true">
        <div class="tool-module-header">
          <h3>Buildnotes</h3>
          <p>Buildnotes is a collective purchasing platform for survivors, architects, and builders involved in the LA wildfire rebuild.</p>
        </div>
        <div style="margin-top: 16px;">
          <a href="https://buildnotes.com" target="_blank" rel="noopener noreferrer" class="tool-link-btn">
            üèóÔ∏è Open Buildnotes
          </a>
        </div>
      </div>

      <!-- Data Transfer Tool Module (Hidden) -->
      <div class="tool-module hidden" id="dataTransferTool" data-no-expand="true">
        <div class="tool-module-header">
          <h3>Data Transfer Tool</h3>
          <p>Transfer and translate your data from your existing spreadsheet to the new Google spreadsheet backend. This tool helps you migrate your data seamlessly to the new platform.</p>
        </div>
        <div style="margin-top: 16px;">
          <button class="tool-link-btn">
            üîÑ Open Data Transfer Tool
          </button>
        </div>
      </div>

    </div>

    <!-- Actions View -->
    <div class="content-view hidden" id="meetupsView">
      <h2 class="page-title">Actions</h2>
      <div id="actionsPageContent" style="margin-top: 24px;">
        <div class="loading">Loading actions...</div>
      </div>
    </div>

    <!-- My NC Profile View (NC Directory) -->
    <div class="content-view hidden" id="profileView">
      <h2 class="page-title">My NC Profile</h2>
      <p style="color: var(--text-secondary); margin-bottom: 1rem; max-width: 700px;">Update your neighborhood captain&apos;s profile. Changes are saved to the NC directory. You can also update your profile the old fashioned way in the <a href="https://docs.google.com/spreadsheets/d/1E77qmT4eGtyokaDvD2wlK3q2NeMcS4itmkbYp6Rz0qM/edit?gid=0#gid=0" target="_blank" rel="noopener noreferrer">directory spreadsheet</a>.</p>
      <div id="profileSigninPrompt" class="hidden" style="padding: 1.5rem; background: var(--bg-card); border: 2px solid var(--border-color); border-radius: 8px; max-width: 500px;">
        <p><strong>Sign in to edit your profile</strong></p>
        <p>Use the &quot;Sign in with Google&quot; button above, then return here.</p>
      </div>
      <div id="profileNotFound" class="hidden" style="padding: 1.5rem; background: #FEF3C7; border: 2px solid var(--accent-gold); border-radius: 8px; max-width: 500px;">
        <p><strong>No profile found</strong></p>
        <p>In order to manage your profile on this page, the <a href="https://docs.google.com/spreadsheets/d/1E77qmT4eGtyokaDvD2wlK3q2NeMcS4itmkbYp6Rz0qM/edit?gid=0#gid=0" target="_blank" rel="noopener noreferrer">directory spreadsheet</a> needs to have the Google address you used to log into the dashboard listed in the green column. Add that email address, and then refresh this screen.</p>
      </div>
      <div id="profileFormContainer" class="hidden" style="max-width: 700px;">
        <form id="ncProfileForm" style="display: flex; flex-direction: column; gap: 1rem;">
          <div><label for="ncName" style="font-weight: 600;">Name</label><br><input type="text" id="ncName" name="Name" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border-color); border-radius: 4px;"></div>
          <div><label for="ncZone" style="font-weight: 600;">Zone</label><br><input type="text" id="ncZone" name="Zone" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border-color); border-radius: 4px;"></div>
          <div><label for="ncLocation" style="font-weight: 600;">Location</label><br><input type="text" id="ncLocation" name="Location" placeholder="Describe your location" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border-color); border-radius: 4px;"></div>
          <div><label for="ncCensusTract" style="font-weight: 600;">Predominant Census Tract of Zone</label><br><select id="ncCensusTract" name="Predominant Census Tract of Zone" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border-color); border-radius: 4px;"></select></div>
          <div><label for="ncPhone" style="font-weight: 600;">Phone</label><br><input type="text" id="ncPhone" name="Phone" placeholder="(XXX) XXX-XXXX" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border-color); border-radius: 4px;"></div>
          <div><label for="ncPreferredEmail" style="font-weight: 600;">Preferred email</label><br><input type="email" id="ncPreferredEmail" name="Preferred email" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border-color); border-radius: 4px;"></div>
          <div><label style="font-weight: 600;">Working Group Participation</label><br><div id="ncWorkingGroups" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div></div>
          <div><label for="ncHousing" style="font-weight: 600;">Housing Arrangement</label><br><select id="ncHousing" name="Housing Arrangement" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border-color); border-radius: 4px;"></select></div>
          <div><label for="ncDamage" style="font-weight: 600;">Damage to home</label><br><select id="ncDamage" name="Damage to home" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border-color); border-radius: 4px;"></select></div>
          <div><label for="ncNotesBio" style="font-weight: 600;">Notes/Bio</label><br><textarea id="ncNotesBio" name="Notes/Bio" rows="3" placeholder="A little about your background or interests" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border-color); border-radius: 4px;"></textarea></div>
          <div><label style="font-weight: 600;">Interest Areas</label><br><div id="ncInterestAreas" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div></div>
          <div><label for="ncExpertiseAskMe" style="font-weight: 600;">Expertise (Ask Me About...)</label><br><input type="text" id="ncExpertiseAskMe" name="Expertise (Ask Me About...)" placeholder="Things you're knowledgeable about" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border-color); border-radius: 4px;"></div>
          <div><label for="ncLanguages" style="font-weight: 600;">Languages Spoken</label><br><input type="text" id="ncLanguages" name="Languages Spoken" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border-color); border-radius: 4px;"></div>
          <div><label for="ncWaterDistrict" style="font-weight: 600;">Water Districts in Zone</label><br><select id="ncWaterDistrict" name="Water Districts in Zone" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border-color); border-radius: 4px;"></select></div>
          <div><label style="display:inline-flex;align-items:center;gap:0.5rem;cursor:pointer;"><input type="checkbox" id="ncDenaNative" name="dena native"> I'm a dena native</label></div>
          <div id="ncBadgesReadOnly" class="hidden" style="font-size: 0.9rem; color: var(--text-secondary);"></div>
          <button type="button" id="ncProfileSaveBtn" class="btn-save" style="align-self: flex-start;">Save profile</button>
        </form>
        <p id="profileSaveStatus" class="hidden" style="margin-top: 0.5rem; font-size: 0.9rem;"></p>
      </div>
    </div>

  </div>

  <script>
    const input = document.getElementById("sheetUrlInput");
    const btn = document.getElementById("loadSheetBtn");
    // Refresh button removed - data auto-loads after sign-in
    const addressPanelContent = document.getElementById("addressPanelContent");
    const signInBtn = document.getElementById("signInBtn");
    const signinPrompt = document.getElementById("signinPrompt");

    // Navigation state
    let currentView = 'home'; // Default view
    let currentSheetUrl = '';
    let sheetData = [];
    let selectedAddress = null; // Track currently selected address
    let savedScrollPosition = 0; // Track scroll position for refresh
    let accessToken = null; // OAuth2 access token
    let currentUserEmail = null; // Signed-in Google account email (for NC Profile row match)
    let currentSheetId = null; // Current sheet ID for writing
    let currentStreetFilter = 'all'; // Current street filter
    let currentDamageFilter = 'all'; // Current damage filter
    let currentAddressPlanFilter = 'all'; // Current Address Plan filter (only when Damage = Partial/Total Loss)
    let currentRebuildFilter = 'all'; // Current rebuild status filter
    let currentCaptainFilter = 'all'; // Current captain assigned filter
    let showContactedAddresses = true; // Show addresses with contacted people
    let showUncontactedAddresses = true; // Show addresses with uncontacted people
    
    // Sequential rebuild stages (in order)
    const REBUILD_STAGES_SEQUENTIAL = [
      'Planning/Not Ready to Build Yet',
      'Permits & Pre-Construction',
      'Under Construction',
      'Finishing/Preparing to Move Back',
      'Moved In'
    ];
    let tableSortColumn = null; // Current sort column
    let tableSortDirection = 'asc'; // Sort direction: 'asc' or 'desc'
    let zoneMap = null; // Leaflet map instance
    let homeMap = null; // Homepage map instance
    let addressMarkers = []; // Array of address markers
    let homeMapMarkers = []; // Array of markers for homepage map
    let kmlLayer = null; // KML boundary layer
    let homeKmlLayer = null; // KML boundary layer for homepage
    let additionalMapboxLayer = null; // Optional Mapbox-powered overlay layer
    let additionalMapboxLayerControl = null; // Expandable layers control for map overlays
    let additionalMapboxLayerLoading = false; // Prevent duplicate overlay fetches
    let additionalMapboxLayerVisible = false; // Current visibility state for optional overlay layer
    let cachedAdditionalMapboxFeatureCollection = null; // Cached feature collection for optional overlay
    let additionalMapboxZoomHandler = null; // Zoom listener for label visibility
    let currentTileLayer = null; // Current map tile layer
    let homeTileLayer = null; // Tile layer for homepage
    let isSatelliteMode = false; // Track satellite mode state
    let currentColorMode = null; // Current color mode: 'contact', 'damage', 'status', 'rebuild', or null
    // Load saved color mode from localStorage
    const savedColorMode = localStorage.getItem('currentColorMode');
    if (savedColorMode && savedColorMode !== '') {
      currentColorMode = savedColorMode;
    }
    let homeColorMode = null; // Color mode for home map
    let colorLegendControl = null; // Color legend control instance
    let colorFilterControl = null; // Color filter control instance
    let homeColorFilterControl = null; // Color filter control instance for home map
    let homeColorLegendControl = null; // Color legend control instance for home map
    let colorFilterWatchdog = null; // Interval ID for watching control
    let isHomeSatelliteMode = false; // Track satellite mode for homepage
    let zoneNotes = ''; // Zone-level notes
    let zoneKmlUrl = ''; // Zone KML URL from metadata
    let metadataSheetId = null; // Sheet ID for metadata sheet
    let autoSaveTimer = null; // Timer for debounced auto-save
    let currentZoneName = ''; // Current zone name from spreadsheet
    let homeKmlLoading = false; // Prevent duplicate KML loads causing transparency issues

    // Mapbox Datasets API config (zone boundaries). Leave token empty to disable; KML fallback still works.
    const MAPBOX_CONFIG = {
      username: 'altagether',   // Your Mapbox account username (e.g. from Studio URL)
      datasetId: 'cm64fisju135z1qqmifs0zty5',  // Dataset ID containing zone polygons (ZoneName, Status, ContactEmail, etc.)
      accessToken: '' // Set from environment/runtime; keep blank in source to avoid secret scanning blocks
    };
    function isMapboxEnabled() {
      return !!(MAPBOX_CONFIG.accessToken && MAPBOX_CONFIG.username && MAPBOX_CONFIG.datasetId);
    }
    const MAPBOX_ADDITIONAL_LAYER_CONFIG = {
      tilesetId: 'altagether.cm64fisju135z1qqmifs0zty5-4swrp',
      displayName: 'Zones',
      defaultVisible: false,
      filterToCurrentZone: false, // Set true if this layer should only show current zone features
      zonePropertyKeys: ['ZoneName', 'Zone name', 'zoneName', 'zone'],
      contactNamePropertyKeys: ['ContactName', 'Contact Name', 'Captain Name', 'CaptainName', 'Captain'],
      contactEmailPropertyKeys: ['ContactEmail', 'Contact Email', 'Email', 'Emails'],
      contactPhonePropertyKeys: ['ContactPhone', 'Contact Phone', 'Phone', 'Phones'],
      tooltip: {
        enabled: true,
        permanent: true,
        direction: 'center',
        className: 'additional-zone-tooltip'
      },
      labelMinZoom: 16,
      style: {
        color: '#4B7D5D',
        weight: 2,
        opacity: 0.85,
        fillColor: '#A9CFA0',
        fillOpacity: 0.16
      },
      hoverStyle: {
        weight: 3,
        opacity: 0.95,
        fillOpacity: 0.24
      }
    };
    function isAdditionalMapboxLayerEnabled() {
      return !!(MAPBOX_CONFIG.accessToken && MAPBOX_ADDITIONAL_LAYER_CONFIG.tilesetId);
    }

    async function initializeMapboxAccessToken() {
      if (MAPBOX_CONFIG.accessToken && MAPBOX_CONFIG.accessToken.trim()) return;
      try {
        const response = await fetch('/api/mapbox-token', { cache: 'no-store' });
        if (!response.ok) return;
        const payload = await response.json();
        const token = (payload?.token || '').trim();
        if (!token) return;
        MAPBOX_CONFIG.accessToken = token;

        // Refresh boundary overlays once token is available at runtime.
        if (currentZoneName && currentZoneName.trim()) {
          if (zoneMap) loadZoneBoundary();
          if (homeMap) loadHomeZoneBoundary();
        }
        if (additionalMapboxLayerVisible) {
          setAdditionalMapboxLayerVisible(true);
        }
      } catch (error) {
        console.warn('Mapbox token endpoint unavailable; Mapbox layers remain disabled.', error);
      }
    }

    // Load OAuth token and user email from localStorage
    const savedToken = localStorage.getItem('googleOAuthToken');
    const savedTokenExpiry = localStorage.getItem('googleOAuthTokenExpiry');
    if (savedToken && savedTokenExpiry && Date.now() < parseInt(savedTokenExpiry)) {
      accessToken = savedToken;
      currentUserEmail = (localStorage.getItem('ncProfileUserEmail') || '').trim().toLowerCase() || null;
      updateSignInUI();
    }

    // Load saved sheet URL from localStorage
    const savedSheetUrl = localStorage.getItem('savedSheetUrl');
    if (savedSheetUrl && input) {
      input.value = savedSheetUrl;
      currentSheetUrl = savedSheetUrl;
      // Auto-load the sheet if user is signed in (wait a bit for OAuth to initialize)
      if (accessToken) {
        setTimeout(() => {
          if (currentSheetUrl) {
            loadAddressData(currentSheetUrl);
          }
        }, 1000);
      }
    }

    // Initialize sheet link label, welcome message, header title, and navigation state
    updateSheetLinkLabel();
    updateWelcomeMessage();
    updateHeaderTitle();
    updateNavigationState();
    initializeMapboxAccessToken();

    // Get Help link handler (in welcome overlay) - opens About the Dashboard page in new tab
    const getHelpBtn = document.getElementById('getHelpBtn');
    if (getHelpBtn) {
      getHelpBtn.addEventListener('click', (e) => {
        e.preventDefault();
        window.open('about.html', '_blank', 'noopener,noreferrer');
      });
    }

    // Welcome popup load button handler
    const welcomeLoadBtn = document.getElementById('welcomeLoadBtn');
    const welcomeSheetUrlInput = document.getElementById('welcomeSheetUrlInput');
    if (welcomeLoadBtn && welcomeSheetUrlInput) {
      welcomeLoadBtn.addEventListener('click', () => {
        // Validate sign-in first
        if (!accessToken) {
          alert('Please sign in with Google first before loading your spreadsheet.');
          // Show step 1 if hidden
          const welcomeStep1 = document.getElementById('welcomeStep1');
          if (welcomeStep1) {
            welcomeStep1.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
          return;
        }

        let url = welcomeSheetUrlInput.value.trim();
        if (!url) {
          alert('Please enter a Google Sheets URL.');
          return;
        }

        if (url.includes("/view")) {
          url = url.replace("/view", "/edit");
        }

        // Update main input field
        if (input) {
          input.value = url;
        }

        currentSheetUrl = url;
        // Save to localStorage
        localStorage.setItem('savedSheetUrl', url);
        
        // Update UI
        updateSheetLinkLabel();
        updateWelcomeMessage();
        updateNavigationState();
        
        // Load the address data
        loadAddressData(url);
      });

      // Also allow Enter key to trigger load
      welcomeSheetUrlInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          welcomeLoadBtn.click();
        }
      });
    }

    // Google Sheets API is now proxied via server (service account). No client-side gapi init needed.

    // ============================================
    // CONFIGURATION: OAuth Client ID
    // ============================================
    // To enable editing, you need a Google OAuth Client ID:
    // 1. Go to https://console.cloud.google.com/apis/credentials
    // 2. Create OAuth 2.0 Client ID (Web application)
    // 3. Add your domain to authorized JavaScript origins
    // 4. Replace 'YOUR_CLIENT_ID' below with your actual Client ID
    // ============================================
    const OAUTH_CLIENT_ID = '633926045450-3214il5eg7emu5e0fp8am1g26jdfnoh7.apps.googleusercontent.com'; // Replace with your OAuth Client ID
    const NC_DIRECTORY_SHEET_ID = '1E77qmT4eGtyokaDvD2wlK3q2NeMcS4itmkbYp6Rz0qM'; // NC Directory Google Sheet (Sheet1 = captain roster)

    // OAuth2 Sign In
    async function signIn() {
      if (OAUTH_CLIENT_ID === 'YOUR_CLIENT_ID') {
        alert('OAuth Client ID not configured. Please set OAUTH_CLIENT_ID in the code.');
        return;
      }
      
      try {
        const tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: OAUTH_CLIENT_ID,
          scope: 'https://www.googleapis.com/auth/userinfo.email openid',
          callback: async (response) => {
            if (response.error) {
              console.error('Sign in error:', response.error);
              alert('Sign in failed. Please try again.');
              return;
            }
            accessToken = response.access_token;
            // Store token with expiry (tokens last 1 hour, store for 50 minutes)
            const expiry = Date.now() + (50 * 60 * 1000);
            localStorage.setItem('googleOAuthToken', accessToken);
            localStorage.setItem('googleOAuthTokenExpiry', expiry.toString());
            // Fetch and store signed-in user email (for NC Profile row matching)
            try {
              const userRes = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', { headers: { 'Authorization': 'Bearer ' + accessToken } });
              if (userRes.ok) {
                const user = await userRes.json();
                currentUserEmail = (user.email || '').trim().toLowerCase();
                if (currentUserEmail) localStorage.setItem('ncProfileUserEmail', currentUserEmail);
              }
            } catch (e) { console.warn('Could not fetch user email:', e); }
            updateSignInUI();
            
            // Auto-load data after sign-in if we have a sheet URL
            const savedSheetUrl = localStorage.getItem('savedSheetUrl');
            const sheetUrlToLoad = currentSheetUrl || savedSheetUrl;
            
            if (sheetUrlToLoad) {
              currentSheetUrl = sheetUrlToLoad;
              // Small delay to ensure UI updates
              setTimeout(() => {
                loadAddressData(sheetUrlToLoad);
              }, 500);
            } else if (selectedAddress && currentSheetUrl) {
              // Fallback: refresh current address if one is selected
              loadAddressData(currentSheetUrl);
            }
            if (currentView === 'profile') loadProfileView();
          },
        });
        tokenClient.requestAccessToken({ prompt: 'consent' });
      } catch (error) {
        console.error('Sign in error:', error);
        alert('Error signing in. Please try again.');
      }
    }

    // Sign Out
    function signOut() {
      accessToken = null;
      currentUserEmail = null;
      localStorage.removeItem('googleOAuthToken');
      localStorage.removeItem('googleOAuthTokenExpiry');
      localStorage.removeItem('ncProfileUserEmail');
      updateSignInUI();
      if (selectedAddress && currentSheetUrl) {
        loadAddressData(currentSheetUrl);
      }
      if (currentView === 'profile') loadProfileView();
    }

    // ---- NC Directory / My NC Profile ----
    const NC_PROFILE_HEADERS = ['Name', 'Zone', 'Location', 'Predominant Census Tract of Zone', 'Phone', 'Preferred email', 'Working Group Participation', 'Housing Arrangement', 'Damage to home', 'Notes/Bio', 'Interest Areas', 'Expertise (Ask Me About...)', 'Languages Spoken', 'Google email', 'Water Districts in Zone', 'Badges'];
    const NC_PROFILE_OPTIONS = {
      'Predominant Census Tract of Zone': ['CT 4601', 'CT 4602', 'CT 4603.01', 'CT 4603.02', 'CT 4610', 'CT 4611', 'CT 4612', 'CT 4613'],
      'Housing Arrangement': ['Renter', 'Homeowner', 'RV', 'Other'],
      'Damage to home': ['Standing home', 'Partial loss', 'Total loss'],
      'Water Districts in Zone': ['Rubio Ca√±on', 'Lincoln Avenue', 'Las Flores', 'TBD'],
      'Working Group Participation': ['Home Hardening & Fire-Resistant Neighborhoods', 'Bioremediation + Native Plants', 'Political Advocacy', 'Group Purchasing Power', 'Altagether Rebuilding Working Group', 'School Redevelopment'],
      'Interest Areas': ['Standing homes', 'Trees & plants', 'Bioremediation', 'Mental health', 'Insurance', 'Community visioning', 'Modular, Prefab, and Factory-Built Homes', 'Community Land Trusts', 'Schools & Children', 'Crime & Safety', 'Renter issues', 'Landlord issues', 'Rebuilding', 'Group purchasing power', 'Disaster preparedness', 'Architectural heritage', 'Commercial redevelopment', 'Faith institutions', 'Town history & stories', 'New tech tools & platforms', 'Event planning', 'Owner/Builder', 'Alternative Building', 'Solar power', 'Utilities', 'Water issues', 'Electric issues', 'Gas issues', 'Telecom issues']
    };
    let ncProfileRowIndex = null;
    let ncProfileRowData = null;
    let ncProfileHeaders = null;

    function splitPipe(val) {
      if (!val || !String(val).trim()) return [];
      return String(val).split('|').map(s => s.trim()).filter(Boolean);
    }

    // Format multi-select values for sheet: comma-separated, quote any value containing a comma (matches Sheets native multi-select).
    function formatMultiSelectForSheet(values) {
      if (!Array.isArray(values) || values.length === 0) return '';
      return values.map(v => {
        const s = String(v).trim();
        if (!s) return '';
        return s.includes(',') ? '"' + s.replace(/"/g, '""') + '"' : s;
      }).filter(Boolean).join(', ');
    }

    // Parse multi-select cell value: comma-separated (with optional quoted segments) or legacy pipe-separated.
    function parseMultiSelect(val) {
      if (!val || !String(val).trim()) return [];
      const s = String(val).trim();
      if (s.includes('|') && !s.includes('"')) {
        return s.split('|').map(x => x.trim()).filter(Boolean);
      }
      const result = [];
      let current = '';
      let inQuotes = false;
      for (let i = 0; i < s.length; i++) {
        const c = s[i];
        if (c === '"') {
          if (inQuotes && s[i + 1] === '"') { current += '"'; i++; }
          else inQuotes = !inQuotes;
        } else if (c === ',' && !inQuotes) {
          result.push(current.trim());
          current = '';
          if (s[i + 1] === ' ') i++;
        } else {
          current += c;
        }
      }
      result.push(current.trim());
      return result.filter(Boolean);
    }

    async function loadProfileView() {
      const signinEl = document.getElementById('profileSigninPrompt');
      const notFoundEl = document.getElementById('profileNotFound');
      const formEl = document.getElementById('profileFormContainer');
      if (signinEl) signinEl.classList.add('hidden');
      if (notFoundEl) notFoundEl.classList.add('hidden');
      if (formEl) formEl.classList.add('hidden');

      if (!accessToken) {
        if (signinEl) signinEl.classList.remove('hidden');
        return;
      }
      if (!currentUserEmail) {
        try {
          const userRes = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', { headers: { 'Authorization': 'Bearer ' + accessToken } });
          if (userRes.ok) {
            const user = await userRes.json();
            currentUserEmail = (user.email || '').trim().toLowerCase();
            if (currentUserEmail) localStorage.setItem('ncProfileUserEmail', currentUserEmail);
          } else {
            console.warn('Userinfo response not ok:', userRes.status, await userRes.text().catch(() => ''));
          }
        } catch (e) { console.warn('Could not fetch user email:', e); }
      }
      if (!currentUserEmail) {
        if (notFoundEl) {
          notFoundEl.innerHTML = '<p><strong>Could not determine your Google email.</strong></p><p>Your sign-in may not include email access (for example if you signed in before we added profile support). Sign out and sign in again so we can link your account to your NC profile.</p><button type="button" class="btn-signin" id="profileSignOutAndInAgain" style="margin-top: 0.5rem;">Sign out and sign in again</button>';
          notFoundEl.classList.remove('hidden');
          document.getElementById('profileSignOutAndInAgain')?.addEventListener('click', () => {
            signOut();
            setTimeout(() => signIn(), 300);
          });
        }
        return;
      }

      try {
        const values = await fetchViaOAuth(NC_DIRECTORY_SHEET_ID, 'A1:P500', 'Sheet1');
        if (!values || values.length < 2) {
          if (notFoundEl) { notFoundEl.querySelector('p:last-child').textContent = 'NC Directory is empty or unavailable.'; notFoundEl.classList.remove('hidden'); }
          return;
        }
        const headers = values[0].map(h => (h || '').trim());
        const rows = values.slice(1).map(rowArr => {
          const obj = {};
          headers.forEach((h, i) => { obj[h] = (rowArr[i] !== undefined && rowArr[i] !== null ? String(rowArr[i]).trim() : ''); });
          return obj;
        });
        const googleEmailCol = headers.find(h => h === 'Google email') || 'Google email';
        const matchIndex = rows.findIndex(r => (r[googleEmailCol] || '').trim().toLowerCase() === currentUserEmail);
        if (matchIndex === -1) {
          if (notFoundEl) notFoundEl.classList.remove('hidden');
          return;
        }
        ncProfileRowIndex = matchIndex + 2;
        ncProfileRowData = rows[matchIndex];
        ncProfileHeaders = headers;
        populateProfileForm(ncProfileRowData);
        if (formEl) formEl.classList.remove('hidden');
      } catch (err) {
        console.error('NC Profile load error:', err);
        if (notFoundEl) { notFoundEl.querySelector('p:last-child').textContent = 'Error loading directory: ' + (err.message || 'Please try again.'); notFoundEl.classList.remove('hidden'); }
      }
    }

    function getRowVal(row, ...keys) {
      for (const k of keys) { const v = (row[k] || '').trim(); if (v) return v; }
      return '';
    }
    function populateProfileForm(row) {
      const opts = NC_PROFILE_OPTIONS;
      const ncCensusTract = document.getElementById('ncCensusTract');
      if (ncCensusTract) {
        ncCensusTract.innerHTML = '<option value="">‚Äî</option>' + (opts['Predominant Census Tract of Zone'] || []).map(v => '<option value="' + escapeHtmlAttr(v) + '">' + escapeHtml(v) + '</option>').join('');
        ncCensusTract.value = getRowVal(row, 'Predominant Census Tract of Zone', 'Census Tract');
      }
      const ncHousing = document.getElementById('ncHousing');
      if (ncHousing) {
        ncHousing.innerHTML = '<option value="">‚Äî</option>' + (opts['Housing Arrangement'] || []).map(v => '<option value="' + escapeHtmlAttr(v) + '">' + escapeHtml(v) + '</option>').join('');
        const housingVal = (row['Housing Arrangement'] || '').trim();
        ncHousing.value = housingVal === 'Owner' ? 'Homeowner' : housingVal;
      }
      const ncDamage = document.getElementById('ncDamage');
      if (ncDamage) {
        ncDamage.innerHTML = '<option value="">‚Äî</option>' + (opts['Damage to home'] || []).map(v => '<option value="' + escapeHtmlAttr(v) + '">' + escapeHtml(v) + '</option>').join('');
        ncDamage.value = (row['Damage to home'] || '').trim();
      }
      const ncWaterDistrict = document.getElementById('ncWaterDistrict');
      if (ncWaterDistrict) {
        ncWaterDistrict.innerHTML = '<option value="">‚Äî</option>' + (opts['Water Districts in Zone'] || []).map(v => '<option value="' + escapeHtmlAttr(v) + '">' + escapeHtml(v) + '</option>').join('');
        ncWaterDistrict.value = (row['Water Districts in Zone'] || '').trim();
      }
      document.getElementById('ncName').value = getRowVal(row, 'Name');
      document.getElementById('ncZone').value = getRowVal(row, 'Zone');
      const ncLocation = document.getElementById('ncLocation');
      if (ncLocation) ncLocation.value = getRowVal(row, 'Location');
      document.getElementById('ncPhone').value = getRowVal(row, 'Phone');
      document.getElementById('ncPreferredEmail').value = (row['Preferred email'] || '').trim();
      const ncNotesBio = document.getElementById('ncNotesBio');
      if (ncNotesBio) ncNotesBio.value = (row['Notes/Bio'] || '').trim();
      const ncExpertiseAskMe = document.getElementById('ncExpertiseAskMe');
      if (ncExpertiseAskMe) ncExpertiseAskMe.value = (row['Expertise (Ask Me About...)'] || '').trim();
      document.getElementById('ncLanguages').value = (row['Languages Spoken'] || '').trim();
      const wgContainer = document.getElementById('ncWorkingGroups');
      if (wgContainer) {
        const selected = parseMultiSelect(row['Working Group Participation']);
        wgContainer.innerHTML = (opts['Working Group Participation'] || []).map(opt => {
          const id = 'ncWg_' + opt.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
          const checked = selected.includes(opt) ? ' checked' : '';
          return '<label style="display:inline-flex;align-items:center;gap:0.35rem;margin-right:0.5rem;"><input type="checkbox" name="Working Group Participation" value="' + escapeHtmlAttr(opt) + '" id="' + id + '"' + checked + '> ' + escapeHtml(opt) + '</label>';
        }).join('');
      }
      const iaContainer = document.getElementById('ncInterestAreas');
      if (iaContainer) {
        const selected = parseMultiSelect(row['Interest Areas']);
        iaContainer.innerHTML = (opts['Interest Areas'] || []).map(opt => {
          const id = 'ncIa_' + opt.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '').slice(0, 30);
          const checked = selected.includes(opt) ? ' checked' : '';
          return '<label style="display:inline-flex;align-items:center;gap:0.35rem;margin-right:0.5rem;"><input type="checkbox" name="Interest Areas" value="' + escapeHtmlAttr(opt) + '" id="' + id + '"' + checked + '> ' + escapeHtml(opt) + '</label>';
        }).join('');
      }
      const ncDenaNative = document.getElementById('ncDenaNative');
      if (ncDenaNative) {
        const badges = parseMultiSelect(row['Badges'] || '');
        ncDenaNative.checked = badges.some(b => (b || '').trim().toLowerCase() === 'dena native');
      }
      const badgesEl = document.getElementById('ncBadgesReadOnly');
      if (badgesEl) {
        const badges = parseMultiSelect(row['Badges'] || '').filter(b => (b || '').trim().toLowerCase() !== 'dena native');
        if (badges.length) {
          badgesEl.textContent = 'Other badges (read-only): ' + badges.join(', ');
          badgesEl.classList.remove('hidden');
        } else {
          badgesEl.classList.add('hidden');
        }
      }
    }
    function escapeHtmlAttr(s) {
      if (s == null) return '';
      return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    async function saveNcProfile() {
      if (!accessToken || ncProfileRowIndex == null || !ncProfileRowData) return;
      const row = {};
      row['Name'] = (document.getElementById('ncName').value || '').trim();
      row['Zone'] = (document.getElementById('ncZone').value || '').trim();
      row['Location'] = (document.getElementById('ncLocation')?.value || '').trim();
      row['Predominant Census Tract of Zone'] = (document.getElementById('ncCensusTract').value || '').trim();
      row['Phone'] = (document.getElementById('ncPhone').value || '').trim();
      row['Preferred email'] = (document.getElementById('ncPreferredEmail').value || '').trim();
      row['Working Group Participation'] = formatMultiSelectForSheet(Array.from(document.querySelectorAll('#ncWorkingGroups input[type=checkbox]:checked')).map(cb => cb.value));
      row['Housing Arrangement'] = (document.getElementById('ncHousing').value || '').trim();
      row['Damage to home'] = (document.getElementById('ncDamage').value || '').trim();
      row['Notes/Bio'] = (document.getElementById('ncNotesBio')?.value || '').trim();
      row['Interest Areas'] = formatMultiSelectForSheet(Array.from(document.querySelectorAll('#ncInterestAreas input[type=checkbox]:checked')).map(cb => cb.value));
      row['Expertise (Ask Me About...)'] = (document.getElementById('ncExpertiseAskMe')?.value || '').trim();
      row['Languages Spoken'] = (document.getElementById('ncLanguages').value || '').trim();
      row['Google email'] = (ncProfileRowData['Google email'] || '').trim();
      row['Water Districts in Zone'] = (document.getElementById('ncWaterDistrict').value || '').trim();
      const existingBadges = parseMultiSelect(ncProfileRowData['Badges'] || '').filter(b => (b || '').trim().toLowerCase() !== 'dena native');
      if (document.getElementById('ncDenaNative')?.checked) existingBadges.push('dena native');
      row['Badges'] = formatMultiSelectForSheet(existingBadges);
      const colLetter = (i) => (i < 26 ? String.fromCharCode(65 + i) : String.fromCharCode(64 + Math.floor(i / 26)) + String.fromCharCode(65 + (i % 26)));
      const norm = (s) => (s || '').trim().toLowerCase();
      const findCol = (key) => {
        if (!ncProfileHeaders) return -1;
        const nk = norm(key);
        const idx = ncProfileHeaders.findIndex(h => norm(h) === nk);
        if (idx >= 0) return idx;
        const aliases = { 'predominant census tract of zone': ['census tract', 'predominant census tract'], 'notes/bio': ['notes', 'bio'] };
        for (const alt of (aliases[nk] || [])) {
          const i = ncProfileHeaders.findIndex(h => norm(h) === alt);
          if (i >= 0) return i;
        }
        return -1;
      };
      const data = [];
      for (const key of NC_PROFILE_HEADERS) {
        const colIdx = findCol(key);
        if (colIdx >= 0) {
          const range = 'Sheet1!' + colLetter(colIdx) + ncProfileRowIndex;
          data.push({ range: range, values: [[row[key] || '']] });
        }
      }
      if (data.length === 0 && ncProfileHeaders) {
        const rowValues = NC_PROFILE_HEADERS.map(h => row[h] || '');
        data.push({ range: 'Sheet1!A' + ncProfileRowIndex + ':P' + ncProfileRowIndex, values: [rowValues] });
      }
      const statusEl = document.getElementById('profileSaveStatus');
      const btn = document.getElementById('ncProfileSaveBtn');
      if (btn) btn.disabled = true;
      if (statusEl) { statusEl.textContent = 'Saving‚Ä¶'; statusEl.classList.remove('hidden'); }
      try {
        const res = await fetch('/api/sheets/batch-update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sheetId: NC_DIRECTORY_SHEET_ID,
            valueInputOption: 'USER_ENTERED',
            data: data
          })
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.message || err.error || 'Save failed');
        }
        if (statusEl) { statusEl.textContent = 'Saved.'; statusEl.style.color = 'var(--accent-altagether-green)'; }
        ncProfileRowData = row;
      } catch (e) {
        if (statusEl) { statusEl.textContent = 'Error: ' + (e.message || 'Could not save'); statusEl.style.color = 'var(--accent-clay)'; }
      }
      if (btn) btn.disabled = false;
    }

    document.getElementById('ncProfileSaveBtn')?.addEventListener('click', saveNcProfile);

    // Update sign-in UI
    function updateSignInUI() {
      const homeSigninPrompt = document.getElementById('homeSigninPrompt');
      
      if (accessToken) {
        signinPrompt.classList.add('hidden');
        if (homeSigninPrompt) homeSigninPrompt.classList.add('hidden');
        // Could add a sign-out button here if needed
      } else {
        // Always show sign-in prompt in floating panel when not signed in
        signinPrompt.classList.remove('hidden');
        // Show global sign-in overlay if spreadsheet is linked but not signed in (any tab)
        if (homeSigninPrompt && currentSheetUrl) {
          homeSigninPrompt.classList.remove('hidden');
        } else if (homeSigninPrompt) {
          homeSigninPrompt.classList.add('hidden');
        }
      }
      
      // Update welcome message to reflect sign-in state
      updateWelcomeMessage();
    }

    // Update sheet link label based on link status
    function updateSheetLinkLabel() {
      const label = document.getElementById('sheetLinkLabel');
      if (!label) return;
      
      if (currentSheetUrl) {
        // Spreadsheet is linked - show "Link spreadsheet" with subtle external link icon
        label.innerHTML = `Link spreadsheet <svg class="sheet-link-external-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" title="Open spreadsheet"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>`;
        // Add click handler to the icon
        const icon = label.querySelector('.sheet-link-external-icon');
        if (icon) {
          icon.style.cursor = 'pointer';
          icon.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            window.open(currentSheetUrl, '_blank', 'noopener,noreferrer');
          });
        }
      } else {
        // No spreadsheet linked
        label.textContent = 'Link your zone spreadsheet';
      }
    }

    // Update welcome message visibility and step progression
    function updateWelcomeMessage() {
      const welcomeOverlay = document.getElementById('welcomeOverlay');
      const welcomeStep1 = document.getElementById('welcomeStep1');
      const welcomeStep2 = document.getElementById('welcomeStep2');
      const welcomeStep1Status = document.getElementById('welcomeStep1Status');
      const welcomeSignInBtn = document.getElementById('welcomeSignInBtn');
      
      if (!welcomeOverlay) return;
      
      // Show welcome message only on home page when no spreadsheet is linked
      if (currentView === 'home' && !currentSheetUrl) {
        welcomeOverlay.classList.remove('hidden');
        document.body.classList.remove('dashboard-active');
        
        // Update step visibility based on sign-in state
        if (accessToken) {
          // User is signed in - show step 2, hide step 1 button
          if (welcomeStep1) {
            const btnContainer = welcomeSignInBtn?.parentElement;
            if (btnContainer && welcomeSignInBtn) {
              welcomeSignInBtn.classList.add('hidden');
            }
            if (welcomeStep1Status) {
              welcomeStep1Status.classList.remove('hidden');
            }
          }
          if (welcomeStep2) {
            welcomeStep2.classList.remove('hidden');
          }
        } else {
          // User not signed in - show step 1, hide step 2
          if (welcomeStep1) {
            const btnContainer = welcomeSignInBtn?.parentElement;
            if (btnContainer && welcomeSignInBtn) {
              welcomeSignInBtn.classList.remove('hidden');
            }
            if (welcomeStep1Status) {
              welcomeStep1Status.classList.add('hidden');
            }
          }
          if (welcomeStep2) {
            welcomeStep2.classList.add('hidden');
          }
        }
      } else {
        welcomeOverlay.classList.add('hidden');
        document.body.classList.add('dashboard-active');
      }
    }

    // Update header title based on zone name and spreadsheet link status
    function updateHeaderTitle() {
      const navHeaderZone = document.getElementById('navHeaderZone');
      if (!navHeaderZone) return;
      
      if (currentSheetUrl && currentZoneName) {
        // Strip "Zone" from the beginning if it's already there
        let zoneName = currentZoneName.trim();
        if (zoneName.toLowerCase().startsWith('zone ')) {
          zoneName = zoneName.substring(5).trim();
        }
        
        // Only add "Zone " prefix if the name is numeric (like "1", "2") or starts with a number
        // For custom names like "Alpine Villa", use the name as-is
        const isNumericZone = /^\d+$/.test(zoneName) || /^\d+/.test(zoneName);
        if (isNumericZone) {
          navHeaderZone.textContent = `Zone ${zoneName}`;
        } else {
          navHeaderZone.textContent = zoneName;
        }
      } else {
        navHeaderZone.textContent = 'Zone XX';
      }
    }

    // Update navigation disabled state
    function updateNavigationState() {
      const leftNav = document.querySelector('.left-nav');
      const navItems = document.querySelectorAll('.nav-item[data-view]');
      const sheetLinkSection = document.querySelector('.sheet-link-section');
      
      if (!currentSheetUrl) {
        // No spreadsheet linked - disable all navigation except Home
        if (leftNav) {
          leftNav.classList.add('disabled');
        }
        // Hide the sheet link section in left nav when welcome overlay is shown
        if (sheetLinkSection) {
          sheetLinkSection.classList.add('hidden');
        }
        navItems.forEach(item => {
          const viewName = item.getAttribute('data-view');
          if (viewName !== 'home') {
            item.disabled = true;
            item.style.pointerEvents = 'none';
          } else {
            item.disabled = false;
            item.style.pointerEvents = 'auto';
          }
        });
      } else {
        // Spreadsheet linked - enable all navigation
        if (leftNav) {
          leftNav.classList.remove('disabled');
        }
        // Show the sheet link section for changing spreadsheet
        if (sheetLinkSection) {
          sheetLinkSection.classList.remove('hidden');
        }
        navItems.forEach(item => {
          item.disabled = false;
          item.style.pointerEvents = 'auto';
        });
      }
    }

    // Sign in button handler
    signInBtn.addEventListener('click', signIn);

    // Home sign-in button handler (uses same signIn function)
    const homeSignInBtn = document.getElementById('homeSignInBtn');
    if (homeSignInBtn) {
      homeSignInBtn.addEventListener('click', signIn);
    }

    // Welcome sign-in button handler (uses same signIn function)
    const welcomeSignInBtn = document.getElementById('welcomeSignInBtn');
    if (welcomeSignInBtn) {
      welcomeSignInBtn.addEventListener('click', signIn);
    }

    // Extract sheet ID from any Google Sheets URL format
    function extractSheetId(sheetUrl) {
      // Handle published format: /spreadsheets/d/e/...
      const publishedMatch = sheetUrl.match(/\/spreadsheets\/d\/e\/([a-zA-Z0-9-_]+)/);
      if (publishedMatch) {
        return { sheetId: publishedMatch[1], isPublished: true };
      }
      
      // Handle standard format: /spreadsheets/d/...
      const standardMatch = sheetUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
      if (!standardMatch) {
        return null;
      }
      
      return { sheetId: standardMatch[1], isPublished: false };
    }

    // Convert Google Sheets URL to CSV export URL
    function getCsvUrl(sheetUrl) {
      const sheetInfo = extractSheetId(sheetUrl);
      if (!sheetInfo) {
        console.error('Could not parse Google Sheets URL:', sheetUrl);
        return null;
      }
      
      if (sheetInfo.isPublished) {
        // For published sheets, use /pub?output=csv
        const csvUrl = `https://docs.google.com/spreadsheets/d/e/${sheetInfo.sheetId}/pub?output=csv`;
        return csvUrl;
      }
      
      // For standard format, extract GID if present
      const gidMatch = sheetUrl.match(/[#&]gid=(\d+)/);
      const gid = gidMatch ? gidMatch[1] : '0';
      
      // Build CSV export URL
      const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetInfo.sheetId}/export?format=csv&gid=${gid}`;
      return csvUrl;
    }

    // Fetch data via backend proxy (service account)
    async function fetchViaOAuth(sheetId, range = 'A1:ZZ1000', sheetName = null) {
      const storedExpiry = localStorage.getItem('googleOAuthTokenExpiry');
      if (storedExpiry && Date.now() > parseInt(storedExpiry)) {
        accessToken = null;
        localStorage.removeItem('googleOAuthToken');
        localStorage.removeItem('googleOAuthTokenExpiry');
        throw new Error('Your session has expired. Please sign in again.');
      }
      if (!accessToken) {
        throw new Error('Not signed in. Please sign in to view data.');
      }
      const response = await fetch('/api/sheets/values', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sheetId, range, sheetName: sheetName || undefined })
      });
      if (!response.ok) {
        const err = await response.json().catch(() => ({}));
        if (response.status === 401) {
          accessToken = null;
          localStorage.removeItem('googleOAuthToken');
          localStorage.removeItem('googleOAuthTokenExpiry');
          throw new Error('Your session has expired. Please sign in again.');
        }
        throw new Error(err.message || err.error || 'Failed to fetch sheet values');
      }
      const data = await response.json();
      return (data.values || []);
    }

    // Fetch Zone Notes sheet (Zone Notes and KML URL)
    async function fetchMetadata(sheetId) {
      if (!accessToken) {
        return null;
      }
      
      try {
        // Try to fetch from "Zone Notes" sheet
        const metadataValues = await fetchViaOAuth(sheetId, 'A1:B10', 'Zone Notes');
        
        if (!metadataValues || metadataValues.length === 0) {
          return null;
        }
        
        let notes = '';
        let kmlUrl = '';
        
        // Parse metadata - look for "Zone Notes" and "KML URL" rows
        for (let i = 0; i < metadataValues.length; i++) {
          const row = metadataValues[i];
          if (row && row.length >= 2) {
            const key = (row[0] || '').toString().trim().toLowerCase();
            const value = (row[1] || '').toString().trim();
            
            if (key.includes('zone note') || key === 'notes') {
              notes = value;
            } else if (key.includes('kml') || key.includes('boundary')) {
              // Clean the URL - remove quotes, trim whitespace
              kmlUrl = value.replace(/^["']|["']$/g, '').trim();
            }
          }
        }
        
        return { notes, kmlUrl };
      } catch (error) {
        console.error('Error fetching Zone Notes sheet:', error);
        return null;
      }
    }

    // Parse CSV text to array of objects
    function parseCSV(csvText) {
      const lines = csvText.split('\n').filter(line => line.trim());
      if (lines.length === 0) return [];

      // Parse header
      const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
      
      // Parse data rows
      const data = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim().replace(/^"|"$/g, ''));
        if (values.length === 0 || values.every(v => !v)) continue;
        
        const row = {};
        headers.forEach((header, index) => {
          row[header] = values[index] || '';
        });
        data.push(row);
      }
      
      return { headers, data };
    }

    // Convert API response (array of arrays) to object format
    function parseApiData(apiValues) {
      if (!apiValues || apiValues.length === 0) return { headers: [], data: [] };
      
      const headers = apiValues[0].map(h => h.trim());
      const data = [];
      
      for (let i = 1; i < apiValues.length; i++) {
        const row = {};
        headers.forEach((header, index) => {
          row[header] = apiValues[i][index] || '';
        });
        // Only add row if it has at least one non-empty value
        if (Object.values(row).some(v => v.trim())) {
          data.push(row);
        }
      }
      
      return { headers, data };
    }

    // Fetch and process spreadsheet data
    async function loadAddressData(sheetUrl) {
      // Save current scroll position before refreshing (if we're refreshing, not initial load)
      if (sheetData.addressMap) {
        savedScrollPosition = addressPanelContent.scrollTop;
      }

      if (!addressPanelContent) {
        console.error('addressPanelContent element not found');
        return;
      }

      addressPanelContent.innerHTML = '<div class="loading">Loading addresses...</div>';

      // Require OAuth sign-in to read data
      if (!accessToken) {
        addressPanelContent.innerHTML = '<div class="error">Please sign in with Google to view data.</div>';
        // Show sign-in prompt
        if (signinPrompt) signinPrompt.classList.remove('hidden');
        return;
      }

      const sheetInfo = extractSheetId(sheetUrl);
      if (!sheetInfo) {
        addressPanelContent.innerHTML = '<div class="error">Invalid Google Sheets URL</div>';
        return;
      }
      
      try {
        let headers, data;
        
        // Use OAuth to fetch data (explicit Sheet1 so read and append always use same tab)
        try {
          const apiValues = await fetchViaOAuth(sheetInfo.sheetId, 'A1:ZZ1000', 'Sheet1');
          const parsed = parseApiData(apiValues);
          headers = parsed.headers;
          data = parsed.data;
          
          // Also fetch Zone Notes sheet
          metadataSheetId = sheetInfo.sheetId;
          const metadata = await fetchMetadata(sheetInfo.sheetId);
          if (metadata) {
            zoneNotes = metadata.notes || '';
            zoneKmlUrl = metadata.kmlUrl || '';
            updateZoneNotesUI();
            // Boundary loading (Mapbox or KML) happens after currentZoneName is set and map is ready
          }
        } catch (oauthError) {
          console.error('OAuth fetch failed:', oauthError);
          throw new Error(`Error loading data: ${oauthError.message}. Make sure you're signed in and have access to this sheet.`);
        }
        
        // No fallback - OAuth is required
        if (!headers || !data) {
          // Fall back to CSV export (requires published sheet)
          const csvUrl = getCsvUrl(sheetUrl);
          if (!csvUrl) {
            throw new Error('Could not generate CSV URL');
          }

          // Try direct fetch first, then CORS proxy if needed
          let csvText;
          try {
            const response = await fetch(csvUrl);
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            csvText = await response.text();
          } catch (error) {
            // If direct fetch fails, try CORS proxy
            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(csvUrl)}`;
            const proxyResponse = await fetch(proxyUrl);
            if (!proxyResponse.ok) {
              throw new Error(`Proxy fetch failed: ${proxyResponse.status}. Please sign in with Google.`);
            }
            csvText = await proxyResponse.text();
          }
          
          if (!csvText || csvText.trim().length === 0) {
            throw new Error('Spreadsheet appears to be empty or could not be accessed.');
          }
          
          const parsed = parseCSV(csvText);
          headers = parsed.headers;
          data = parsed.data;
        }
        
        if (data.length === 0) {
          addressPanelContent.innerHTML = '<div class="empty">No data found in spreadsheet</div>';
          return;
        }

        // Find address columns - prefer separate House # and Street, fallback to Address
        const houseNumCol = headers.find(h => {
          const lower = h.toLowerCase();
          // Match "House #" exactly (case-insensitive) or variations
          return h === 'House #' || 
                 lower === 'house #' ||
                 lower.includes('house #') || 
                 lower.includes('house#') ||
                 lower === 'house number' ||
                 lower === 'house num' ||
                 (lower === 'house' && !lower.includes('hold')); // "house" but not "household"
        });
        const streetCol = headers.find(h => {
          const lower = h.toLowerCase();
          // Match "Street" exactly (case-insensitive) or variations
          return h === 'Street' ||
                 lower === 'street' ||
                 (lower.includes('street') && !lower.includes('address'));
        });
        const addressCol = headers.find(h => {
          const lower = h.toLowerCase();
          return (lower.includes('address') || lower.includes('location')) &&
                 !lower.includes('email') && !lower.includes('phone');
        });

        // Helper function to get address string
        const getAddressString = (row) => {
          if (houseNumCol && streetCol) {
            const houseNum = (row[houseNumCol] || '').trim();
            const street = (row[streetCol] || '').trim();
            if (houseNum && street) {
              return `${houseNum} ${street}`;
            } else if (street) {
              return street;
            } else if (houseNum) {
              return houseNum;
            }
          }
          // Fallback to Address column if it exists
          if (addressCol) {
            return (row[addressCol] || '').trim();
          }
          return null;
        };

        // Check if we have at least one way to identify addresses
        if (!houseNumCol && !streetCol && !addressCol) {
          const availableCols = headers.slice(0, 10).join(', ');
          addressPanelContent.innerHTML = `<div class="error">No address columns found. Need either "House #" and "Street" columns, or an "Address" column. Available columns: ${availableCols || 'none'}</div>`;
          return;
        }

        // Group data by address, storing original row index with each row
        const addressMap = new Map();
        data.forEach((row, rowIndex) => {
          const address = getAddressString(row);
          if (!address) return;
          
          if (!addressMap.has(address)) {
            addressMap.set(address, []);
          }
          // Store row with its original index
          addressMap.get(address).push({ ...row, __originalIndex: rowIndex });
        });

        // Store data globally
        sheetData = { headers, data, addressMap, addressCol, houseNumCol, streetCol, getAddressString };
        
        // Re-initialize Contact List Creator if user is on Tools view and data just loaded
        if (currentView === 'tools') {
          setTimeout(() => {
            initializeContactListCreator();
          }, 100);
        }
        
        // Update header with Zone information
        const zoneCol = findColumn(headers, 'zone');
        // Store sheet ID for writing (sheetInfo already defined above)
        if (sheetInfo) {
          currentSheetId = sheetInfo.sheetId;
        }
        
        // Update sheet link label after successful load
        updateSheetLinkLabel();
        updateHeaderTitle();
        updateNavigationState();
        
        // Update sign-in UI
        updateSignInUI();
        
        // Reset filters when loading new data
        currentStreetFilter = 'all';
        currentDamageFilter = 'all';
        currentAddressPlanFilter = 'all';
        currentCaptainFilter = 'all';
        
        // Extract zone name from ZoneName column if available
        const zoneNameCol = headers.find(h => h.toLowerCase() === 'zonename' || h.toLowerCase() === 'zone name');
        if (zoneNameCol && data.length > 0 && data[0][zoneNameCol]) {
          currentZoneName = data[0][zoneNameCol].trim();
        } else {
          currentZoneName = '';
        }
        updateHeaderTitle();
        
        // If an address was selected, restore that view; otherwise show list
        if (selectedAddress && addressMap.has(selectedAddress)) {
          displayAddressDetails(selectedAddress, true); // true = preserve scroll
        } else {
          displayAddressList(Array.from(addressMap.keys()).sort());
          // Restore scroll position for list view
          setTimeout(() => {
            addressPanelContent.scrollTop = savedScrollPosition;
          }, 0);
        }
        
        // Populate persistent filter bar
        populateFilterBar();
        
        // Update table view if in people view
        if (currentView === 'people') {
          displayAddressTable();
        }
        
        // Update zone progress charts
        updateZoneProgressCharts();
        
        // Initialize or update map with addresses
        // Initialize map but don't update markers yet if map view isn't active
        initializeMap();
        // Load zone boundary (Mapbox first if configured, else KML from Zone Notes)
        loadZoneBoundary();
        refreshAdditionalMapboxLayer();

        // Only update map markers if we're currently on the map view
        if (currentView === 'map') {
          // Wait for map to be properly sized
          setTimeout(() => {
            if (zoneMap) {
              const mapDiv = document.getElementById('zoneMap');
              if (mapDiv && mapDiv.offsetParent !== null) {
                zoneMap.invalidateSize();
                setTimeout(() => {
                  updateMapMarkers();
                }, 100);
              }
            }
          }, 200);
        }
        
        // Only switch to home view if no view is set (initial load without saved view)
        // Don't override saved view - let the user stay on their chosen view
        if (!currentView) {
          switchView('home');
        }
        updateHomeDashboard();
        
        // If we're on map view, ensure color filter control exists and is restored
        if (currentView === 'map') {
          // Ensure watchdog is running
          startColorFilterWatchdog();
          
          setTimeout(() => {
            if (zoneMap) {
              // Always ensure color filter control exists after data loads
              ensureColorFilterControl();
              
              zoneMap.invalidateSize();
              setTimeout(() => {
                updateMapMarkers();
                // Restore color mode after control is ensured to exist
                restoreColorMode();
                
                // Final check after everything settles - ensure control is still there
                setTimeout(() => {
                  if (currentView === 'map' && zoneMap) {
                    ensureColorFilterControl();
                  }
                }, 500);
              }, 150);
            }
          }, 500); // Increased delay to ensure map container is fully visible
        }
        
      } catch (error) {
        console.error('Error loading spreadsheet:', error);
        const errorMsg = error.message || 'Unknown error';
        
        // Hide zone progress panel on error
        const panel = document.getElementById('zoneProgressPanel');
        if (panel) panel.classList.add('hidden');
        
        let helpText = '';
        if (errorMsg.includes('permission') || errorMsg.includes('does not have permission') || errorMsg.includes('sign in')) {
          helpText = `<br><br><strong>Solution:</strong><br>
            1. Click "Sign in with Google" above<br>
            2. Grant permission to access Google Sheets<br>
            3. Make sure you have access to the sheet (it should be shared with you or set to "Anyone with the link can edit")<br>
            4. Refresh and try again`;
        } else {
          helpText = `<br><br>Tips:<br>‚Ä¢ Sign in with Google to view and edit data<br>‚Ä¢ Make sure the sheet is shared with you or set to "Anyone with the link can edit"<br>‚Ä¢ Make sure the sheet has an "Address" column`;
        }
        
        addressPanelContent.innerHTML = `<div class="error">Error loading spreadsheet: ${errorMsg}${helpText}</div>`;
      }
    }

    // Normalize street name by removing unit numbers, suffixes, and other variations
    // normalizeStreet and extractStreet moved to js/utils.js

    // Sort rebuild statuses in sequential order (known stages first, then custom values alphabetically)
    function sortRebuildStatusesSequential(statuses) {
      const sequential = [];
      const custom = [];
      
      // First, add known sequential stages that exist in the data
      REBUILD_STAGES_SEQUENTIAL.forEach(stage => {
        if (statuses.some(s => s.toLowerCase().trim() === stage.toLowerCase().trim())) {
          // Find the exact match (preserving original case from data)
          const match = statuses.find(s => s.toLowerCase().trim() === stage.toLowerCase().trim());
          if (match) sequential.push(match);
        }
      });
      
      // Then add any custom statuses that aren't in the sequential list, sorted alphabetically
      statuses.forEach(status => {
        const statusLower = status.toLowerCase().trim();
        const isInSequential = REBUILD_STAGES_SEQUENTIAL.some(stage => 
          stage.toLowerCase().trim() === statusLower
        );
        if (!isInSequential) {
          custom.push(status);
        }
      });
      custom.sort();
      
      return [...sequential, ...custom];
    }
    
    // Get unique streets from all addresses
    function getUniqueStreets(addresses) {
      const streets = new Set();
      addresses.forEach(addr => {
        const street = extractStreet(addr);
        if (street) streets.add(street);
      });
      return Array.from(streets).sort();
    }

    // Full option lists for filters (always show all options; empty result is user's problem)
    const DEFAULT_DAMAGE_VALUES = ['Total Loss', 'Partial Loss', 'Standing'];
    const ADDRESS_PLAN_OPTIONS = ['Undecided', 'Building', 'Selling', 'Other', 'Unknown'];

    // Get all damage options for filter: full list always, then any custom values from data
    function getFullDamageOptions() {
      if (!sheetData || !sheetData.headers) return DEFAULT_DAMAGE_VALUES;
      const damageCol = findColumn(sheetData.headers, 'damage');
      if (!damageCol) return DEFAULT_DAMAGE_VALUES;
      const fromData = new Set();
      sheetData.data.forEach(row => {
        if (row[damageCol] !== undefined && row[damageCol] !== null) {
          const v = String(row[damageCol]).trim();
          if (v) fromData.add(v);
        }
      });
      const custom = Array.from(fromData).filter(d => !DEFAULT_DAMAGE_VALUES.some(def => def.toLowerCase() === d.toLowerCase())).sort();
      return [...DEFAULT_DAMAGE_VALUES, ...custom];
    }

    // Get all Address Plan options for filter (only shown when Damage = Partial/Total Loss)
    function getFullAddressPlanOptions() {
      if (!sheetData || !sheetData.headers) return [...ADDRESS_PLAN_OPTIONS];
      const addressPlanCol = findColumn(sheetData.headers, ['address', 'plan'], ['note']);
      if (!addressPlanCol) return [...ADDRESS_PLAN_OPTIONS];
      const fromData = new Set();
      sheetData.data.forEach(row => {
        if (row[addressPlanCol] !== undefined && row[addressPlanCol] !== null) {
          const v = String(row[addressPlanCol]).trim();
          if (v) fromData.add(v);
        }
      });
      const custom = Array.from(fromData).filter(s => !ADDRESS_PLAN_OPTIONS.some(def => def.toLowerCase() === s.toLowerCase())).sort();
      return [...ADDRESS_PLAN_OPTIONS, ...custom];
    }

    // Normalize rebuild status label (remove spaces around slashes) for consistent display
    function normalizeRebuildStatusLabel(str) {
      if (!str || typeof str !== 'string') return str || '';
      return str.trim().replace(/\s*\/\s*/g, '/');
    }

    // Get all rebuild status options for filter: full sequential list first, then any custom from data
    function getFullRebuildStatusOptions() {
      if (!sheetData || !sheetData.headers) return [...REBUILD_STAGES_SEQUENTIAL];
    const rebuildCol = findColumn(sheetData.headers, ['build', 'status'], ['intent']);
      if (!rebuildCol) return [...REBUILD_STAGES_SEQUENTIAL];
      const fromData = new Set();
      sheetData.data.forEach(row => {
        if (row[rebuildCol] !== undefined && row[rebuildCol] !== null) {
          const v = String(row[rebuildCol]).trim();
          if (v) fromData.add(normalizeRebuildStatusLabel(v));
        }
      });
      const custom = Array.from(fromData).filter(s => !REBUILD_STAGES_SEQUENTIAL.some(stage => stage.toLowerCase().trim() === s.toLowerCase().trim())).sort();
      return [...REBUILD_STAGES_SEQUENTIAL, ...custom];
    }

    // Get unique damage values from all addresses (legacy; filter bar uses getFullDamageOptions)
    function getUniqueDamage(addresses) {
      const damageCol = findColumn(sheetData.headers, 'damage');
      if (!damageCol) return [];
      return getFullDamageOptions();
    }

    // Get unique Address Plan values (legacy)
    function getUniqueAddressPlan(addresses) {
      return getFullAddressPlanOptions();
    }

    // Parse multiple captains from semicolon-separated values in NC Name, NC Phone, NC Email columns
    function parseCaptains(ncName, ncPhone, ncEmail) {
      if (!ncName || !ncName.trim()) {
        return [];
      }
      
      // Split each field by semicolon and trim whitespace
      const names = (ncName || '').split(';').map(s => s.trim()).filter(s => s);
      const phones = (ncPhone || '').split(';').map(s => s.trim()).filter(s => s);
      const emails = (ncEmail || '').split(';').map(s => s.trim()).filter(s => s);
      
      // Find the maximum count to handle mismatched counts gracefully
      const maxCount = Math.max(names.length, phones.length, emails.length);
      
      // Match up by position: name[0] with phone[0] and email[0], etc.
      const captains = [];
      for (let i = 0; i < maxCount; i++) {
        captains.push({
          name: names[i] || 'N/A',
          phone: phones[i] || 'N/A',
          email: emails[i] || 'N/A'
        });
      }
      
      return captains;
    }

    // Check if an address has any contacted people
    function isAddressContacted(address) {
      const contactDateCol = findColumn(sheetData.headers, ['contact', 'date']);
      if (!contactDateCol) return false;
      
      const rows = sheetData.addressMap.get(address);
      if (!rows || rows.length === 0) return false;
      
      // Check if any person at this address has a contact date
      return rows.some(row => {
        const contactDate = row[contactDateCol];
        return contactDate !== undefined && contactDate !== null && String(contactDate).trim() !== '';
      });
    }

    // Check if an address needs follow-up
    function isAddressNeedsFollowup(address) {
      const rows = sheetData.addressMap.get(address);
      if (!rows || rows.length === 0) return false;
      
      // Check for columns that might indicate needs follow-up
      return rows.some(row => {
        return Object.keys(row).some(col => {
          const lowerCol = col.toLowerCase();
          const lowerValue = String(row[col] || '').toLowerCase().trim();
          
          // Check if column name or value contains "needs follow-up", "follow-up", "follow up", etc.
          if (lowerCol.includes('follow') || lowerCol.includes('followup') || lowerCol.includes('follow-up')) {
            // If column name indicates follow-up, check if value is positive
            return lowerValue === 'yes' || lowerValue === 'true' || lowerValue === '1' || 
                   (lowerValue !== '' && lowerValue !== 'no' && lowerValue !== 'false' && lowerValue !== '0');
          }
          // Check if value itself indicates needs follow-up
          if (lowerValue.includes('needs follow-up') || lowerValue.includes('follow-up needed') || 
              lowerValue.includes('needs followup') || lowerValue === 'follow-up') {
            return true;
          }
          return false;
        });
      });
    }

    // Check if an address is a renter
    function isAddressRenter(address) {
      const rows = sheetData.addressMap.get(address);
      if (!rows || rows.length === 0) return false;
      
      // Check columns that might indicate renter status (Renter checkbox, etc.)
      return rows.some(row => {
        return Object.keys(row).some(col => {
          const lowerCol = col.toLowerCase();
          const lowerValue = String(row[col] || '').toLowerCase().trim();
          
          
          // Check if column name or value contains "renter", "rent", "tenant", "own/rent", etc.
          if (lowerCol.includes('renter') || lowerCol.includes('rent') || lowerCol.includes('tenant') || 
              lowerCol.includes('own/rent') || lowerCol.includes('ownership')) {
            // If column name indicates renter/rent, check if value is positive
            if (lowerValue && lowerValue !== 'no' && lowerValue !== 'false' && lowerValue !== '0') {
              return lowerValue.includes('rent') || lowerValue.includes('renter') || 
                     lowerValue.includes('tenant') || lowerValue === 'r' || lowerValue === 'rental' ||
                     lowerValue === 'yes' || lowerValue === 'true' || lowerValue === '1';
            }
          }
          // Check if value itself indicates renter (anywhere in the data)
          if (lowerValue && (lowerValue.includes('renter') || lowerValue.includes('rent') || 
                             lowerValue === 'rental' || lowerValue.includes('tenant') || lowerValue === 'r')) {
            return true;
          }
          return false;
        });
      });
    }

    // Get damage value for an address
    function getAddressDamage(address) {
      const damageCol = findColumn(sheetData.headers, 'damage');
      if (!damageCol) return null;
      const rows = sheetData.addressMap.get(address);
      if (rows && rows.length > 0) {
        return rows[0][damageCol]?.trim() || null;
      }
      return null;
    }

    // Get Address Plan value for an address (only applies when Damage = Partial/Total Loss)
    function getAddressPlan(address) {
      const addressPlanCol = findColumn(sheetData.headers, ['address', 'plan'], ['note']);
      if (!addressPlanCol) return null;
      const rows = sheetData.addressMap.get(address);
      if (rows && rows.length > 0) {
        return rows[0][addressPlanCol]?.trim() || null;
      }
      return null;
    }

    // Get captain assigned value for an address
    function getAddressCaptainAssigned(address) {
      const captainAssignedCol = findColumn(sheetData.headers, 'captain assigned');
      if (!captainAssignedCol) return null;
      const rows = sheetData.addressMap.get(address);
      if (rows && rows.length > 0) {
        return rows[0][captainAssignedCol]?.trim() || null;
      }
      return null;
    }

    // Get rebuild status value for an address (normalized for display: no spaces around slashes)
    function getAddressRebuildStatus(address) {
    const rebuildCol = findColumn(sheetData.headers, ['build', 'status'], ['intent']);
      if (!rebuildCol) return null;
      const rows = sheetData.addressMap.get(address);
      if (rows && rows.length > 0) {
        const raw = rows[0][rebuildCol]?.trim() || null;
        return raw ? normalizeRebuildStatusLabel(raw) : null;
      }
      return null;
    }

    // Calculate quick actions based on spreadsheet data
    function calculateQuickActions() {
      if (!sheetData || !sheetData.addressMap) {
        return {
          uncontactedCount: 0,
          noDamageStatusCount: 0,
          followupPeople: []
        };
      }

      const headers = sheetData.headers;
      const addressMap = sheetData.addressMap;
      
      // Find contact columns (same logic as Zone Overview)
      const contactStatusCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('contact status');
      });
      const contactDateCol = headers.find(h => {
        const lower = h.toLowerCase();
        return (lower.includes('contact') && lower.includes('date')) ||
               lower.includes('last contact');
      });
      
      // Find follow-up column
      const followupCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('follow') && (lower.includes('up') || lower.includes('-up'));
      });
      
      // Find resident name column (same pattern as displayAddressDetails)
      const nameCol = headers.find(h => 
        h.toLowerCase().includes('resident name') || 
        (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name') && 
         !h.toLowerCase().includes('first') && !h.toLowerCase().includes('last') && 
         !h.toLowerCase().includes('middle'))
      );
      
      let uncontactedCount = 0;
      let noDamageStatusCount = 0;
      const followupPeople = [];

      addressMap.forEach((rows, address) => {
        // Count uncontacted addresses using exact same logic as Zone Overview
        const row = rows[0];
        let isContacted = false;
        
        if (contactStatusCol && row[contactStatusCol]) {
          const status = String(row[contactStatusCol]).toLowerCase().trim();
          isContacted = status && !status.includes('uncontacted') && status !== 'no';
        } else if (contactDateCol && row[contactDateCol]) {
          const date = String(row[contactDateCol]).trim();
          isContacted = date.length > 0;
        }
        
        if (!isContacted) {
          uncontactedCount++;
        }

        // Count addresses with no damage status
        const damage = getAddressDamage(address);
        if (!damage || damage.trim() === '' || damage === '(not set)') {
          noDamageStatusCount++;
        }
        
        // Find people who need follow-up
        if (followupCol) {
          rows.forEach((personRow) => {
            const followupValue = (personRow[followupCol] || '').toString().trim();
            const followupValueLower = followupValue.toLowerCase();
            const isFollowupChecked = followupValueLower === 'true' || followupValue === 'TRUE' || 
                                     followupValueLower === 'yes' || 
                                     (followupValue !== '' && followupValueLower !== 'false' && 
                                      followupValue !== 'FALSE' && followupValueLower !== 'no');
            
            if (isFollowupChecked) {
              const personName = nameCol ? (personRow[nameCol] || '').trim() : '';
              if (personName) {
                followupPeople.push({
                  name: personName,
                  address: address
                });
              }
            }
          });
        }
      });

      return {
        uncontactedCount,
        noDamageStatusCount,
        followupPeople
      };
    }

    // Navigate to uncontacted addresses view
    function navigateToUncontactedAddresses() {
      // Reset all filters first
      currentStreetFilter = 'all';
      currentDamageFilter = 'all';
      currentAddressPlanFilter = 'all';
      currentRebuildFilter = 'all';
      currentCaptainFilter = 'all';
      // Set contact filters
      showUncontactedAddresses = true;
      showContactedAddresses = false;
      switchView('people');
      populateFilterBar();
      displayAddressTable();
    }

    // Navigate to addresses without damage status view
    function navigateToAddressesWithoutDamageStatus() {
      // Reset all filters first
      currentStreetFilter = 'all';
      currentDamageFilter = ''; // Empty string for "(not set)"
      currentAddressPlanFilter = 'all';
      currentRebuildFilter = 'all';
      currentCaptainFilter = 'all';
      // Reset contact filters to show all
      showUncontactedAddresses = true;
      showContactedAddresses = true;
      switchView('map');
      populateFilterBar();
      // Map view will automatically apply filters and update markers
    }

    // Navigate to a specific address and select it
    function navigateToAddress(address) {
      // Reset all filters
      currentStreetFilter = 'all';
      currentDamageFilter = 'all';
      currentAddressPlanFilter = 'all';
      currentRebuildFilter = 'all';
      currentCaptainFilter = 'all';
      showUncontactedAddresses = true;
      showContactedAddresses = true;
      switchView('people');
      populateFilterBar();
      displayAddressTable();
      // Select the address after a short delay to ensure the table is rendered
      setTimeout(() => {
        displayAddressDetails(address);
      }, 100);
    }

    // Display quick actions panel
    function displayQuickActions() {
      const content = document.getElementById('quickActionsContent');
      if (!content) return;

      if (!sheetData || !sheetData.addressMap) {
        content.innerHTML = '<div class="loading">Loading quick actions...</div>';
        return;
      }

      const actions = calculateQuickActions();
      let html = '';
      let hasActions = false;

      // Uncontacted addresses action
      if (actions.uncontactedCount > 0) {
        hasActions = true;
        html += `
          <div class="quick-action-item">
            <div class="quick-action-text">
              There are <strong>${actions.uncontactedCount}</strong> address${actions.uncontactedCount !== 1 ? 'es' : ''} you haven't contacted. Contact 3 of them right now.
            </div>
            <div class="quick-action-links">
              <a href="#" class="quick-action-link" id="showUncontactedLink">see uncontacted addresses</a>
              <a href="https://docs.google.com/document/d/1hP1N5eXjddsZfFj9GQHjIokVfAvf_Ir4gcb7bVSOFRI/view" target="_blank" rel="noopener noreferrer" class="quick-action-link">sample script</a>
            </div>
          </div>
        `;
      }

      // Missing damage status action
      if (actions.noDamageStatusCount > 0) {
        hasActions = true;
        html += `
          <div class="quick-action-item">
            <div class="quick-action-text">
              There are <strong>${actions.noDamageStatusCount}</strong> address${actions.noDamageStatusCount !== 1 ? 'es' : ''} with no Damage Status assigned. Update 5 addresses now.
            </div>
            <div class="quick-action-links">
              <a href="#" class="quick-action-link" id="showNoDamageStatusLink">see addresses without damage status</a>
            </div>
          </div>
        `;
      }

      // Follow-up people action
      if (actions.followupPeople && actions.followupPeople.length > 0) {
        hasActions = true;
        const peopleNames = actions.followupPeople.map((person, index) => {
          return `<a href="#" class="quick-action-link person-link" data-address="${person.address.replace(/"/g, '&quot;')}">${person.name}</a>`;
        }).join(', ');
        
        html += `
          <div class="quick-action-item">
            <div class="quick-action-text">
              You have <strong>${actions.followupPeople.length}</strong> ${actions.followupPeople.length !== 1 ? 'people' : 'person'} who ${actions.followupPeople.length !== 1 ? 'need' : 'needs'} a follow-up. Follow up with 1 of them now.
            </div>
            <div class="quick-action-text" style="margin-top: 8px; font-size: 0.9rem;">
              ${peopleNames}
            </div>
          </div>
        `;
      }

      if (!hasActions) {
        html = '<div class="empty">No quick actions at this time.</div>';
      }

      // Add "More Actions" link at the bottom
      html += `
        <div class="quick-action-more" style="margin-top: 16px; padding-top: 16px; border-top: 2px solid rgba(96, 108, 56, 0.2); text-align: center;">
          <a href="#" class="quick-action-link" id="moreActionsLink" style="font-size: 1rem;">More Actions ‚Üí</a>
        </div>
      `;

      content.innerHTML = html;

      // Add event listeners for navigation links
      const uncontactedLink = document.getElementById('showUncontactedLink');
      if (uncontactedLink) {
        uncontactedLink.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToUncontactedAddresses();
        });
      }

      const noDamageStatusLink = document.getElementById('showNoDamageStatusLink');
      if (noDamageStatusLink) {
        noDamageStatusLink.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToAddressesWithoutDamageStatus();
        });
      }

      // Add event listeners for person name links
      document.querySelectorAll('.person-link').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const address = link.getAttribute('data-address');
          if (address) {
            navigateToAddress(address);
          }
        });
      });

      // Add event listener for "More Actions" link
      const moreActionsLink = document.getElementById('moreActionsLink');
      if (moreActionsLink) {
        moreActionsLink.addEventListener('click', (e) => {
          e.preventDefault();
          switchView('meetups');
        });
      }
    }

    // Display quick actions on Actions page
    async function displayActionsPage() {
      const content = document.getElementById('actionsPageContent');
      if (!content) return;

      content.innerHTML = '<div class="loading">Loading actions...</div>';

      // Fetch custom actions from spreadsheet (4th column)
      let customActionsHtml = await fetchAndDisplayActions();
      const hasCustomActions = customActionsHtml && !customActionsHtml.includes('empty') && !customActionsHtml.includes('error');

      // Build calculated actions (distribute across first 3 columns)
      const calculatedActions = [];
      let hasCalculatedActions = false;

      if (sheetData && sheetData.addressMap) {
        const actions = calculateQuickActions();

        // Uncontacted addresses action
        if (actions.uncontactedCount > 0) {
          hasCalculatedActions = true;
          calculatedActions.push(`
            <div class="action-card">
              <div class="action-card-title">Contact Uncontacted Addresses</div>
              <div class="action-card-content">
                There are <strong>${actions.uncontactedCount}</strong> address${actions.uncontactedCount !== 1 ? 'es' : ''} you haven't contacted. Contact 3 of them right now.
              </div>
              <div class="action-card-links">
                <a href="#" class="action-card-link" id="actionsPageUncontactedLink">see uncontacted addresses</a>
                <a href="https://docs.google.com/document/d/1hP1N5eXjddsZfFj9GQHjIokVfAvf_Ir4gcb7bVSOFRI/view" target="_blank" rel="noopener noreferrer" class="action-card-link">sample script</a>
              </div>
            </div>
          `);
        }

        // Missing damage status action
        if (actions.noDamageStatusCount > 0) {
          hasCalculatedActions = true;
          calculatedActions.push(`
            <div class="action-card">
              <div class="action-card-title">Update Damage Status</div>
              <div class="action-card-content">
                There are <strong>${actions.noDamageStatusCount}</strong> address${actions.noDamageStatusCount !== 1 ? 'es' : ''} with no Damage Status assigned. Update 5 addresses now.
              </div>
              <div class="action-card-links">
                <a href="#" class="action-card-link" id="actionsPageNoDamageStatusLink">see addresses without damage status</a>
              </div>
            </div>
          `);
        }

        // Follow-up people action
        if (actions.followupPeople && actions.followupPeople.length > 0) {
          hasCalculatedActions = true;
          const peopleNames = actions.followupPeople.map((person, index) => {
            return `<a href="#" class="quick-action-link person-link" data-address="${person.address.replace(/"/g, '&quot;')}">${person.name}</a>`;
          }).join(', ');
          
          calculatedActions.push(`
            <div class="action-card">
              <div class="action-card-title">Follow-up Needed</div>
              <div class="action-card-content">
                You have <strong>${actions.followupPeople.length}</strong> ${actions.followupPeople.length !== 1 ? 'people' : 'person'} who ${actions.followupPeople.length !== 1 ? 'need' : 'needs'} a follow-up. Follow up with 1 of them now.
              </div>
              <div class="action-card-people-list">
                ${peopleNames}
              </div>
            </div>
          `);
        }

        // Share Altagether Newsletter action (always shown)
        hasCalculatedActions = true;
        calculatedActions.push(`
          <div class="action-card">
            <div class="action-card-title">Share Altagether Newsletter</div>
            <div class="action-card-content">
              Share the latest Altagether newsletter with your neighbors. Get a list of email addresses from your spreadsheet and share the newsletter link.
            </div>
            <div class="action-card-links">
              <a href="#" class="action-card-link" id="shareNewsletterLink">get email addresses</a>
              <a href="https://altagether.org/newsletter" target="_blank" rel="noopener noreferrer" class="action-card-link">view newsletter</a>
            </div>
          </div>
        `);
      }

      // Distribute calculated actions across first 3 columns
      const columns = [[], [], [], []]; // 4 columns
      
      calculatedActions.forEach((action, index) => {
        // Distribute evenly across first 3 columns
        columns[index % 3].push(action);
      });
      
      // 4th column gets custom actions
      if (hasCustomActions) {
        columns[3].push(customActionsHtml);
      }

      // Build HTML with 4 columns
      let html = '';
      if (!hasCalculatedActions && !hasCustomActions) {
        html = '<div class="empty">No actions available at this time.</div>';
      } else {
        const columnHtml = columns.map(col => 
          `<div class="actions-column">${col.join('')}</div>`
        ).join('');
        html = `<div class="actions-page-container">${columnHtml}</div>`;
      }

      content.innerHTML = html;

      // Add event listeners for navigation links
      const uncontactedLink = document.getElementById('actionsPageUncontactedLink');
      if (uncontactedLink) {
        uncontactedLink.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToUncontactedAddresses();
        });
      }

      const noDamageStatusLink = document.getElementById('actionsPageNoDamageStatusLink');
      if (noDamageStatusLink) {
        noDamageStatusLink.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToAddressesWithoutDamageStatus();
        });
      }

      // Add event listeners for person name links (same class as Home Quick Actions for consistent styling)
      document.querySelectorAll('#actionsPageContent .person-link').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const address = link.getAttribute('data-address');
          if (address) {
            navigateToAddress(address);
          }
        });
      });

      // Add event listener for Share Newsletter link
      const shareNewsletterLink = document.getElementById('shareNewsletterLink');
      if (shareNewsletterLink) {
        shareNewsletterLink.addEventListener('click', (e) => {
          e.preventDefault();
          showNewsletterEmailGuide();
        });
      }
    }

    // Show newsletter email guide modal
    function showNewsletterEmailGuide() {
      if (!sheetData || !sheetData.addressMap) {
        alert('Please load your spreadsheet first to extract email addresses.');
        return;
      }

      // Find email column
      const headers = sheetData.headers;
      const emailCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('email address') || (lower.includes('email') && !lower.includes('nc email'));
      });

      if (!emailCol) {
        alert('No email address column found in your spreadsheet. Please make sure you have a column with "Email" or "Email Address" in the name.');
        return;
      }

      // Extract unique email addresses
      const emailSet = new Set();
      sheetData.data.forEach(row => {
        const email = (row[emailCol] || '').trim();
        if (email && email.includes('@')) {
          // Basic email validation
          emailSet.add(email.toLowerCase());
        }
      });

      const emails = Array.from(emailSet).sort();
      const emailCount = emails.length;

      if (emailCount === 0) {
        alert('No email addresses found in your spreadsheet. Please make sure the email column contains valid email addresses.');
        return;
      }

      // Create modal HTML
      const modalHTML = `
        <div class="newsletter-modal-overlay" id="newsletterModalOverlay">
          <div class="newsletter-modal">
            <button class="newsletter-modal-close" id="newsletterModalClose">&times;</button>
            <div class="newsletter-modal-header">
              <h3 class="newsletter-modal-title">Share Altagether Newsletter</h3>
              <p class="newsletter-modal-subtitle">Get email addresses and share the latest newsletter with your neighbors</p>
            </div>
            <div class="newsletter-modal-content">
              <div class="newsletter-modal-section">
                <h4 class="newsletter-modal-section-title">Step 1: Copy Email Addresses</h4>
                <div class="newsletter-modal-instructions">
                  <p>We found <strong>${emailCount}</strong> unique email address${emailCount !== 1 ? 'es' : ''} in your spreadsheet. Copy them below:</p>
                </div>
                <div class="newsletter-email-count">${emailCount} email address${emailCount !== 1 ? 'es' : ''} found</div>
                <div class="newsletter-email-list" id="newsletterEmailList">${emails.join(', ')}</div>
              </div>
              <div class="newsletter-modal-section">
                <h4 class="newsletter-modal-section-title">Step 2: Share the Newsletter</h4>
                <div class="newsletter-modal-instructions">
                  <ol>
                    <li>Copy the email addresses above (click the "Copy All Emails" button)</li>
                    <li>Open your email client (Gmail, Outlook, etc.)</li>
                    <li>Paste the email addresses into the "To" field</li>
                    <li>Click the "View Newsletter" button below to get the latest newsletter link</li>
                    <li>Share the newsletter link: <strong>https://altagether.org/newsletter</strong></li>
                  </ol>
                </div>
              </div>
            </div>
            <div class="newsletter-modal-actions">
              <button class="btn-copy-emails" id="copyEmailsBtn">Copy All Emails</button>
              <a href="https://altagether.org/newsletter" target="_blank" rel="noopener noreferrer" class="btn-newsletter-link">View Newsletter</a>
            </div>
          </div>
        </div>
      `;

      // Remove existing modal if any
      const existingModal = document.getElementById('newsletterModalOverlay');
      if (existingModal) {
        existingModal.remove();
      }

      // Add modal to page
      document.body.insertAdjacentHTML('beforeend', modalHTML);

      // Add event listeners
      const modalOverlay = document.getElementById('newsletterModalOverlay');
      const closeBtn = document.getElementById('newsletterModalClose');
      const copyBtn = document.getElementById('copyEmailsBtn');

      // Close on overlay click
      modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) {
          modalOverlay.remove();
        }
      });

      // Close on close button click
      closeBtn.addEventListener('click', () => {
        modalOverlay.remove();
      });

      // Copy emails button
      copyBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(emails.join(', '));
          copyBtn.textContent = '‚úì Copied!';
          copyBtn.style.background = 'linear-gradient(135deg, #4caf50 0%, #388e3c 100%)';
          setTimeout(() => {
            copyBtn.textContent = 'Copy All Emails';
            copyBtn.style.background = 'linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%)';
          }, 2000);
        } catch (err) {
          // Fallback for older browsers
          const textArea = document.createElement('textarea');
          textArea.value = emails.join(', ');
          textArea.style.position = 'fixed';
          textArea.style.opacity = '0';
          document.body.appendChild(textArea);
          textArea.select();
          try {
            document.execCommand('copy');
            copyBtn.textContent = '‚úì Copied!';
            copyBtn.style.background = 'linear-gradient(135deg, #4caf50 0%, #388e3c 100%)';
            setTimeout(() => {
              copyBtn.textContent = 'Copy All Emails';
              copyBtn.style.background = 'linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%)';
            }, 2000);
          } catch (fallbackErr) {
            alert('Failed to copy. Please manually select and copy the email addresses.');
          }
          document.body.removeChild(textArea);
        }
      });

      // Close on Escape key
      document.addEventListener('keydown', function escapeHandler(e) {
        if (e.key === 'Escape' && modalOverlay && document.body.contains(modalOverlay)) {
          modalOverlay.remove();
          document.removeEventListener('keydown', escapeHandler);
        }
      });
    }

    // Geocode an address string with Mapbox Geocoding API; returns { lat, lon } or null
    async function geocodeWithMapbox(addressString) {
      if (!addressString || !addressString.trim()) return null;
      if (!MAPBOX_CONFIG.accessToken) return null;
      try {
        const query = encodeURIComponent(addressString.trim());
        const proximity = '-118.15,34.19'; // Altadena area to bias results
        const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${query}.json?access_token=${MAPBOX_CONFIG.accessToken}&limit=1&types=address&proximity=${proximity}`;
        const res = await fetch(url);
        if (!res.ok) return null;
        const data = await res.json();
        const feature = data.features && data.features[0];
        if (!feature || !feature.geometry || !feature.geometry.coordinates) return null;
        const [lon, lat] = feature.geometry.coordinates;
        return { lat, lon };
      } catch (e) {
        console.warn('Mapbox geocode failed:', e);
        return null;
      }
    }

    // Append rows to the main data sheet via Google Sheets API
    async function appendRowsToSheet(rows) {
      if (!currentSheetId || !accessToken || !rows || rows.length === 0) {
        throw new Error('Not signed in or no sheet loaded.');
      }
      const range = 'Sheet1!A1:ZZ'; // append to first sheet
      const res = await fetch('/api/sheets/append', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sheetId: currentSheetId, values: rows })
      });
      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        throw new Error(err.message || err.error || 'Failed to add record to spreadsheet.');
      }
    }

    // Build one row array in header order from a key-value map
    function buildRowForHeaders(headers, valuesByColumn) {
      return headers.map(h => (valuesByColumn[h] != null && valuesByColumn[h] !== '') ? String(valuesByColumn[h]).trim() : '');
    }

    // Parse leading house number from address string for sorting (e.g. "123 Main St" -> 123)
    function parseHouseNumber(address) {
      if (!address || typeof address !== 'string') return 0;
      const m = address.trim().match(/^(\d+)/);
      return m ? parseInt(m[1], 10) : 0;
    }

    // Sort addresses by street name then house number (numeric)
    function sortAddressesByStreetThenNumber(addresses) {
      if (!addresses || !addresses.length) return [];
      return [...addresses].sort((a, b) => {
        const streetA = extractStreet(a);
        const streetB = extractStreet(b);
        if (streetA !== streetB) return (streetA || '').localeCompare(streetB || '');
        return (parseHouseNumber(a) || 0) - (parseHouseNumber(b) || 0);
      });
    }

    // Get predominant city, state, zip from sheet for pre-filling Add Record
    function getPredominantLocation() {
      if (!sheetData || !sheetData.headers || !sheetData.data || !sheetData.data.length) return { city: '', state: '', zip: '' };
      const headers = sheetData.headers;
      const cityCol = headers.find(h => /^city$/i.test(h));
      const stateCol = headers.find(h => /^state$/i.test(h));
      const zipCol = headers.find(h => /zip|postal/i.test(h));
      const count = (arr) => {
        const m = new Map();
        arr.forEach(v => { const x = (v || '').trim(); if (x) m.set(x, (m.get(x) || 0) + 1); });
        let best = '', max = 0;
        m.forEach((n, v) => { if (n > max) { max = n; best = v; } });
        return best;
      };
      const city = cityCol ? count(sheetData.data.map(r => r[cityCol])) : '';
      const state = stateCol ? count(sheetData.data.map(r => r[stateCol])) : '';
      const zip = zipCol ? count(sheetData.data.map(r => r[zipCol])) : '';
      return { city, state, zip };
    }

    // In-app success toast (avoids browser alert and "origin says" title)
    function showAppToast(message) {
      const existing = document.getElementById('appToast');
      if (existing) existing.remove();
      const toast = document.createElement('div');
      toast.id = 'appToast';
      toast.className = 'app-toast';
      toast.innerHTML = `<span class="app-toast-title">Altagether Zone Dashboard</span><div>${escapeHtml(message)}</div>`;
      toast.addEventListener('click', () => toast.remove());
      document.body.appendChild(toast);
      setTimeout(() => { if (toast.parentNode) toast.remove(); }, 4500);
    }

    // Show Add Record modal (v2: flexible flow, geocode + minimap, no "spreadsheet" copy)
    function showAddRecordModal() {
      if (!sheetData || !sheetData.headers || !sheetData.addressMap) {
        alert('Please load your zone data first.');
        return;
      }
      if (!accessToken || !currentSheetId) {
        alert('Please sign in with Google to add records.');
        return;
      }
      const headers = sheetData.headers;
      const addresses = sortAddressesByStreetThenNumber(Array.from(sheetData.addressMap.keys()));
      const predominantLoc = getPredominantLocation();
      const cityStateZip = [predominantLoc.city, predominantLoc.state, predominantLoc.zip].filter(Boolean).join(', ');
      const uniqueStreets = [...new Set(addresses.map(addr => extractStreet(addr)))].filter(Boolean).sort();
      const houseNumCol = sheetData.houseNumCol || headers.find(h => /house\s*#?/i.test(h));
      const streetCol = sheetData.streetCol || headers.find(h => h.toLowerCase() === 'street');
      const addressCol = sheetData.addressCol;
      const nameCol = headers.find(h => { const l = h.toLowerCase(); return l.includes('resident name') || l === 'name'; }) || headers.find(h => /name/i.test(h));
      const latCol = headers.find(h => /latitude|^lat$/i.test(h));
      const lonCol = headers.find(h => /longitude|^lon$|^lng$/i.test(h));
      let zoneCol = headers.find(h => /zone\s*name|zonename/i.test(h));
      if (!zoneCol) zoneCol = headers.find(h => h.toLowerCase().includes('zone'));
      const damageCol = findColumn(headers, 'damage');
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
    const rebuildCol = findColumn(headers, ['build', 'status'], ['intent']);
      const addressNotesCol = headers.find(h => /address\s*note/i.test(h));
      const captainCol = findColumn(headers, ['captain', 'assign']) || headers.find(h => /captain/i.test(h));
      const saleDateCol = headers.find(h => /sale\s*date/i.test(h));
      const saleNotesCol = headers.find(h => /sale\s*note/i.test(h));
      const newOwnerCol = headers.find(h => /new\s*owner/i.test(h));
      const indoorsCol = headers.find(h => /indoors\s*remediat/i.test(h));
      const soilCol = headers.find(h => /soil\s*remediat/i.test(h));
      const ageCol = headers.find(h => /^age$/i.test(h));
      const genderCol = headers.find(h => /^gender$/i.test(h));
      const homePhoneCol = headers.find(h => /home\s*phone/i.test(h));
      const cellCol = headers.find(h => /cell|mobile/i.test(h));
      const emailCol = headers.find(h => /email\s*address/i.test(h)) || headers.find(h => /^email$/i.test(h));
      const renterCol = headers.find(h => /renter/i.test(h));
      const followUpCol = headers.find(h => /follow\s*up|needs\s*follow/i.test(h));
      const personNotesCol = headers.find(h => /person\s*note/i.test(h));
      const contactDateCol = findColumn(headers, ['contact', 'date']) || findColumn(headers, ['last', 'contact']);
      const contactNotesCol = headers.find(h => /contact\s*note/i.test(h));
      const getUniqueValues = (col) => col ? [...new Set(sheetData.data.map(r => (r[col] || '').trim()).filter(Boolean))].sort() : [];
      const field = (label, id, type = 'text', opts = '') => `<p style="margin:0 0 4px 0;"><label>${escapeHtml(label)}</label></p><input type="${type}" id="${id}" class="add-record-input" ${opts}>`;
      const notesField = (label, id) => `<p style="margin:0 0 4px 0;"><label>${escapeHtml(label)}</label></p><textarea id="${id}" class="add-record-input add-record-notes" rows="4" placeholder="Optional"></textarea>`;
      const selectField = (label, id, values) => `<p style="margin:0 0 4px 0;"><label>${escapeHtml(label)}</label></p><select id="${id}" class="add-record-select"><option value="">‚Äî</option>${(values || []).map(v => `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`).join('')}</select>`;
      const checkboxField = (label, id) => `<label class="add-record-checkbox-wrap"><input type="checkbox" id="${id}" class="add-record-checkbox"><span>${escapeHtml(label)}</span></label>`;

      // Person details: Age, Home phone, Cell, Email address, Renter (checkbox), Needs Follow-Up (checkbox), Person Notes
      const buildPersonDetailsHtml = (prefix) => {
        const parts = [
          field('Age', prefix + 'Age', 'text'),
          field('Home phone', prefix + 'HomePhone'),
          field('Cell', prefix + 'Cell'),
          field('Email address', prefix + 'Email', 'email'),
          checkboxField('Renter', prefix + 'Renter'),
          checkboxField('Needs Follow-Up', prefix + 'FollowUp'),
          notesField('Person Notes', prefix + 'PersonNotes')
        ];
        return parts.join('');
      };
      // Address details: Damage, Address Plan, Build Status, Address Notes
      const addressDamageOptions = getFullDamageOptions();
      const addressPlanOptions = ['Undecided', 'Building', 'Selling', 'Other', 'Unknown'];
      const addressRebuildOptions = getFullRebuildStatusOptions();
      const addressDetailsFields = [
        selectField('Damage', 'addRecordDamage', addressDamageOptions),
        selectField('Address Plan', 'addRecordAddressPlan', addressPlanOptions),
        selectField('Build Status', 'addRecordRebuild', addressRebuildOptions),
        notesField('Address Notes', 'addRecordAddressNotes')
      ].join('');
      const personDetailsFields = buildPersonDetailsHtml('addRecord');
      const personDetailsFieldsP = buildPersonDetailsHtml('addRecordP');

      const modalHTML = `
        <div class="newsletter-modal-overlay" id="addRecordModalOverlay">
          <div class="newsletter-modal" style="max-width:560px;">
            <button class="newsletter-modal-close" id="addRecordModalClose">&times;</button>
            <div class="newsletter-modal-header">
              <h3 class="newsletter-modal-title">Add a record</h3>
            </div>
            <div class="newsletter-modal-content">
              <div class="newsletter-modal-section">
                <p style="margin:0 0 10px 0; font-weight:600;">Are you adding an address or a person?</p>
                <div style="display:flex; gap:20px;">
                  <label style="display:flex; align-items:center; gap:8px; cursor:pointer;"><input type="radio" name="addRecordType" value="address" checked> An address</label>
                  <label style="display:flex; align-items:center; gap:8px; cursor:pointer;"><input type="radio" name="addRecordType" value="person"> A person</label>
                </div>
              </div>
              <div id="addRecordAddressForm" class="newsletter-modal-section">
                <h4 class="newsletter-modal-section-title">Address</h4>
                <div class="newsletter-modal-instructions">
                  <p style="margin:0 0 6px 0;"><label>House number</label></p>
                  <input type="text" id="addRecordHouseNum" class="add-record-input" placeholder="e.g. 123" style="max-width:120px; margin-bottom:10px;">
                  <p style="margin:0 0 6px 0;"><label>Street</label></p>
                  <select id="addRecordStreetSelect" class="add-record-select" style="max-width:320px; margin-bottom:10px;">
                    <option value="">-- Select street --</option>
                    ${uniqueStreets.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join('')}
                    <option value="__other__">Other (type new street)</option>
                  </select>
                  <div id="addRecordStreetOtherWrap" class="hidden" style="margin-bottom:10px;">
                    <input type="text" id="addRecordStreetOther" class="add-record-input" placeholder="e.g. Main St" style="max-width:320px;">
                  </div>
                  <p style="margin:0 0 6px 0;"><label>City, State, Zip</label></p>
                  <input type="text" id="addRecordCityState" class="add-record-input" placeholder="e.g. Altadena, CA 91001" value="${escapeHtml(cityStateZip)}" style="max-width:320px; margin-bottom:10px;">
                </div>
                <div class="newsletter-modal-section" style="margin-top:16px;">
                  <h4 class="newsletter-modal-section-title">Someone at this address?</h4>
                  <p style="margin:0 0 8px 0; font-size:0.9rem; color:var(--text-light);">Optional. Add a name and details if you know who lives here.</p>
                  <p style="margin:0 0 6px 0;"><label>Name</label></p>
                  <input type="text" id="addRecordPersonName" class="add-record-input" placeholder="e.g. Jane Smith" style="max-width:320px; margin-bottom:10px;">
                  <details style="margin-top:10px;"><summary style="cursor:pointer; font-weight:600;">Person details</summary><p style="margin:8px 0 10px 0; font-size:0.9rem; color:var(--text-light);">All fields are optional and can be added later.</p><div style="margin-top:8px; padding-left:0;">${personDetailsFields}</div></details>
                </div>
                <details style="margin-top:12px;"><summary style="cursor:pointer; font-weight:600;">Address details</summary><p style="margin:8px 0 10px 0; font-size:0.9rem; color:var(--text-light);">All fields are optional and can be added later.</p><div style="margin-top:8px; padding-left:0;">${addressDetailsFields}</div></details>
              </div>
              <div id="addRecordPersonForm" class="newsletter-modal-section hidden">
                <h4 class="newsletter-modal-section-title">Where do they live?</h4>
                <div class="newsletter-modal-instructions">
                  <p style="margin:0 0 6px 0;"><label>Choose one</label></p>
                  <select id="addRecordPersonAddressType" class="add-record-select" style="max-width:360px; margin-bottom:10px;">
                    <option value="existing">Existing address</option>
                    <option value="new">New address</option>
                    <option value="none">No address / leave blank</option>
                  </select>
                  <div id="addRecordPersonExistingWrap">
                    <p style="margin:0 0 6px 0;"><label>Address</label></p>
                    <select id="addRecordExistingAddress" class="add-record-select" style="max-width:400px; margin-bottom:10px;">
                      <option value="">-- Select an address --</option>
                      ${addresses.map(addr => `<option value="${escapeHtml(addr)}">${escapeHtml(addr)}</option>`).join('')}
                    </select>
                  </div>
                  <div id="addRecordPersonNewWrap" class="hidden">
                    <p style="margin:0 0 6px 0;"><label>House number</label></p>
                    <input type="text" id="addRecordPersonHouseNum" class="add-record-input" placeholder="e.g. 123" style="max-width:120px; margin-bottom:8px;">
                    <p style="margin:0 0 6px 0;"><label>Street</label></p>
                    <select id="addRecordPersonStreetSelect" class="add-record-select" style="max-width:320px; margin-bottom:8px;">
                      <option value="">-- Select street --</option>
                      ${uniqueStreets.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join('')}
                      <option value="__other__">Other (type new street)</option>
                    </select>
                    <div id="addRecordPersonStreetOtherWrap" class="hidden" style="margin-bottom:8px;"><input type="text" id="addRecordPersonStreetOther" class="add-record-input" placeholder="e.g. Main St" style="max-width:320px;"></div>
                    <p style="margin:0 0 6px 0;"><label>City, State, Zip</label></p>
                    <input type="text" id="addRecordPersonCityState" class="add-record-input" placeholder="e.g. Altadena, CA 91001" value="${escapeHtml(cityStateZip)}" style="max-width:320px;">
                  </div>
                </div>
                <div style="margin-top:16px;">
                  <h4 class="newsletter-modal-section-title">Person</h4>
                  <p style="margin:0 0 6px 0;"><label>Name</label></p>
                  <input type="text" id="addRecordPersonNameInput" class="add-record-input" placeholder="e.g. Jane Smith" style="max-width:320px; margin-bottom:10px;">
                  <details style="margin-top:10px;"><summary style="cursor:pointer; font-weight:600;">Person details</summary><p style="margin:8px 0 10px 0; font-size:0.9rem; color:var(--text-light);">All fields are optional and can be added later.</p><div style="margin-top:8px; padding-left:0;">${personDetailsFieldsP}</div></details>
                </div>
              </div>
              <div id="addRecordMapSection" class="newsletter-modal-section hidden">
                <h4 class="newsletter-modal-section-title">Location on map</h4>
                <p id="addRecordGeocodeStatus" style="margin:0 0 8px 0; font-size:0.9rem;"></p>
                <div id="addRecordMinimap" style="height:200px; width:100%; border-radius:8px; border:1px solid var(--border-soft);"></div>
                <p style="margin:8px 0 0 0; font-size:0.85rem; color:var(--text-light);">Drag the pin to adjust, or click &quot;Place pin manually&quot; to set by clicking on the map.</p>
                <button type="button" id="addRecordPlacePinBtn" class="btn-copy-emails" style="margin-top:8px; font-size:0.9rem;">Place pin manually</button>
              </div>
            </div>
            <div class="newsletter-modal-actions">
              <button type="button" class="btn-copy-emails" id="addRecordSubmitBtn">Add record</button>
            </div>
          </div>
        </div>
      `;

      const existingModal = document.getElementById('addRecordModalOverlay');
      if (existingModal) existingModal.remove();
      document.body.insertAdjacentHTML('beforeend', modalHTML);

      const overlay = document.getElementById('addRecordModalOverlay');
      const closeBtn = document.getElementById('addRecordModalClose');
      const addressForm = document.getElementById('addRecordAddressForm');
      const personForm = document.getElementById('addRecordPersonForm');
      const mapSection = document.getElementById('addRecordMapSection');
      const streetSelect = document.getElementById('addRecordStreetSelect');
      const streetOtherWrap = document.getElementById('addRecordStreetOtherWrap');
      const geocodeStatus = document.getElementById('addRecordGeocodeStatus');
      const minimapDiv = document.getElementById('addRecordMinimap');
      const placePinBtn = document.getElementById('addRecordPlacePinBtn');
      const submitBtn = document.getElementById('addRecordSubmitBtn');

      let addRecordMinimap = null;
      let addRecordMarker = null;
      let addRecordLat = null;
      let addRecordLon = null;
      let addRecordPendingMapConfirm = false;
      let addRecordPendingRowValues = null;
      const defaultCenter = [34.19, -118.15];

      function showMapSection(lat, lon) {
        mapSection.classList.remove('hidden');
        addRecordLat = lat;
        addRecordLon = lon;
        if (!addRecordMinimap && minimapDiv && typeof L !== 'undefined') {
          const center = (lat != null && lon != null) ? [lat, lon] : defaultCenter;
          const zoom = (lat != null && lon != null) ? 16 : 11;
          addRecordMinimap = L.map(minimapDiv, { attributionControl: false }).setView(center, zoom);
          L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { maxZoom: 19 }).addTo(addRecordMinimap);
          addRecordMarker = L.marker(center, { draggable: true }).addTo(addRecordMinimap);
          addRecordMarker.on('dragend', () => {
            const pos = addRecordMarker.getLatLng();
            addRecordLat = pos.lat;
            addRecordLon = pos.lng;
          });
        } else if (addRecordMinimap && addRecordMarker && lat != null && lon != null) {
          addRecordMarker.setLatLng([lat, lon]);
          addRecordMinimap.setView([lat, lon], 16);
          addRecordLat = lat;
          addRecordLon = lon;
        }
        if (placePinBtn) placePinBtn.onclick = () => {
          if (!addRecordMinimap) return;
          addRecordMinimap.once('click', (e) => {
            addRecordLat = e.latlng.lat;
            addRecordLon = e.latlng.lng;
            addRecordMarker.setLatLng(e.latlng);
            geocodeStatus.textContent = 'Location set manually.';
          });
          geocodeStatus.textContent = 'Click on the map to place the pin.';
        };
      }

      function removeModalAndMap() {
        if (addRecordMinimap) { addRecordMinimap.remove(); addRecordMinimap = null; addRecordMarker = null; }
        overlay.remove();
      }

      function toggleByType() {
        const t = overlay.querySelector('input[name="addRecordType"]:checked').value;
        addressForm.classList.toggle('hidden', t !== 'address');
        personForm.classList.toggle('hidden', t !== 'person');
        mapSection.classList.add('hidden');
      }
      overlay.querySelectorAll('input[name="addRecordType"]').forEach(r => r.addEventListener('change', toggleByType));
      toggleByType();

      streetSelect.addEventListener('change', () => { streetOtherWrap.classList.toggle('hidden', streetSelect.value !== '__other__'); });
      if (streetSelect.value === '__other__') streetOtherWrap.classList.remove('hidden');

      const addRecordDamageEl = document.getElementById('addRecordDamage');

      const personAddressType = document.getElementById('addRecordPersonAddressType');
      const personExistingWrap = document.getElementById('addRecordPersonExistingWrap');
      const personNewWrap = document.getElementById('addRecordPersonNewWrap');
      const personStreetSelect = document.getElementById('addRecordPersonStreetSelect');
      const personStreetOtherWrap = document.getElementById('addRecordPersonStreetOtherWrap');
      function togglePersonAddressBlocks() {
        const v = personAddressType ? personAddressType.value : 'existing';
        if (personExistingWrap) personExistingWrap.classList.toggle('hidden', v !== 'existing');
        if (personNewWrap) personNewWrap.classList.toggle('hidden', v !== 'new');
      }
      if (personAddressType) personAddressType.addEventListener('change', togglePersonAddressBlocks);
      togglePersonAddressBlocks();
      if (personStreetSelect) personStreetSelect.addEventListener('change', () => { if (personStreetOtherWrap) personStreetOtherWrap.classList.toggle('hidden', personStreetSelect.value !== '__other__'); });
      if (personStreetSelect && personStreetSelect.value === '__other__' && personStreetOtherWrap) personStreetOtherWrap.classList.remove('hidden');

      overlay.addEventListener('click', (e) => { if (e.target === overlay) removeModalAndMap(); });
      closeBtn.addEventListener('click', removeModalAndMap);
      document.addEventListener('keydown', function escapeHandler(e) {
        if (e.key === 'Escape' && overlay && document.body.contains(overlay)) { removeModalAndMap(); document.removeEventListener('keydown', escapeHandler); }
      });

      function collectPersonDetails(prefix) {
        const out = {};
        if (ageCol) { const el = document.getElementById(prefix + 'Age'); if (el && el.value) out[ageCol] = el.value.trim(); }
        if (homePhoneCol) { const el = document.getElementById(prefix + 'HomePhone'); if (el && el.value) out[homePhoneCol] = el.value.trim(); }
        if (cellCol) { const el = document.getElementById(prefix + 'Cell'); if (el && el.value) out[cellCol] = el.value.trim(); }
        if (emailCol) { const el = document.getElementById(prefix + 'Email'); if (el && el.value) out[emailCol] = el.value.trim(); }
        if (renterCol) { const el = document.getElementById(prefix + 'Renter'); if (el && el.type === 'checkbox') out[renterCol] = el.checked ? 'TRUE' : 'FALSE'; }
        if (followUpCol) { const el = document.getElementById(prefix + 'FollowUp'); if (el && el.type === 'checkbox') out[followUpCol] = el.checked ? 'TRUE' : 'FALSE'; }
        if (personNotesCol) { const el = document.getElementById(prefix + 'PersonNotes'); if (el && el.value) out[personNotesCol] = el.value.trim(); }
        return out;
      }
      function collectAddressDetails() {
        const out = {};
        if (damageCol) { const el = document.getElementById('addRecordDamage'); if (el && el.value) out[damageCol] = el.value; }
        if (addressPlanCol) { const el = document.getElementById('addRecordAddressPlan'); if (el && el.value) out[addressPlanCol] = el.value; }
        if (rebuildCol) { const el = document.getElementById('addRecordRebuild'); if (el && el.value) out[rebuildCol] = el.value; }
        if (addressNotesCol) { const el = document.getElementById('addRecordAddressNotes'); if (el && el.value) out[addressNotesCol] = el.value.trim(); }
        return out;
      }

      submitBtn.addEventListener('click', async () => {
        if (addRecordPendingMapConfirm && addRecordPendingRowValues) {
          if (latCol && addRecordLat != null) addRecordPendingRowValues[latCol] = String(addRecordLat);
          if (lonCol && addRecordLon != null) addRecordPendingRowValues[lonCol] = String(addRecordLon);
          const row = buildRowForHeaders(headers, addRecordPendingRowValues);
          submitBtn.disabled = true;
          submitBtn.textContent = 'Adding‚Ä¶';
          try {
            await appendRowsToSheet([row]);
            removeModalAndMap();
            showAppToast('Record successfully added to your zone.');
            if (currentSheetUrl) {
              setTimeout(() => loadAddressData(currentSheetUrl), 400);
            }
          } catch (err) {
            alert('Could not add record: ' + (err.message || err));
          } finally {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Add record';
          }
          addRecordPendingMapConfirm = false;
          addRecordPendingRowValues = null;
          return;
        }
        const t = overlay.querySelector('input[name="addRecordType"]:checked').value;
        let rowValuesByColumn = {};

        if (t === 'address') {
          const houseNum = (document.getElementById('addRecordHouseNum').value || '').trim();
          const streetVal = streetSelect.value === '__other__' ? (document.getElementById('addRecordStreetOther').value || '').trim() : (streetSelect.value || '').trim();
          const cityState = (document.getElementById('addRecordCityState').value || '').trim();
          const personName = (document.getElementById('addRecordPersonName').value || '').trim();
          if (!streetVal) { alert('Please select or enter a street.'); return; }
          const addressString = [houseNum, streetVal].filter(Boolean).join(' ');
          if (houseNumCol) rowValuesByColumn[houseNumCol] = houseNum;
          if (streetCol) rowValuesByColumn[streetCol] = streetVal;
          if (addressCol) rowValuesByColumn[addressCol] = addressString || '';
          if (nameCol) rowValuesByColumn[nameCol] = personName || '';
          if (zoneCol && currentZoneName) rowValuesByColumn[zoneCol] = currentZoneName;
          Object.assign(rowValuesByColumn, collectPersonDetails('addRecord'));
          Object.assign(rowValuesByColumn, collectAddressDetails());
          let lat = '', lon = '';
          const geocodeQuery = addressString && (addressString + (cityState ? ', ' + cityState : ''));
          if (geocodeQuery && latCol && lonCol) {
            geocodeStatus.textContent = 'Looking up location‚Ä¶';
            mapSection.classList.remove('hidden');
            const coords = await geocodeWithMapbox(geocodeQuery);
            if (coords) {
              addRecordLat = coords.lat;
              addRecordLon = coords.lon;
              geocodeStatus.textContent = 'Location found. Drag the pin to adjust, then click Confirm.';
              showMapSection(coords.lat, coords.lon);
            } else {
              geocodeStatus.textContent = 'We couldn\'t find a location. Place the pin manually, then click Confirm.';
              showMapSection(null, null);
            }
            addRecordPendingRowValues = { ...rowValuesByColumn };
            addRecordPendingMapConfirm = true;
            submitBtn.textContent = 'Confirm and add record';
            return;
          }
          if (addRecordLat != null && addRecordLon != null) {
            lat = String(addRecordLat);
            lon = String(addRecordLon);
          } else if (geocodeQuery) {
            const coords = await geocodeWithMapbox(geocodeQuery);
            if (coords) { lat = String(coords.lat); lon = String(coords.lon); }
          }
          if (latCol) rowValuesByColumn[latCol] = lat;
          if (lonCol) rowValuesByColumn[lonCol] = lon;
        } else {
          // t === 'person'
          const personName = (document.getElementById('addRecordPersonNameInput').value || '').trim();
          if (!personName) { alert('Please enter the person\'s name.'); return; }
          const addrType = personAddressType ? personAddressType.value : 'existing';
          if (addrType === 'existing') {
            const existingAddr = (document.getElementById('addRecordExistingAddress').value || '').trim();
            if (!existingAddr) { alert('Please select an address.'); return; }
            const existingRows = sheetData.addressMap.get(existingAddr);
            if (!existingRows || !existingRows.length) { alert('Could not find that address.'); return; }
            const firstRow = existingRows[0];
            headers.forEach(h => { rowValuesByColumn[h] = (firstRow[h] != null ? firstRow[h] : ''); });
            rowValuesByColumn[nameCol] = personName;
            Object.assign(rowValuesByColumn, collectPersonDetails('addRecordP'));
          } else if (addrType === 'new') {
            const houseNum = (document.getElementById('addRecordPersonHouseNum').value || '').trim();
            const streetVal = personStreetSelect.value === '__other__' ? (document.getElementById('addRecordPersonStreetOther').value || '').trim() : (personStreetSelect.value || '').trim();
            const cityState = (document.getElementById('addRecordPersonCityState').value || '').trim();
            if (!streetVal) { alert('Please select or enter a street for the new address.'); return; }
            const addressString = [houseNum, streetVal].filter(Boolean).join(' ');
            if (houseNumCol) rowValuesByColumn[houseNumCol] = houseNum;
            if (streetCol) rowValuesByColumn[streetCol] = streetVal;
            if (addressCol) rowValuesByColumn[addressCol] = addressString || '';
            if (nameCol) rowValuesByColumn[nameCol] = personName;
            if (zoneCol && currentZoneName) rowValuesByColumn[zoneCol] = currentZoneName;
            Object.assign(rowValuesByColumn, collectPersonDetails('addRecordP'));
            let lat = '', lon = '';
            const geocodeQuery = addressString && (addressString + (cityState ? ', ' + cityState : ''));
            if (geocodeQuery && latCol && lonCol) {
              geocodeStatus.textContent = 'Looking up location‚Ä¶';
              mapSection.classList.remove('hidden');
              const coords = await geocodeWithMapbox(geocodeQuery);
              if (coords) {
                addRecordLat = coords.lat;
                addRecordLon = coords.lon;
                geocodeStatus.textContent = 'Location found. Drag the pin to adjust, then click Confirm.';
                showMapSection(coords.lat, coords.lon);
              } else {
                geocodeStatus.textContent = 'We couldn\'t find a location. Place the pin manually, then click Confirm.';
                showMapSection(null, null);
              }
              addRecordPendingRowValues = { ...rowValuesByColumn };
              addRecordPendingMapConfirm = true;
              submitBtn.textContent = 'Confirm and add record';
              return;
            }
            if (addRecordLat != null && addRecordLon != null) {
              lat = String(addRecordLat);
              lon = String(addRecordLon);
            } else if (geocodeQuery) {
              const coords = await geocodeWithMapbox(geocodeQuery);
              if (coords) { lat = String(coords.lat); lon = String(coords.lon); }
            }
            if (latCol) rowValuesByColumn[latCol] = lat;
            if (lonCol) rowValuesByColumn[lonCol] = lon;
          } else {
            if (addressCol) rowValuesByColumn[addressCol] = '';
            if (houseNumCol) rowValuesByColumn[houseNumCol] = '';
            if (streetCol) rowValuesByColumn[streetCol] = '';
            if (nameCol) rowValuesByColumn[nameCol] = personName;
            if (zoneCol && currentZoneName) rowValuesByColumn[zoneCol] = currentZoneName;
            if (latCol) rowValuesByColumn[latCol] = '';
            if (lonCol) rowValuesByColumn[lonCol] = '';
            Object.assign(rowValuesByColumn, collectPersonDetails('addRecordP'));
          }
        }

        const row = buildRowForHeaders(headers, rowValuesByColumn);
        submitBtn.disabled = true;
        submitBtn.textContent = 'Adding‚Ä¶';
        try {
          await appendRowsToSheet([row]);
          removeModalAndMap();
          showAppToast('Record successfully added to your zone.');
          if (currentSheetUrl) {
            setTimeout(() => loadAddressData(currentSheetUrl), 400);
          }
        } catch (err) {
          alert('Could not add record: ' + (err.message || err));
        } finally {
          submitBtn.disabled = false;
          submitBtn.textContent = 'Add record';
        }
      });
    }

    // Display list of addresses
    // Helper function to adjust content views for filter bar
    function adjustContentViewsForFilterBar() {
      const filterBar = document.getElementById('filterBar');
      const shouldShowFilters = (currentView === 'people' || currentView === 'map');
      
      if (shouldShowFilters && filterBar && !filterBar.classList.contains('hidden')) {
        // Force a layout recalculation by accessing offsetHeight
        const forceLayout = filterBar.offsetHeight;
        
        // Get the filter bar's bounding rectangle for accurate position
        const filterBarRect = filterBar.getBoundingClientRect();
        const filterBarTop = filterBarRect.top;
        const filterBarHeight = filterBarRect.height;
        // Add a small buffer (2px) to ensure no overlap
        const filterBarOffset = filterBarTop + filterBarHeight + 2;
        
        // Apply offset to content views
        // Both filter bar and app-container start at top of viewport
        // Filter bar is fixed, content views are absolute within app-container
        // Since they start at the same point, we just need filter bar height
        const offset = filterBarRect.height + 2; // +2px buffer to prevent any overlap
        
        document.querySelectorAll('.content-view').forEach(view => {
          if (view.id === 'peopleView' || view.id === 'mapView') {
            view.style.top = offset + 'px';
          }
        });
        
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
          mapContainer.style.top = offset + 'px';
        }
      } else {
        // No filter bar, content views start at top - reset padding
        document.querySelectorAll('.content-view').forEach(view => {
          if (view.id === 'peopleView' || view.id === 'mapView') {
            view.style.top = '0';
            view.style.paddingTop = '32px'; // Reset to default padding
          }
        });
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
          mapContainer.style.top = '0';
        }
      }
    }

    // Debounced resize: keep content/map aligned with filter bar when window is resized
    (function initResizeListener() {
      var resizeTimer = null;
      var resizeDelay = 120;
      function onResize() {
        if (resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function() {
          resizeTimer = null;
          adjustContentViewsForFilterBar();
        }, resizeDelay);
      }
      window.addEventListener('resize', onResize);
    })();
    
    // Populate persistent filter bar
    function populateFilterBar() {
      if (!sheetData || !sheetData.addressMap) {
        const filterBar = document.getElementById('filterBar');
        if (filterBar) filterBar.classList.add('hidden');
        return;
      }

      const filterBar = document.getElementById('filterBar');
      const filterBarContent = document.getElementById('filterBarContent');
      if (!filterBar || !filterBarContent) return;

      const addresses = Array.from(sheetData.addressMap.keys());
      const headers = sheetData.headers;
      const damageCol = findColumn(headers, 'damage');
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
      const rebuildCol = findColumn(headers, ['build', 'status'], ['intent']);
      const contactDateCol = findColumn(headers, ['contact', 'date']);

      const streets = getUniqueStreets(addresses);
      const damages = getFullDamageOptions();
      const addressPlans = addressPlanCol ? getFullAddressPlanOptions() : [];
      const rebuildStatusesArray = rebuildCol ? getFullRebuildStatusOptions() : [];
      
      // Check if zone has multiple captains and get captain names for filter
      const ncNameCol = findColumn(headers, 'nc name');
      const ncPhoneCol = findColumn(headers, 'nc phone');
      const ncEmailCol = findColumn(headers, 'nc email');
      const captainAssignedCol = findColumn(headers, 'captain assigned');
      let hasMultipleCaptains = false;
      let captainNames = [];
      
      if (ncNameCol && sheetData.data && sheetData.data.length > 0 && captainAssignedCol) {
        const firstRow = sheetData.data[0];
        const ncName = firstRow[ncNameCol] ? (firstRow[ncNameCol] || '').trim() : '';
        const ncPhone = ncPhoneCol ? (firstRow[ncPhoneCol] || '').trim() : '';
        const ncEmail = ncEmailCol ? (firstRow[ncEmailCol] || '').trim() : '';
        const captains = parseCaptains(ncName, ncPhone, ncEmail);
        hasMultipleCaptains = captains.length > 1;
        if (hasMultipleCaptains) {
          captainNames = captains.map(c => c.name).filter(n => n !== 'N/A');
        }
      }

      const html = `
        <span class="filters-label">Filters:</span>
        <select id="persistentStreetFilter" class="${currentStreetFilter !== 'all' ? 'filter-active' : ''}">
          <option value="all" ${currentStreetFilter === 'all' ? 'selected' : ''}>All Streets</option>
          ${streets.map(street => `<option value="${street.replace(/"/g, '&quot;')}" ${currentStreetFilter === street ? 'selected' : ''}>${street}</option>`).join('')}
        </select>
        <select id="persistentDamageFilter" class="${currentDamageFilter !== 'all' ? 'filter-active' : ''}" title="The highest level of damage to any structure on this property (e.g., mark 'Partial' if a garage or ADU was lost but the house stands).">
          <option value="all" ${currentDamageFilter === 'all' ? 'selected' : ''}>All Damage Status</option>
          <option value="" ${currentDamageFilter === '' ? 'selected' : ''}>(not set)</option>
          ${damages.map(damage => `<option value="${damage.replace(/"/g, '&quot;')}" ${currentDamageFilter === damage ? 'selected' : ''}>${damage}</option>`).join('')}
        </select>
        ${addressPlanCol ? `<select id="persistentAddressPlanFilter" class="${currentAddressPlanFilter !== 'all' ? 'filter-active' : ''}" title="The owner's current intent for the property‚Äîwhether they plan to rebuild, sell, or are still deciding.">
          <option value="all" ${currentAddressPlanFilter === 'all' ? 'selected' : ''}>All Address Plan</option>
          <option value="" ${currentAddressPlanFilter === '' ? 'selected' : ''}>(not set)</option>
          ${addressPlans.map(ap => `<option value="${ap.replace(/"/g, '&quot;')}" ${currentAddressPlanFilter === ap ? 'selected' : ''}>${ap}</option>`).join('')}
        </select>` : ''}
        ${rebuildCol ? `<select id="persistentRebuildFilter" class="${currentRebuildFilter !== 'all' ? 'filter-active' : ''}" title="For properties in recovery, this tracks the physical progress of construction.">
          <option value="all" ${currentRebuildFilter === 'all' ? 'selected' : ''}>All Build Status</option>
          ${rebuildStatusesArray.map(status => `<option value="${status.replace(/"/g, '&quot;')}" ${currentRebuildFilter === status ? 'selected' : ''}>${status}</option>`).join('')}
        </select>` : ''}
        ${hasMultipleCaptains && captainAssignedCol ? `<select id="persistentCaptainFilter" class="${currentCaptainFilter !== 'all' ? 'filter-active' : ''}" title="Filter to see addresses assigned to a specific Neighborhood Captain.">
          <option value="all" ${currentCaptainFilter === 'all' ? 'selected' : ''}>Any Captain</option>
          <option value="" ${currentCaptainFilter === '' ? 'selected' : ''}>(not specified)</option>
          ${captainNames.map(name => `<option value="${escapeHtml(name).replace(/"/g, '&quot;')}" ${currentCaptainFilter === name ? 'selected' : ''}>${escapeHtml(name)}</option>`).join('')}
        </select>` : ''}
        ${contactDateCol ? `
        <div class="contact-filter-group">
          <label class="contact-filter-checkbox" title="View only the addresses you have successfully reached.">
            <input type="checkbox" id="persistentShowContactedCheckbox" ${showContactedAddresses ? 'checked' : ''}>
            <span>Show contacted addresses</span>
          </label>
          <label class="contact-filter-checkbox" title="View addresses where you haven't been able to reach anyone yet.">
            <input type="checkbox" id="persistentShowUncontactedCheckbox" ${showUncontactedAddresses ? 'checked' : ''}>
            <span>Show uncontacted addresses</span>
          </label>
        </div>
        ` : ''}
      `;

      filterBarContent.innerHTML = html;
      
      // Only show filter bar if we're on map or people view
      const shouldShowFilters = (currentView === 'people' || currentView === 'map');
      if (shouldShowFilters) {
        filterBar.classList.remove('hidden');
        // Recalculate content offset after filter bar is populated (height may change)
        // Use multiple timeouts to ensure filter bar has fully rendered and height is accurate
        setTimeout(() => {
          adjustContentViewsForFilterBar();
          // Recalculate again after a bit more time to catch any delayed rendering
          setTimeout(() => {
            adjustContentViewsForFilterBar();
          }, 100);
        }, 50);
      } else {
        filterBar.classList.add('hidden');
      }

      // Add event handlers (remove old ones first to avoid duplicates)
      const oldStreetFilter = document.getElementById('persistentStreetFilter');
      if (oldStreetFilter) {
        oldStreetFilter.replaceWith(oldStreetFilter.cloneNode(true));
      }
      const oldDamageFilter = document.getElementById('persistentDamageFilter');
      if (oldDamageFilter) {
        oldDamageFilter.replaceWith(oldDamageFilter.cloneNode(true));
      }
      const oldAddressPlanFilter = document.getElementById('persistentAddressPlanFilter');
      if (oldAddressPlanFilter) {
        oldAddressPlanFilter.replaceWith(oldAddressPlanFilter.cloneNode(true));
      }
      const oldRebuildFilter = document.getElementById('persistentRebuildFilter');
      if (oldRebuildFilter) {
        oldRebuildFilter.replaceWith(oldRebuildFilter.cloneNode(true));
      }
      const oldContactedCheckbox = document.getElementById('persistentShowContactedCheckbox');
      if (oldContactedCheckbox) {
        oldContactedCheckbox.replaceWith(oldContactedCheckbox.cloneNode(true));
      }
      const oldUncontactedCheckbox = document.getElementById('persistentShowUncontactedCheckbox');
      if (oldUncontactedCheckbox) {
        oldUncontactedCheckbox.replaceWith(oldUncontactedCheckbox.cloneNode(true));
      }
      const oldCaptainFilter = document.getElementById('persistentCaptainFilter');
      if (oldCaptainFilter) {
        oldCaptainFilter.replaceWith(oldCaptainFilter.cloneNode(true));
      }
      // Add event handlers
      const streetFilter = document.getElementById('persistentStreetFilter');
      if (streetFilter) {
        streetFilter.addEventListener('change', (e) => {
          currentStreetFilter = e.target.value;
          if (currentStreetFilter !== 'all') {
            streetFilter.classList.add('filter-active');
          } else {
            streetFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const damageFilter = document.getElementById('persistentDamageFilter');
      if (damageFilter) {
        damageFilter.addEventListener('change', (e) => {
          currentDamageFilter = e.target.value;
          if (currentDamageFilter !== 'all') {
            damageFilter.classList.add('filter-active');
          } else {
            damageFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const addressPlanFilter = document.getElementById('persistentAddressPlanFilter');
      if (addressPlanFilter) {
        addressPlanFilter.addEventListener('change', (e) => {
          currentAddressPlanFilter = e.target.value;
          if (currentAddressPlanFilter !== 'all') {
            addressPlanFilter.classList.add('filter-active');
          } else {
            addressPlanFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const rebuildFilter = document.getElementById('persistentRebuildFilter');
      if (rebuildFilter) {
        rebuildFilter.addEventListener('change', (e) => {
          currentRebuildFilter = e.target.value;
          if (currentRebuildFilter !== 'all') {
            rebuildFilter.classList.add('filter-active');
          } else {
            rebuildFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const captainFilter = document.getElementById('persistentCaptainFilter');
      if (captainFilter) {
        captainFilter.addEventListener('change', (e) => {
          currentCaptainFilter = e.target.value;
          if (currentCaptainFilter !== 'all') {
            captainFilter.classList.add('filter-active');
          } else {
            captainFilter.classList.remove('filter-active');
          }
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const showContactedCheckbox = document.getElementById('persistentShowContactedCheckbox');
      if (showContactedCheckbox) {
        showContactedCheckbox.addEventListener('change', (e) => {
          showContactedAddresses = e.target.checked;
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

      const showUncontactedCheckbox = document.getElementById('persistentShowUncontactedCheckbox');
      if (showUncontactedCheckbox) {
        showUncontactedCheckbox.addEventListener('change', (e) => {
          showUncontactedAddresses = e.target.checked;
          displayAddressTable();
          displayAddressList(Array.from(sheetData.addressMap.keys()).sort());
          updateMapMarkers();
        });
      }

    }

    // Display address table view for Addresses & People page
    function displayAddressTable() {
      if (!sheetData || !sheetData.addressMap) {
        const tableView = document.getElementById('peopleTableView');
        if (tableView) {
          tableView.innerHTML = '<div class="empty">Load a spreadsheet to see addresses</div>';
        }
        return;
      }
      
      const addresses = Array.from(sheetData.addressMap.keys()).sort();
      const tableView = document.getElementById('peopleTableView');
      if (!tableView) return;
      
      if (addresses.length === 0) {
        tableView.innerHTML = '<div class="empty">No addresses found</div>';
        return;
      }
      
      const headers = sheetData.headers;
      const damageCol = findColumn(headers, 'damage');
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
      const rebuildCol = findColumn(headers, ['build', 'status'], ['intent']);
      const residentNameCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('resident name') || (lower.includes('name') && !lower.includes('first') && !lower.includes('last') && !lower.includes('nc'));
      });
      const ageCol = headers.find(h => h.toLowerCase() === 'age');
      const phoneCol = findColumn(headers, 'phone', ['nc']);
      const emailCol = findColumn(headers, 'email');
      const contactDateCol = findColumn(headers, ['contact', 'date']);
      
      // Get unique values for filters
      const streets = getUniqueStreets(addresses);
      const damages = getUniqueDamage(addresses);
      
      // Get unique rebuild status values
      const rebuildStatuses = new Set();
      if (rebuildCol) {
        sheetData.data.forEach(row => {
          if (row[rebuildCol] !== undefined && row[rebuildCol] !== null) {
            const value = String(row[rebuildCol]).trim();
            if (value) rebuildStatuses.add(value);
          }
        });
      }
      // Sort rebuild statuses in sequential order, with any custom values at the end
      const rebuildStatusesArray = sortRebuildStatusesSequential(Array.from(rebuildStatuses));
      
      // Filter addresses
      const filteredAddresses = addresses.filter(addr => {
        if (currentStreetFilter !== 'all' && extractStreet(addr) !== currentStreetFilter) return false;
        if (currentDamageFilter !== 'all') {
          if (currentDamageFilter === '') {
            // Filter for "(not set)" - addresses with no damage status
            const damage = getAddressDamage(addr);
            if (damage && damage.trim() !== '' && damage !== '(not set)') return false;
          } else {
            if (getAddressDamage(addr) !== currentDamageFilter) return false;
          }
        }
        if (currentAddressPlanFilter !== 'all') {
          const addrPlan = getAddressPlan(addr);
          if (currentAddressPlanFilter === '') {
            if (addrPlan !== null && addrPlan !== '') return false;
          } else if (addrPlan !== currentAddressPlanFilter) {
            return false;
          }
        }
        if (currentRebuildFilter !== 'all' && rebuildCol) {
          const rows = sheetData.addressMap.get(addr);
          if (rows && rows[0]) {
            const rebuildValue = normalizeRebuildStatusLabel((rows[0][rebuildCol] || '').trim());
            if (rebuildValue !== currentRebuildFilter) return false;
          } else {
            return false;
          }
        }
        // Captain assigned filter
        if (currentCaptainFilter !== 'all') {
          const captainAssignedCol = findColumn(headers, 'captain assigned');
          if (captainAssignedCol) {
            const rows = sheetData.addressMap.get(addr);
            if (rows && rows[0]) {
              const captainValue = (rows[0][captainAssignedCol] || '').trim();
              if (currentCaptainFilter === '') {
                // Filter for "(not specified)" - addresses with no captain assigned
                if (captainValue && captainValue.trim() !== '') return false;
              } else {
                if (captainValue !== currentCaptainFilter) return false;
              }
            } else {
              // No rows for address - check if we're filtering for "(not specified)"
              if (currentCaptainFilter !== '') return false;
            }
          }
        }
        // Contact status filter
        if (contactDateCol) {
          const isContacted = isAddressContacted(addr);
          if (isContacted && !showContactedAddresses) return false;
          if (!isContacted && !showUncontactedAddresses) return false;
        }
        return true;
      });
      
      // Sort addresses if sort column is set
      let sortedAddresses = [...filteredAddresses];
      if (tableSortColumn) {
        sortedAddresses.sort((a, b) => {
          const rowsA = sheetData.addressMap.get(a);
          const rowsB = sheetData.addressMap.get(b);
          let valA = '';
          let valB = '';
          
          if (tableSortColumn === 'address') {
            valA = a;
            valB = b;
          } else if (tableSortColumn === 'residents') {
            const residentsA = rowsA && residentNameCol ? rowsA.filter(r => r[residentNameCol]?.trim()).length : 0;
            const residentsB = rowsB && residentNameCol ? rowsB.filter(r => r[residentNameCol]?.trim()).length : 0;
            valA = residentsA.toString();
            valB = residentsB.toString();
          } else {
            const col = headers.find(h => h.toLowerCase() === tableSortColumn.toLowerCase());
            if (col) {
              valA = rowsA && rowsA[0] ? (rowsA[0][col] || '').toString().trim() : '';
              valB = rowsB && rowsB[0] ? (rowsB[0][col] || '').toString().trim() : '';
            }
          }
          
          const comparison = valA.localeCompare(valB, undefined, { numeric: true, sensitivity: 'base' });
          return tableSortDirection === 'asc' ? comparison : -comparison;
        });
      }
      
      const html = `
        <div class="address-table-container">
          <table class="address-table">
            <thead>
              <tr>
                <th class="sortable" data-sort="address" title="Click to sort">Address ${tableSortColumn === 'address' ? (tableSortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}</th>
                <th class="sortable" data-sort="residents" title="Click to sort">Residents ${tableSortColumn === 'residents' ? (tableSortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}</th>
                ${damageCol ? `<th class="sortable" data-sort="${damageCol.toLowerCase()}" title="Click to sort">Damage ${tableSortColumn === damageCol.toLowerCase() ? (tableSortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}</th>` : ''}
                ${addressPlanCol ? `<th class="sortable" data-sort="${addressPlanCol.toLowerCase()}" title="Click to sort">Address Plan ${tableSortColumn === addressPlanCol.toLowerCase() ? (tableSortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}</th>` : ''}
                ${rebuildCol ? `<th class="sortable" data-sort="${rebuildCol.toLowerCase()}" title="Click to sort">Build Status ${tableSortColumn === rebuildCol.toLowerCase() ? (tableSortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}</th>` : ''}
                ${ageCol ? `<th class="sortable" data-sort="${ageCol.toLowerCase()}" title="Click to sort">Age ${tableSortColumn === ageCol.toLowerCase() ? (tableSortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}</th>` : ''}
                ${phoneCol ? `<th>Phone</th>` : ''}
                ${emailCol ? `<th>Email</th>` : ''}
                ${contactDateCol ? `<th class="sortable" data-sort="${contactDateCol.toLowerCase()}" title="Click to sort">Last Contact ${tableSortColumn === contactDateCol.toLowerCase() ? (tableSortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}</th>` : ''}
              </tr>
            </thead>
            <tbody>
              ${sortedAddresses.map(addr => {
                const rows = sheetData.addressMap.get(addr);
                const residents = [];
                if (rows && residentNameCol) {
                  rows.forEach(row => {
                    if (row[residentNameCol] && row[residentNameCol].trim()) {
                      residents.push(row[residentNameCol].trim());
                    }
                  });
                }
                const damage = damageCol && rows && rows[0] ? (rows[0][damageCol] || '').trim() : '';
                const addressPlan = addressPlanCol && rows && rows[0] ? (rows[0][addressPlanCol] || '').trim() : '';
                const rebuild = rebuildCol && rows && rows[0] ? normalizeRebuildStatusLabel((rows[0][rebuildCol] || '').trim()) : '';
                const age = ageCol && rows && rows[0] ? (rows[0][ageCol] || '').trim() : '';
                const phone = phoneCol && rows && rows[0] ? (rows[0][phoneCol] || '').trim() : '';
                const email = emailCol && rows && rows[0] ? (rows[0][emailCol] || '').trim() : '';
                const contactDate = contactDateCol && rows && rows[0] ? (rows[0][contactDateCol] || '').trim() : '';
                
                // Format residents with truncation
                let residentsDisplay = '-';
                if (residents.length > 0) {
                  const residentsText = residents.join(', ');
                  const totalCount = residents.length;
                  // If text is long, truncate and show count in parentheses
                  // With expanded column (300px max), allow ~35 chars before truncating
                  if (residentsText.length > 35) {
                    // Truncate to fit column width, leaving space for "... (X Total)" which is ~12-15 chars
                    const truncateTo = Math.max(20, 35 - (totalCount.toString().length + 12));
                    residentsDisplay = residentsText.substring(0, truncateTo) + '... (' + totalCount + ' Total)';
                  } else {
                    residentsDisplay = residentsText;
                  }
                }
                
                return `
                  <tr class="table-address-row" data-address="${addr.replace(/"/g, '&quot;')}">
                    <td title="${addr}">${addr}</td>
                    <td title="${residents.length > 0 ? residents.join(', ') : '-'}">${residentsDisplay}</td>
                    ${damageCol ? `<td>${damage || '-'}</td>` : ''}
                    ${addressPlanCol ? `<td>${addressPlan || '-'}</td>` : ''}
                    ${rebuildCol ? `<td>${rebuild || '-'}</td>` : ''}
                    ${ageCol ? `<td>${age || '-'}</td>` : ''}
                    ${phoneCol ? `<td>${phone || '-'}</td>` : ''}
                    ${emailCol ? `<td>${email || '-'}</td>` : ''}
                    ${contactDateCol ? `<td>${contactDate || '-'}</td>` : ''}
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
      `;
      
      tableView.innerHTML = html;
      
      // Add sortable column handlers
      document.querySelectorAll('.sortable').forEach(th => {
        th.style.cursor = 'pointer';
        th.addEventListener('click', () => {
          const sortCol = th.getAttribute('data-sort');
          if (tableSortColumn === sortCol) {
            // Toggle direction if same column
            tableSortDirection = tableSortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            // New column, default to ascending
            tableSortColumn = sortCol;
            tableSortDirection = 'asc';
          }
          displayAddressTable();
        });
      });
      
      // Add row click handlers
      document.querySelectorAll('.table-address-row').forEach(row => {
        row.addEventListener('click', () => {
          const address = row.getAttribute('data-address');
          // Update selected state
          document.querySelectorAll('.table-address-row').forEach(r => r.classList.remove('selected'));
          row.classList.add('selected');
          // Show details in floating panel
          displayAddressDetails(address);
          // Switch to people view if not already
          if (currentView !== 'people') {
            switchView('people');
          }
        });
      });
      
      // Wire up print and export buttons
      setupPrintExportHandlers();
    }
    
    // Setup print and export button handlers
    function setupPrintExportHandlers() {
      const printBtn = document.getElementById('btnPrintAddresses');
      const exportBtn = document.getElementById('btnExportAddresses');
      const addRecordBtn = document.getElementById('btnAddRecord');
      
      if (printBtn && !printBtn.hasAttribute('data-handler-attached')) {
        printBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          printAddresses();
        });
        printBtn.setAttribute('data-handler-attached', 'true');
      }
      if (exportBtn && !exportBtn.hasAttribute('data-handler-attached')) {
        exportBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          exportAddressesToCSV();
        });
        exportBtn.setAttribute('data-handler-attached', 'true');
      }
      if (addRecordBtn && !addRecordBtn.hasAttribute('data-handler-attached')) {
        addRecordBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          showAddRecordModal();
        });
        addRecordBtn.setAttribute('data-handler-attached', 'true');
      }
    }
    
    // Get filtered addresses (same logic as displayAddressTable)
    function getFilteredAddresses() {
      if (!sheetData || !sheetData.addressMap) return [];
      
      const addresses = Array.from(sheetData.addressMap.keys()).sort();
      const headers = sheetData.headers;
      const damageCol = findColumn(headers, 'damage');
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
      const rebuildCol = findColumn(headers, ['build', 'status'], ['intent']);
      const contactDateCol = findColumn(headers, ['contact', 'date']);
      const captainAssignedCol = findColumn(headers, 'captain assigned');
      
      return addresses.filter(addr => {
        if (currentStreetFilter !== 'all' && extractStreet(addr) !== currentStreetFilter) return false;
        if (currentDamageFilter !== 'all') {
          if (currentDamageFilter === '') {
            const damage = getAddressDamage(addr);
            if (damage && damage.trim() !== '' && damage !== '(not set)') return false;
          } else {
            if (getAddressDamage(addr) !== currentDamageFilter) return false;
          }
        }
        if (currentAddressPlanFilter !== 'all') {
          const addrPlan = getAddressPlan(addr);
          if (currentAddressPlanFilter === '') {
            if (addrPlan !== null && addrPlan !== '') return false;
          } else if (addrPlan !== currentAddressPlanFilter) {
            return false;
          }
        }
        if (currentRebuildFilter !== 'all' && rebuildCol) {
          const rows = sheetData.addressMap.get(addr);
          if (rows && rows[0]) {
            const rebuildValue = normalizeRebuildStatusLabel((rows[0][rebuildCol] || '').trim());
            if (rebuildValue !== currentRebuildFilter) return false;
          } else {
            return false;
          }
        }
        if (currentCaptainFilter !== 'all' && captainAssignedCol) {
          const rows = sheetData.addressMap.get(addr);
          if (rows && rows[0]) {
            const captainValue = (rows[0][captainAssignedCol] || '').trim();
            if (currentCaptainFilter === '') {
              if (captainValue && captainValue.trim() !== '') return false;
            } else {
              if (captainValue !== currentCaptainFilter) return false;
            }
          } else {
            if (currentCaptainFilter !== '') return false;
          }
        }
        if (contactDateCol) {
          const isContacted = isAddressContacted(addr);
          if (isContacted && !showContactedAddresses) return false;
          if (!isContacted && !showUncontactedAddresses) return false;
        }
        return true;
      });
    }
    
    // Print addresses with comprehensive call sheet formatting
    function printAddresses() {
      const filteredAddresses = getFilteredAddresses();
      if (filteredAddresses.length === 0) {
        alert('No addresses to print. Please adjust your filters.');
        return;
      }
      
      const headers = sheetData.headers;
      
      // Find all relevant columns
      const residentNameCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('resident name') || (lower.includes('name') && !lower.includes('first') && !lower.includes('last') && !lower.includes('nc'));
      });
      const homePhoneCol = headers.find(h => {
        const lower = h.toLowerCase();
        return (lower.includes('home phone') || lower.includes('homephone') || 
                (lower.includes('phone') && lower.includes('home'))) && 
               !lower.includes('cell') && !lower.includes('mobile');
      });
      const cellPhoneCol = headers.find(h => {
        const lower = h.toLowerCase();
        return (lower.includes('cell') || lower.includes('mobile')) && 
               (lower.includes('phone') || lower.includes('cell') || lower.includes('mobile'));
      });
      const emailCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('email address') || (lower.includes('email') && !lower.includes('nc'));
      });
      const ageCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower === 'age' || lower.includes('age') && !lower.includes('phone') && !lower.includes('resident name');
      });
      const genderCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower === 'gender' || (lower.includes('gender') && !lower.includes('resident name'));
      });
      
      // Address-level columns
      const damageCol = findColumn(headers, 'damage');
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
      const rebuildStageCol = findColumn(headers, ['rebuild', 'stage']);
      const rebuildStatusCol = findColumn(headers, ['rebuild', 'status']);
      const householdSizeCol = findColumn(headers, ['household', 'size']);
      const addressNotesCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('address note') || (lower.includes('note') && !lower.includes('person') && !lower.includes('contact'));
      });
      const indoorsRemediatedCol = findColumn(headers, ['indoors', 'remediated']);
      const soilRemediatedCol = findColumn(headers, ['soil', 'remediated']);
      const captainAssignedCol = findColumn(headers, ['captain', 'assigned']);
      
      // Contact and notes columns
      const lastContactDateCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower === 'last contact date' ||
               lower.includes('last contact') || 
               lower.includes('contact date') ||
               lower.includes('contacted');
      });
      const contactNotesCol = headers.find(h => {
        const lower = h.toLowerCase();
        return (lower.includes('contact') && lower.includes('note'));
      });
      
      // Find all person notes columns
      const personNotesCols = headers.filter(h => {
        const lower = h.toLowerCase();
        return lower.includes('person note');
      });
      
      // Group addresses with full data
      const groupedByAddress = {};
      filteredAddresses.forEach(addr => {
        const rows = sheetData.addressMap.get(addr);
        if (!rows || rows.length === 0) return;
        
        const firstRow = rows[0];
        
        // Get address-level data
        const addressData = {
          damage: damageCol && firstRow ? (firstRow[damageCol] || '').trim() : '',
          addressPlan: addressPlanCol && firstRow ? (firstRow[addressPlanCol] || '').trim() : '',
          rebuildStage: rebuildStageCol && firstRow ? (firstRow[rebuildStageCol] || '').trim() : '',
          rebuildStatus: rebuildStatusCol && firstRow ? (firstRow[rebuildStatusCol] || '').trim() : '',
          householdSize: householdSizeCol && firstRow ? (firstRow[householdSizeCol] || '').trim() : '',
          addressNotes: addressNotesCol && firstRow ? (firstRow[addressNotesCol] || '').trim() : '',
          indoorsRemediated: indoorsRemediatedCol && firstRow ? (firstRow[indoorsRemediatedCol] || '').trim() : '',
          soilRemediated: soilRemediatedCol && firstRow ? (firstRow[soilRemediatedCol] || '').trim() : '',
          captainAssigned: captainAssignedCol && firstRow ? (firstRow[captainAssignedCol] || '').trim() : '',
          people: []
        };
        
        // Get person-level data
        rows.forEach(row => {
          if (residentNameCol && row[residentNameCol] && row[residentNameCol].trim()) {
            const person = {
              name: row[residentNameCol].trim(),
              homePhone: homePhoneCol ? (row[homePhoneCol] || '').trim() : '',
              cellPhone: cellPhoneCol ? (row[cellPhoneCol] || '').trim() : '',
              email: emailCol ? (row[emailCol] || '').trim() : '',
              age: ageCol ? (row[ageCol] || '').trim() : '',
              gender: genderCol ? (row[genderCol] || '').trim() : '',
              lastContactDate: lastContactDateCol ? (row[lastContactDateCol] || '').trim() : '',
              contactNotes: contactNotesCol ? (row[contactNotesCol] || '').trim() : '',
              personNotes: []
            };
            
            // Collect all person notes
            personNotesCols.forEach(noteCol => {
              const note = row[noteCol] ? (row[noteCol] || '').trim() : '';
              if (note) {
                person.personNotes.push({ label: noteCol, value: note });
              }
            });
            
            addressData.people.push(person);
          }
        });
        
        groupedByAddress[addr] = addressData;
      });
      
      // Create print window
      const printWindow = window.open('', '_blank');
      const addressCount = Object.keys(groupedByAddress).length;
      const peopleCount = filteredAddresses.reduce((sum, addr) => {
        return sum + (groupedByAddress[addr]?.people.length || 0);
      }, 0);
      
      // Helper function to format checkbox values
      const formatCheckbox = (value) => {
        if (!value) return 'No';
        const val = String(value).trim().toLowerCase();
        return (val === 'true' || val === 'yes' || (val !== '' && val !== 'false' && val !== 'no')) ? 'Yes' : 'No';
      };
      
      let html = `
        <!DOCTYPE html>
        <html>
        <head>
          <title>Call Sheet - ${addressCount} Address${addressCount !== 1 ? 'es' : ''}</title>
          <style>
            @media print {
              @page { 
                margin: 0.5in;
                size: letter;
              }
            }
            body {
              font-family: Arial, sans-serif;
              padding: 0;
              color: #000;
              font-size: 9pt;
              line-height: 1.3;
            }
            h1 {
              margin: 0 0 4px 0;
              font-size: 12pt;
              font-weight: bold;
            }
            .print-meta {
              font-size: 8pt;
              margin-bottom: 12px;
              color: #666;
            }
            .address-group {
              margin-bottom: 16px;
              page-break-inside: avoid;
            }
            .address-header {
              font-weight: bold;
              font-size: 10pt;
              margin-bottom: 6px;
              padding-bottom: 2px;
              border-bottom: 1px solid #000;
            }
            .address-info {
              font-size: 8pt;
              margin-bottom: 8px;
              padding-left: 8px;
            }
            .address-info-item {
              display: inline-block;
              margin-right: 12px;
            }
            .address-info-item strong {
              margin-right: 4px;
            }
            .address-notes {
              font-size: 8pt;
              margin: 4px 0 8px 8px;
              padding: 4px;
              border-left: 1px solid #ccc;
            }
            .people-table {
              width: 100%;
              border-collapse: collapse;
              font-size: 8pt;
              margin-bottom: 4px;
            }
            .people-table th {
              text-align: left;
              font-weight: bold;
              padding: 3px 6px;
              border-bottom: 1px solid #000;
              background: #f0f0f0;
            }
            .people-table td {
              padding: 4px 6px;
              vertical-align: top;
              border-bottom: 1px dotted #ccc;
            }
            .people-table tr:last-child td {
              border-bottom: 1px solid #ccc;
            }
            .person-name {
              font-weight: bold;
              white-space: nowrap;
            }
            .person-contact {
              white-space: nowrap;
            }
            .person-notes {
              font-size: 7.5pt;
              max-width: 200px;
            }
            .person-notes-item {
              margin: 2px 0;
              padding: 2px 0;
            }
            .person-notes-label {
              font-weight: bold;
              font-size: 7pt;
            }
            .contact-info {
              font-size: 7.5pt;
            }
            .contact-date {
              font-weight: bold;
            }
            .notes-column {
              width: 180px;
              min-width: 180px;
            }
            .checkbox-space {
              width: 60px;
              min-width: 60px;
              text-align: center;
            }
            .checkbox-cell {
              font-size: 7pt;
              padding: 2px;
            }
          </style>
        </head>
        <body>
          <h1>Call Sheet</h1>
          <div class="print-meta">${new Date().toLocaleDateString()} ‚Ä¢ ${peopleCount} contact${peopleCount !== 1 ? 's' : ''} at ${addressCount} address${addressCount !== 1 ? 'es' : ''}</div>
      `;
      
      Object.keys(groupedByAddress).sort().forEach(address => {
        const data = groupedByAddress[address];
        html += `
          <div class="address-group">
            <div class="address-header">${escapeHtml(address)}</div>
            <div class="address-info">
              ${data.damage ? `<span class="address-info-item"><strong>Damage:</strong>${escapeHtml(data.damage)}</span>` : ''}
              ${data.status ? `<span class="address-info-item"><strong>Status:</strong>${escapeHtml(data.status)}</span>` : ''}
              ${data.rebuildStage ? `<span class="address-info-item"><strong>Build Stage:</strong>${escapeHtml(data.rebuildStage)}</span>` : ''}
              ${data.rebuildStatus ? `<span class="address-info-item"><strong>Build:</strong>${escapeHtml(data.rebuildStatus)}</span>` : ''}
              ${data.householdSize ? `<span class="address-info-item"><strong>HH Size:</strong>${escapeHtml(data.householdSize)}</span>` : ''}
              ${data.indoorsRemediated ? `<span class="address-info-item"><strong>Indoors Remed:</strong>${formatCheckbox(data.indoorsRemediated)}</span>` : ''}
              ${data.soilRemediated ? `<span class="address-info-item"><strong>Soil Remed:</strong>${formatCheckbox(data.soilRemediated)}</span>` : ''}
              ${data.captainAssigned ? `<span class="address-info-item"><strong>Captain:</strong>${escapeHtml(data.captainAssigned)}</span>` : ''}
            </div>
            ${data.addressNotes ? `
              <div class="address-notes"><strong>Address Notes:</strong> ${escapeHtml(data.addressNotes).replace(/\n/g, ' | ')}</div>
            ` : ''}
            <table class="people-table">
              <thead>
                <tr>
                  <th style="width: 120px;">Name</th>
                  <th style="width: 80px;">Age/Gender</th>
                  <th style="width: 100px;">Phone</th>
                  <th style="width: 100px;">Cell</th>
                  <th style="width: 140px;">Email</th>
                  <th style="width: 90px;">Last Contact</th>
                  <th style="width: 200px;">Contact Notes</th>
                  <th style="width: 200px;">Person Notes</th>
                  <th class="notes-column">Notes</th>
                  <th class="checkbox-space">‚òê</th>
                </tr>
              </thead>
              <tbody>
        `;
        
        data.people.forEach((person, index) => {
          const phones = [];
          if (person.homePhone) phones.push(`H:${escapeHtml(person.homePhone)}`);
          if (person.cellPhone) phones.push(`C:${escapeHtml(person.cellPhone)}`);
          const phoneDisplay = phones.length > 0 ? phones.join(' ') : '';
          
          const ageGender = [];
          if (person.age) ageGender.push(escapeHtml(person.age));
          if (person.gender) ageGender.push(escapeHtml(person.gender));
          const ageGenderDisplay = ageGender.length > 0 ? ageGender.join('/') : '';
          
          // Combine all person notes
          const allPersonNotes = person.personNotes.map(note => 
            `<div class="person-notes-item"><span class="person-notes-label">${escapeHtml(note.label)}:</span> ${escapeHtml(note.value).replace(/\n/g, ' ')}</div>`
          ).join('');
          
          html += `
                <tr>
                  <td class="person-name">${escapeHtml(person.name)}</td>
                  <td class="person-contact">${ageGenderDisplay}</td>
                  <td class="person-contact">${person.homePhone ? escapeHtml(person.homePhone) : ''}</td>
                  <td class="person-contact">${person.cellPhone ? escapeHtml(person.cellPhone) : ''}</td>
                  <td class="person-contact">${person.email ? escapeHtml(person.email) : ''}</td>
                  <td class="contact-info">
                    ${person.lastContactDate ? `<span class="contact-date">${escapeHtml(person.lastContactDate)}</span>` : ''}
                  </td>
                  <td class="contact-info">${person.contactNotes ? escapeHtml(person.contactNotes).replace(/\n/g, ' | ') : ''}</td>
                  <td class="person-notes">${allPersonNotes}</td>
                  <td class="notes-column"></td>
                  <td class="checkbox-space checkbox-cell"></td>
                </tr>
          `;
        });
        
        html += `
              </tbody>
            </table>
          </div>
        `;
      });
      
      html += `
        </body>
        </html>
      `;
      
      printWindow.document.write(html);
      printWindow.document.close();
      
      // Wait for content to load before printing
      setTimeout(() => {
        printWindow.print();
      }, 250);
    }
    
    // Export addresses to CSV
    function exportAddressesToCSV() {
      const filteredAddresses = getFilteredAddresses();
      if (filteredAddresses.length === 0) {
        alert('No addresses to export. Please adjust your filters.');
        return;
      }
      
      const headers = sheetData.headers;
      const residentNameCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('resident name') || (lower.includes('name') && !lower.includes('first') && !lower.includes('last') && !lower.includes('nc'));
      });
      const phoneCol = findColumn(headers, 'phone', ['nc']);
      const emailCol = findColumn(headers, 'email');
      const damageCol = findColumn(headers, 'damage');
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
      const rebuildCol = findColumn(headers, ['build', 'status'], ['intent']);
      const contactDateCol = findColumn(headers, ['contact', 'date']);
      
      // Build CSV headers
      const csvHeaders = ['Address', 'Name'];
      if (phoneCol) csvHeaders.push('Phone');
      if (emailCol) csvHeaders.push('Email');
      if (damageCol) csvHeaders.push('Damage Status');
      if (addressPlanCol) csvHeaders.push('Address Plan');
      if (rebuildCol) csvHeaders.push('Build Status');
      if (contactDateCol) csvHeaders.push('Last Contact');
      
      // Build CSV rows
      const csvRows = [];
      filteredAddresses.forEach(addr => {
        const rows = sheetData.addressMap.get(addr);
        if (!rows || rows.length === 0) {
          // Address with no people
          const row = [addr, ''];
          if (phoneCol) row.push('');
          if (emailCol) row.push('');
          if (damageCol) row.push('');
          if (addressPlanCol) row.push('');
          if (rebuildCol) row.push('');
          if (contactDateCol) row.push('');
          csvRows.push(row);
          return;
        }
        
        // One row per person
        rows.forEach((row, index) => {
          const personName = residentNameCol ? (row[residentNameCol] || '').trim() : '';
          // Only include row if person has a name
          if (personName || index === 0) {
            const csvRow = [addr, personName];
            if (phoneCol) csvRow.push(row[phoneCol] || '');
            if (emailCol) csvRow.push(row[emailCol] || '');
            if (damageCol) csvRow.push(index === 0 ? (rows[0][damageCol] || '') : '');
            if (addressPlanCol) csvRow.push(index === 0 ? (rows[0][addressPlanCol] || '') : '');
            if (rebuildCol) csvRow.push(index === 0 ? (rows[0][rebuildCol] || '') : '');
            if (contactDateCol) csvRow.push(row[contactDateCol] || '');
            csvRows.push(csvRow);
          }
        });
      });
      
      // Convert to CSV format
      const escapeCSV = (cell) => {
        const str = String(cell || '');
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
          return `"${str.replace(/"/g, '""')}"`;
        }
        return str;
      };
      
      const csv = [
        csvHeaders.map(escapeCSV).join(','),
        ...csvRows.map(row => row.map(escapeCSV).join(','))
      ].join('\n');
      
      // Download CSV
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `addresses-${Date.now()}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function displayAddressList(addresses) {
      // Clear selected address when showing list
      selectedAddress = null;
      
      if (addresses.length === 0) {
        addressPanelContent.innerHTML = '<div class="empty">No addresses found</div>';
        return;
      }

      // Get unique values for all filters
      const streets = getUniqueStreets(addresses);
      const damages = getUniqueDamage(addresses);
      
      // Filter addresses by all selected filters (same logic as displayAddressTable)
      const headers = sheetData.headers;
      const rebuildCol = findColumn(headers, ['build', 'status'], ['intent']);
      const contactDateCol = findColumn(headers, ['contact', 'date']);
      
      const filteredAddresses = addresses.filter(addr => {
        // Street filter
        if (currentStreetFilter !== 'all' && extractStreet(addr) !== currentStreetFilter) {
          return false;
        }
        // Damage filter
        if (currentDamageFilter !== 'all') {
          const addrDamage = getAddressDamage(addr);
          if (currentDamageFilter === '') {
            // Filter for "(not set)" - addresses with no damage status
            if (addrDamage && addrDamage.trim() !== '' && addrDamage !== '(not set)') {
              return false;
            }
          } else {
            if (addrDamage !== currentDamageFilter) {
              return false;
            }
          }
        }
        // Status filter
        if (currentAddressPlanFilter !== 'all') {
          const addrPlan = getAddressPlan(addr);
          if (currentAddressPlanFilter === '') {
            if (addrPlan !== null && addrPlan !== '') return false;
          } else if (addrPlan !== currentAddressPlanFilter) {
            return false;
          }
        }
        // Rebuild filter
        if (currentRebuildFilter !== 'all' && rebuildCol) {
          const rows = sheetData.addressMap.get(addr);
          if (rows && rows[0]) {
            const rebuildValue = normalizeRebuildStatusLabel((rows[0][rebuildCol] || '').trim());
            if (rebuildValue !== currentRebuildFilter) return false;
          } else {
            return false;
          }
        }
        // Captain assigned filter
        if (currentCaptainFilter !== 'all') {
          const captainAssignedCol = findColumn(headers, 'captain assigned');
          if (captainAssignedCol) {
            const rows = sheetData.addressMap.get(addr);
            if (rows && rows[0]) {
              const captainValue = (rows[0][captainAssignedCol] || '').trim();
              if (currentCaptainFilter === '') {
                // Filter for "(not specified)" - addresses with no captain assigned
                if (captainValue && captainValue.trim() !== '') return false;
              } else {
                if (captainValue !== currentCaptainFilter) return false;
              }
            } else {
              // No rows for address - check if we're filtering for "(not specified)"
              if (currentCaptainFilter !== '') return false;
            }
          }
        }
        // Contact status filter
        if (contactDateCol) {
          const isContacted = isAddressContacted(addr);
          if (isContacted && !showContactedAddresses) return false;
          if (!isContacted && !showUncontactedAddresses) return false;
        }
        return true;
      });

      const html = `
        <ul class="address-list">
          ${filteredAddresses.map(addr => `
            <li class="address-item" data-address="${addr.replace(/"/g, '&quot;')}">
              ${addr}
            </li>
          `).join('')}
        </ul>
      `;
      
      addressPanelContent.innerHTML = html;

      // Add click handlers
      document.querySelectorAll('.address-item').forEach(item => {
        item.addEventListener('click', () => {
          const address = item.getAttribute('data-address');
          displayAddressDetails(address);
          
          // Update active state
          document.querySelectorAll('.address-item').forEach(i => i.classList.remove('active'));
          item.classList.add('active');
        });
      });
    }

    // Display details for a specific address
    function displayAddressDetails(address, preserveScroll = false) {
      if (!sheetData.addressMap || !sheetData.addressMap.has(address)) {
        return;
      }

      // Track selected address
      selectedAddress = address;
      
      // Highlight the corresponding marker on the map
      highlightSelectedMarker(address);
      
      // Save scroll position if we're refreshing
      if (preserveScroll) {
        savedScrollPosition = addressPanelContent.scrollTop;
      }

      const rows = sheetData.addressMap.get(address);
      const { headers, addressCol, data } = sheetData;

      // Check if zone has multiple captains (only show Captain Assigned dropdown if so)
      const ncNameCol = findColumn(headers, 'nc name');
      const ncPhoneCol = findColumn(headers, 'nc phone');
      const ncEmailCol = findColumn(headers, 'nc email');
      let hasMultipleCaptains = false;
      let captains = [];
      let captainAssignedCol = null;
      
      if (ncNameCol && data && data.length > 0) {
        const firstRow = data[0];
        const ncName = firstRow[ncNameCol] ? (firstRow[ncNameCol] || '').trim() : '';
        const ncPhone = ncPhoneCol ? (firstRow[ncPhoneCol] || '').trim() : '';
        const ncEmail = ncEmailCol ? (firstRow[ncEmailCol] || '').trim() : '';
        captains = parseCaptains(ncName, ncPhone, ncEmail);
        hasMultipleCaptains = captains.length > 1;
        
        // Find Captain Assigned column if it exists
        captainAssignedCol = findColumn(headers, 'captain assigned');
      }

      // Find relevant columns (exclude address column itself)
      const detailCols = headers.filter(h => 
        h !== addressCol && 
        h.toLowerCase() !== 'address' &&
        rows.some(row => row[h] && row[h].trim())
      );
      
      // Define which address-level fields to DISPLAY (others are hidden)
      // Note: "address" is excluded since it's shown as the heading
      const addressLevelDisplayFields = [
        'household size',
        'damage',
        'address plan',
        'address notes',
        'rebuild stage',
        'rebuild status',
        'build stage',
        'build status'
      ];
      
      // Add Captain Assigned if zone has multiple captains and column exists
      if (hasMultipleCaptains && captainAssignedCol) {
        addressLevelDisplayFields.push('captain assigned');
      }
      
      // Separate address-level and person-level columns
      const addressLevelCols = headers.filter(h => {
        const lower = h.toLowerCase();
        // Explicitly exclude person-level notes and email address
        if (lower.includes('person note')) return false;
        if (lower.includes('email address')) return false;
        // Address-level: fields that are the same for all people at this address
        // But only include if they're in the display list
        const isSameForAll = rows.length > 0 && rows.every(r => (r[h] || '').trim() === (rows[0][h] || '').trim());
        const shouldDisplay = addressLevelDisplayFields.some(field => lower.includes(field));
        if (!shouldDisplay) return false;
        // Force key address-level fields to display even if rows vary
        const forceAddressLevelFields = [
          'damage',
          'address plan',
          'build status',
          'build stage',
          'rebuild status',
          'rebuild stage',
          'address notes',
          'household size'
        ];
        const forceAddressLevel = forceAddressLevelFields.some(field => lower.includes(field));
        return isSameForAll || forceAddressLevel;
      });
      
      // Fields to hide from person view (address-level; address is shown as header)
      const hiddenFromPersonView = [
        'house #',
        'house number',
        'house num',
        'street',
        'zip',
        'city',
        'state',
        'zip_code',
        'resident name',
        'zone',
        'nc name',
        'nc email',
        'damage',
        'address plan',
        'household size',
        'latitude',
        'longitude',
        'nc phone',
        'first name',
        'middle name',
        'last name',
        'rebuild stage',
        'rebuild status',
        'build stage',
        'build status',
        'indoors remediated',
        'soil remediated',
        'for sale',
        'recently sold',
        'sold since fire',
        'unit type'
      ];

      const isHouseOrZipField = (lower) => {
        const normalized = lower.trim();
        const isHouseField =
          (normalized === 'house' ||
           normalized === 'house #' ||
           normalized === 'house#' ||
           normalized === 'house number' ||
           normalized === 'house num' ||
           normalized.includes('house #') ||
           normalized.includes('house#')) &&
          !normalized.includes('household') &&
          !normalized.includes('housing');
        const isZipField =
          normalized === 'zip' ||
          normalized.includes('zip code') ||
          normalized.includes('zip_code') ||
          normalized.includes('postal');
        return isHouseField || isZipField;
      };

      const isPersonEmailCol = (colName) => {
        const lower = colName.toLowerCase();
        return lower.includes('email') && !lower.includes('nc email');
      };
      
      const personLevelCols = headers.filter(h => {
        const lower = h.toLowerCase();
        // Skip hidden fields
        if (hiddenFromPersonView.some(field => lower.includes(field)) || isHouseOrZipField(lower)) return false;
        // Skip Contact Notes - it's shown separately in contact mode
        if (lower.includes('contact') && lower.includes('note')) return false;
        // Person-level: Person - X checkboxes (Renter, Needs Follow-Up, Unable to reach, etc.), Person Notes, phones, etc.
        return lower.startsWith('person - ') ||
               lower.includes('person note') ||
               lower.includes('home phone') ||
               lower.includes('cell') ||
               isPersonEmailCol(h) ||
               lower.includes('gender') ||
               lower.includes('age') ||
               (!addressLevelCols.includes(h) && detailCols.includes(h));
      });
      
      // Find Notes columns separately - always show them if signed in, even if empty
      // Exclude Contact Notes - it's shown separately in contact mode
      const allNotesCols = headers.filter(h => 
        h !== addressCol &&
        h.toLowerCase().includes('note') &&
        !(h.toLowerCase().includes('contact') && h.toLowerCase().includes('note')) &&
        accessToken // Only if signed in
      );
      
      // Add Notes columns to detailCols if not already there
      allNotesCols.forEach(col => {
        if (!detailCols.includes(col)) {
          detailCols.push(col);
        }
      });

      let html = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; gap: 12px;">
          <button class="btn-back" onclick="displayAddressList(Array.from(sheetData.addressMap.keys()).sort())">‚Üê Back to List</button>
          ${accessToken ? `
            <div style="display: flex; gap: 6px; align-items: flex-start; position: relative;">
              <div style="display: flex; flex-direction: column; align-items: flex-end; height: 50px; justify-content: flex-start;">
                <div style="display: flex; gap: 6px; align-items: center; margin-bottom: 2px;">
                  <button class="btn-save btn-save-small" id="saveChangesBtnTop" style="margin: 0; align-self: center;">Save Changes</button>
                  <button class="btn-refresh-small" id="refreshBtnTop" title="Refresh addresses now" style="margin: 0;">‚Üª</button>
                </div>
                <span class="save-status save-status-top" id="saveStatusTop"></span>
              </div>
            </div>
          ` : ''}
        </div>
        <div class="address-details active">
          <h3>${address}</h3>
      `;

      // Collect unique values for dropdown fields from ALL data
      const damageValues = new Set();
      const addressPlanValues = new Set();
      const damageCol = findColumn(headers, 'damage');
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
      
      const defaultDamageValues = ['Total Loss', 'Partial Loss', 'Standing'];
      const defaultAddressPlanValues = ['Undecided', 'Building', 'Selling', 'Other', 'Unknown'];
      
      sheetData.data.forEach(row => {
        if (damageCol && row[damageCol] !== undefined && row[damageCol] !== null) {
          const value = String(row[damageCol]).trim();
          if (value) damageValues.add(value);
        }
        if (addressPlanCol && row[addressPlanCol] !== undefined && row[addressPlanCol] !== null) {
          const value = String(row[addressPlanCol]).trim();
          if (value) addressPlanValues.add(value);
        }
      });
      
      if (damageCol) defaultDamageValues.forEach(val => damageValues.add(val));
      if (addressPlanCol) defaultAddressPlanValues.forEach(val => addressPlanValues.add(val));
      
      // Removed console.log statements to reduce noise

      // Get damage status to check if remediation fields should be shown
      // Note: damageCol is already declared above, so we'll use it here
      const damageStatus = damageCol && rows[0] ? (rows[0][damageCol] || '').trim() : '';
      const showRemediationFields = damageStatus.toLowerCase() === 'standing' || damageStatus.toLowerCase() === 'partial loss';
      
      // Get Address Plan to check if build stage should be shown (only when Damage = Partial/Total and Address Plan = Building)
      const addressPlanValue = addressPlanCol && rows[0] ? (rows[0][addressPlanCol] || '').trim() : '';
      const showRebuildStage = addressPlanValue.toLowerCase() === 'building';
      
      // Show address-level fields once at the top (always show, not just when signed in)
      if (addressLevelCols.length > 0) {
        html += '<div class="address-level-section" style="background: rgba(255,255,255,0.7); padding: 12px; border-radius: 6px; margin-bottom: 16px; border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 1px 3px rgba(0,0,0,0.04);">';
        
        addressLevelCols.forEach(col => {
          const firstRowValue = rows[0] ? (rows[0][col] || '') : '';
          const lower = col.toLowerCase();
          const isNotes = lower.includes('note');
          const isDamage = lower.includes('damage');
          const isAddressPlan = lower.includes('address') && lower.includes('plan') && !lower.includes('note');
          const isStatus = isAddressPlan;
          const isRebuildStage = lower.includes('rebuild stage') ||
            lower.includes('rebuild status') ||
            lower.includes('build stage') ||
            lower.includes('build status');
          const isIndoorsRemediated = lower.includes('indoors remediated');
          const isSoilRemediated = lower.includes('soil remediated');
          const isCaptainAssigned = lower.includes('captain assigned');
          const isEditable = accessToken; // All fields editable when signed in
          
          // Hide remediation fields for now
          if (isIndoorsRemediated || isSoilRemediated) {
            return;
          }
          
          if (isEditable) {
            if (isNotes) {
              // Notes: expandable textarea
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <textarea class="editable-notes" 
                     data-address="${address.replace(/"/g, '&quot;')}" 
                     data-address-level="true"
                     data-column="${col}"
                     data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">${firstRowValue}</textarea>
              </div>`;
            } else if (isDamage || isStatus) {
              // Damage / Address Plan: dropdown
              let options;
              if (isDamage) {
                options = Array.from(damageValues).sort();
              } else {
                options = ['Undecided', 'Building', 'Selling', 'Other', 'Unknown'].filter(opt => addressPlanValues.has(opt));
                options = options.concat(Array.from(addressPlanValues).filter(opt => !options.includes(opt)).sort());
              }
              const addressPlanDropdownId = isAddressPlan ? `address-plan-${address.replace(/[^a-zA-Z0-9]/g, '-')}` : '';
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <select class="editable-dropdown ${isAddressPlan ? 'address-plan-dropdown' : ''}" 
                        id="${addressPlanDropdownId}"
                        data-address="${address.replace(/"/g, '&quot;')}" 
                        data-address-level="true"
                        data-column="${col}"
                        data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">
                  <option value="">(not set)</option>
                  ${options.map(opt => `<option value="${opt.replace(/"/g, '&quot;')}" ${opt === firstRowValue ? 'selected' : ''}>${opt}</option>`).join('')}
                </select>
              </div>`;
            } else if (isRebuildStage) {
              // Build Status: dropdown with specific options - always render but hide if not Building
              const rebuildStageOptions = [
                'Planning/Not Ready to Build Yet',
                'Permits & Pre-Construction',
                'Under Construction',
                'Finishing/Preparing to Move Back',
                'Moved In'
              ];
              const normalizedFirst = normalizeRebuildStatusLabel(firstRowValue);
              const rebuildStageId = `rebuild-stage-${address.replace(/[^a-zA-Z0-9]/g, '-')}`;
              const rebuildStageStyle = showRebuildStage ? '' : 'style="display: none;"';
              html += `<div class="person-info rebuild-stage-field" id="${rebuildStageId}" ${rebuildStageStyle}>
                <strong>${col}:</strong>
                <select class="editable-dropdown" 
                        data-address="${address.replace(/"/g, '&quot;')}" 
                        data-address-level="true"
                        data-column="${col}"
                        data-original-value="${(firstRowValue || '').replace(/"/g, '&quot;')}">
                  <option value="">(not set)</option>
                  ${rebuildStageOptions.map(opt => `<option value="${opt.replace(/"/g, '&quot;')}" ${opt === normalizedFirst ? 'selected' : ''}>${opt}</option>`).join('')}
                </select>
              </div>`;
            } else if (isCaptainAssigned && hasMultipleCaptains && captains.length > 0) {
              // Captain Assigned: dropdown with captain names (only if multiple captains exist)
              const captainNames = captains.map(c => c.name).filter(n => n !== 'N/A');
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <select class="editable-dropdown" 
                        data-address="${address.replace(/"/g, '&quot;')}" 
                        data-address-level="true"
                        data-column="${col}"
                        data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">
                  <option value="">(not specified)</option>
                  ${captainNames.map(name => `<option value="${name.replace(/"/g, '&quot;')}" ${name === firstRowValue ? 'selected' : ''}>${escapeHtml(name)}</option>`).join('')}
                </select>
              </div>`;
            } else if (isIndoorsRemediated || isSoilRemediated) {
              // Remediation fields: checkbox
              // Convert value to boolean - handle TRUE/FALSE (Google Sheets checkbox format), yes/no, true/false, or any non-empty value
              const valueStr = (firstRowValue || '').trim();
              const valueStrLower = valueStr.toLowerCase();
              const isChecked = valueStrLower === 'true' || valueStr === 'TRUE' || 
                               valueStrLower === 'yes' || 
                               (valueStr !== '' && valueStrLower !== 'false' && valueStr !== 'FALSE' && valueStrLower !== 'no');
              html += `<div class="person-info">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                  <input type="checkbox" 
                         class="editable-checkbox" 
                         data-address="${address.replace(/"/g, '&quot;')}" 
                         data-address-level="true"
                         data-column="${col}"
                         data-original-value="${firstRowValue.replace(/"/g, '&quot;')}"
                         ${isChecked ? 'checked' : ''}
                         style="width: 18px; height: 18px; cursor: pointer;">
                  <strong>${col}:</strong>
                </label>
              </div>`;
            } else {
              // Other fields: subtle editable
              html += `<div class="person-info">
                <strong>${col}:</strong>
                <span class="editable-inline" contenteditable="true" 
                      data-address="${address.replace(/"/g, '&quot;')}" 
                      data-address-level="true"
                      data-column="${col}"
                      data-original-value="${firstRowValue.replace(/"/g, '&quot;')}">${firstRowValue || ''}</span>
              </div>`;
            }
          } else {
            // Not signed in: display only
            if (isIndoorsRemediated || isSoilRemediated) {
              // For checkboxes, show as Yes/No
              const valueStr = (firstRowValue || '').trim();
              const valueStrLower = valueStr.toLowerCase();
              const isChecked = valueStrLower === 'true' || valueStr === 'TRUE' || 
                               valueStrLower === 'yes' || 
                               (valueStr !== '' && valueStrLower !== 'false' && valueStr !== 'FALSE' && valueStrLower !== 'no');
              html += `<div class="person-info"><strong>${col}:</strong> ${isChecked ? 'Yes' : 'No'}</div>`;
            } else {
              html += `<div class="person-info"><strong>${col}:</strong> ${firstRowValue || '(not set)'}</div>`;
            }
          }
        });

        // Address Tags: expandable section (collapsed by default) - Unit Type, For Sale, Sold Since Fire
        const unitTypeCol = findColumn(headers, ['unit', 'type']);
        const forSaleCol = findColumn(headers, ['for', 'sale']);
        const recentlySoldCol = findColumn(headers, ['recently', 'sold']) || findColumn(headers, ['sold', 'since', 'fire']);
        const hasAddressTagsCols = unitTypeCol || forSaleCol || recentlySoldCol;
        if (hasAddressTagsCols) {
          const firstRow = rows[0] || {};
          const unitTypeVal = unitTypeCol ? (firstRow[unitTypeCol] || '').trim() : '';
          const forSaleVal = forSaleCol ? (firstRow[forSaleCol] || '').trim() : '';
          const recentlySoldVal = recentlySoldCol ? (firstRow[recentlySoldCol] || '').trim() : '';
          const unitTypeOptions = ['Owner Occupied', 'Rental', 'Owner Occupied Plus Rental', 'Commercial', 'Other'];
          const forSaleLower = forSaleVal.toLowerCase();
          const recentlySoldLower = recentlySoldVal.toLowerCase();
          const forSaleChecked = forSaleLower === 'true' || forSaleVal === 'TRUE' || forSaleLower === 'yes' ||
            (forSaleVal !== '' && forSaleLower !== 'false' && forSaleVal !== 'FALSE' && forSaleLower !== 'no');
          const recentlySoldChecked = recentlySoldLower === 'true' || recentlySoldVal === 'TRUE' || recentlySoldLower === 'yes' ||
            (recentlySoldVal !== '' && recentlySoldLower !== 'false' && recentlySoldVal !== 'FALSE' && recentlySoldLower !== 'no');
          html += '<details class="address-tags-section" style="margin-top:12px;">';
          html += '<summary style="cursor:pointer; font-weight:700; font-family: Chivo, sans-serif;">Address Tags</summary>';
          html += '<div style="margin-top:12px; padding-left:0;">';
          if (unitTypeCol) {
            html += `<div class="person-info"><strong>Unit Type:</strong>
              <select class="editable-dropdown" data-address="${address.replace(/"/g, '&quot;')}" data-address-level="true" data-column="${unitTypeCol}" data-original-value="${unitTypeVal.replace(/"/g, '&quot;')}" style="margin-top:4px;">
                <option value="">(not set)</option>
                ${unitTypeOptions.map(opt => {
                  const isSelected = unitTypeVal && opt.toLowerCase() === unitTypeVal.toLowerCase();
                  return `<option value="${opt.replace(/"/g, '&quot;')}" ${isSelected ? 'selected' : ''}>${opt}</option>`;
                }).join('')}
              </select></div>`;
          }
          if (forSaleCol) {
            html += `<div class="person-info"><label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
              <input type="checkbox" class="editable-checkbox" data-address="${address.replace(/"/g, '&quot;')}" data-address-level="true" data-column="${forSaleCol}" data-original-value="${forSaleVal.replace(/"/g, '&quot;')}" ${forSaleChecked ? 'checked' : ''} style="width:18px; height:18px;">
              <strong>For Sale</strong></label></div>`;
          }
          if (recentlySoldCol) {
            html += `<div class="person-info"><label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
              <input type="checkbox" class="editable-checkbox" data-address="${address.replace(/"/g, '&quot;')}" data-address-level="true" data-column="${recentlySoldCol}" data-original-value="${recentlySoldVal.replace(/"/g, '&quot;')}" ${recentlySoldChecked ? 'checked' : ''} style="width:18px; height:18px;">
              <strong>Sold Since Fire</strong></label></div>`;
          }
          html += '</div></details>';
        }

        html += '</div>';
      }

      // Check if contact mode is active
      const isContactMode = window.contactModeActive || false;
      const lastContactCol = headers.find(h => 
        h.toLowerCase() === 'last contact date' ||
        h.toLowerCase().includes('last contact') || 
        h.toLowerCase().includes('contact date') ||
        h.toLowerCase().includes('contacted')
      );

      // Show person-level fields for each person
      rows.forEach((row, index) => {
        // Get the original row index that was stored when grouping
        const originalRowIndex = row.__originalIndex !== undefined ? row.__originalIndex : -1;
        
        // Check contact status
        const lastContact = lastContactCol ? (row[lastContactCol] || '').trim() : '';
        const isContacted = lastContact && lastContact.length > 0;
        const contactClass = isContacted ? 'recent-contact' : (isContactMode ? 'no-contact' : '');
        
        html += `<div class="person-entry ${contactClass}">`;
        
        // Try to find name column - show Resident Name as the person's name
        const nameCol = headers.find(h => 
          h.toLowerCase().includes('resident name') || 
          (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name'))
        );
        
        if (nameCol && row[nameCol]) {
          html += `<div class="person-name">${row[nameCol]}</div>`;
        } else if (rows.length > 1) {
          html += `<div class="person-name">Person ${index + 1}</div>`;
        }

        // Contact mode: show contact button and quick notes
        if (isContactMode && accessToken) {
          html += `
            <div style="margin-top: 8px; margin-bottom: 8px;">
              <button class="contact-button ${isContacted ? 'contacted' : ''}" 
                      data-address="${address.replace(/"/g, '&quot;')}"
                      data-original-row-index="${originalRowIndex}"
                      data-column="${lastContactCol || 'Last Contact Date'}"
                      onclick="markContact(this, '${address.replace(/"/g, '&quot;')}', ${originalRowIndex}, '${lastContactCol || 'Last Contact Date'}')">
                ${isContacted ? '‚úì Contacted' : 'Mark as Contacted'}
              </button>
              ${isContacted ? `<div class="contact-date">Last contact: ${lastContact}</div>` : ''}
              <textarea class="contact-notes-quick" 
                        placeholder="Quick contact notes..."
                        data-address="${address.replace(/"/g, '&quot;')}"
                        data-original-row-index="${originalRowIndex}"
                        data-column="Contact Notes"
                        data-original-value="${(row['Contact Notes'] || '').replace(/"/g, '&quot;')}">${row['Contact Notes'] || ''}</textarea>
            </div>
          `;
        } else if (isContactMode && !accessToken) {
          // Contact mode but not signed in - show status only
          html += `
            <div style="margin-top: 8px; margin-bottom: 8px;">
              <div style="font-size: 0.85rem; color: ${isContacted ? '#4caf50' : '#ff9800'};">
                ${isContacted ? `‚úì Contacted (${lastContact})` : '‚ö† Not contacted'}
              </div>
            </div>
          `;
        }

        // Display person-level fields (show even if empty, like Notes)
        // First, identify fields that should be grouped together
        const ageCol = personLevelCols.find(col => {
          const lower = col.toLowerCase();
          return lower.includes('age') && !lower.includes('phone') && !lower.includes('resident name');
        });
        const genderCol = personLevelCols.find(col => {
          const lower = col.toLowerCase();
          return lower.includes('gender') && !lower.includes('resident name');
        });
        const homePhoneCol = personLevelCols.find(col => {
          const lower = col.toLowerCase();
          return (lower.includes('home phone') || lower.includes('homephone') || 
                  (lower.includes('phone') && lower.includes('home'))) && 
                 !lower.includes('cell') && !lower.includes('mobile');
        });
        const cellPhoneCol = personLevelCols.find(col => {
          const lower = col.toLowerCase();
          return (lower.includes('cell') || lower.includes('mobile')) && 
                 (lower.includes('phone') || lower.includes('cell') || lower.includes('mobile'));
        });
        
        const renderedFields = new Set(); // Track which fields have been rendered
        
        // Helper function to format column name for display
        const formatColumnLabel = (col) => {
          const lower = col.toLowerCase();
          if (lower.includes('home phone') || lower.includes('homephone') ||
              (lower.includes('phone') && lower.includes('home'))) {
            return 'Home üìû';
          }
          if ((lower.includes('cell') || lower.includes('mobile')) &&
              (lower.includes('phone') || lower.includes('cell') || lower.includes('mobile'))) {
            return 'Cell üìû';
          }
          // Remove "Person - " prefix from checkbox fields; use friendly label for specific columns
          if (col.startsWith('Person - ')) {
            const suffix = col.substring(9);
            if (suffix.toLowerCase() === 'unable to reach') return 'Unable to reach';
            return suffix;
          }
          return col;
        };

        // Omit colon for phone labels and person-tag checkboxes (Renter, Needs Follow-Up, Unable to reach)
        const formatLabelForDisplay = (label) => {
          if (label === 'Home üìû' || label === 'Cell üìû' || label === 'Renter' || label === 'Needs Follow-Up' || label === 'Unable to reach') return label;
          return label + ':';
        };
        
        // Helper function to render a single field
        const renderField = (col, isInline = false) => {
          if (renderedFields.has(col)) return '';
          renderedFields.add(col);
          
          const isNotes = col.toLowerCase().includes('note');
          const isPersonCheckbox = col.startsWith('Person - ');
          const isEmail = isPersonEmailCol(col);
          const isEditable = accessToken;
          const value = row[col] || '';
          const displayLabel = formatColumnLabel(col);
          
          // Copy button HTML for email addresses
          const copyButton = isEmail && value.trim() ? `
            <button class="copy-email-btn" 
                    data-email="${value.replace(/"/g, '&quot;')}" 
                    title="Copy email address"
                    style="background: none; border: none; cursor: pointer; padding: 2px 4px; display: inline-flex; align-items: center; opacity: 0.6; transition: opacity 0.2s;">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          ` : '';
          
          if (isEditable) {
            if (isNotes) {
              return `<div class="person-info${isInline ? '-item' : ''}">
                <strong>${formatLabelForDisplay(displayLabel)}</strong>
                <textarea class="editable-notes" 
                     data-address="${address.replace(/"/g, '&quot;')}" 
                     data-original-row-index="${originalRowIndex}" 
                     data-column="${col}"
                     data-address-level="false"
                     data-original-value="${(row[col] || '').replace(/"/g, '&quot;')}">${row[col] || ''}</textarea>
              </div>`;
            } else if (isPersonCheckbox) {
              // Person-level checkbox fields
              const valueStr = (value || '').trim();
              const valueStrLower = valueStr.toLowerCase();
              const isChecked = valueStrLower === 'true' || valueStr === 'TRUE' || 
                               valueStrLower === 'yes' || 
                               (valueStr !== '' && valueStrLower !== 'false' && valueStr !== 'FALSE' && valueStrLower !== 'no');
              return `<div class="person-info${isInline ? '-item' : ''}">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                  <input type="checkbox" 
                         class="editable-checkbox" 
                         data-address="${address.replace(/"/g, '&quot;')}" 
                         data-original-row-index="${originalRowIndex}" 
                         data-column="${col}"
                         data-address-level="false"
                         data-original-value="${value.replace(/"/g, '&quot;')}"
                         ${isChecked ? 'checked' : ''}
                         style="width: 18px; height: 18px; cursor: pointer;">
                  <strong>${formatLabelForDisplay(displayLabel)}</strong>
                </label>
              </div>`;
            } else {
              return `<div class="person-info${isInline ? '-item' : ''}">
                <strong>${formatLabelForDisplay(displayLabel)}</strong>
                <span class="editable-inline" contenteditable="true" 
                      data-address="${address.replace(/"/g, '&quot;')}" 
                      data-original-row-index="${originalRowIndex}" 
                      data-column="${col}"
                      data-address-level="false"
                      data-original-value="${value.replace(/"/g, '&quot;')}">${value || ''}</span>
                ${copyButton}
              </div>`;
            }
          } else {
            if (isPersonCheckbox) {
              // For checkboxes, show as Yes/No
              const valueStr = (value || '').trim();
              const valueStrLower = valueStr.toLowerCase();
              const isChecked = valueStrLower === 'true' || valueStr === 'TRUE' || 
                               valueStrLower === 'yes' || 
                               (valueStr !== '' && valueStrLower !== 'false' && valueStr !== 'FALSE' && valueStrLower !== 'no');
              return `<div class="person-info${isInline ? '-item' : ''}"><strong>${formatLabelForDisplay(displayLabel)}</strong> ${isChecked ? 'Yes' : 'No'}</div>`;
            } else {
              return `<div class="person-info${isInline ? '-item' : ''}">
                <strong>${formatLabelForDisplay(displayLabel)}</strong> ${value || '(not set)'}
                ${copyButton}
              </div>`;
            }
          }
        };
        
        // Render Age and Gender on the same line if both exist
        if (ageCol || genderCol) {
          html += '<div class="person-info-inline">';
          if (ageCol) {
            // Skip Resident Name check for age
            if (!ageCol.toLowerCase().includes('resident name')) {
              html += renderField(ageCol, true);
            }
          }
          if (genderCol) {
            if (!genderCol.toLowerCase().includes('resident name')) {
              html += renderField(genderCol, true);
            }
          }
          html += '</div>';
        }
        
        // Render Home phone and Cell phone on the same line if both exist
        if (homePhoneCol || cellPhoneCol) {
          html += '<div class="person-info-inline">';
          if (homePhoneCol) {
            html += renderField(homePhoneCol, true);
          }
          if (cellPhoneCol) {
            html += renderField(cellPhoneCol, true);
          }
          html += '</div>';
        }
        
        // Email (above Person Tags)
        const emailCol = personLevelCols.find(col => isPersonEmailCol(col));
        if (emailCol) {
          html += renderField(emailCol);
        }
        
        // Person Tags accordion: only Renter, Needs Follow-Up, Unable to reach (same style as Address Tags)
        const personTagSuffixes = ['renter', 'needs follow-up', 'unable to reach'];
        const personTagCols = personLevelCols.filter(col => {
          if (!col.startsWith('Person - ')) return false;
          const suffix = col.substring(9).trim().toLowerCase();
          return personTagSuffixes.includes(suffix);
        });
        if (personTagCols.length > 0) {
          html += '<details class="address-tags-section" style="margin-top:12px;">';
          html += '<summary style="cursor:pointer; font-weight:700; font-family: Chivo, sans-serif;">Person Tags</summary>';
          html += '<div style="margin-top:12px; padding-left:0;">';
          personTagCols.forEach(col => {
            html += renderField(col);
          });
          html += '</div></details>';
        }
        
        // Remaining person-level fields (non-notes first), then Person Notes last
        const deferredNotesCols = [];
        personLevelCols.forEach(col => {
          // Skip fields already rendered or that should be skipped
          if (renderedFields.has(col)) return;
          if (col.toLowerCase().includes('resident name')) return;
          if (isContactMode && (col.toLowerCase().includes('contact') && col.toLowerCase().includes('note'))) return;
          // Defer notes to render last (after Person Tags)
          const isNotes = col.toLowerCase().includes('note');
          if (isNotes) {
            deferredNotesCols.push(col);
            return;
          }
          const isPersonCheckbox = col.startsWith('Person - ');
          const isEmail = isPersonEmailCol(col);
          const isEditable = accessToken;
          const displayLabel = formatColumnLabel(col);
          const value = row[col] || '';
          // Copy button HTML for email addresses
          const copyButton = isEmail && value.trim() ? `
            <button class="copy-email-btn" 
                    data-email="${value.replace(/"/g, '&quot;')}" 
                    title="Copy email address"
                    style="background: none; border: none; cursor: pointer; padding: 2px 4px; display: inline-flex; align-items: center; opacity: 0.6; transition: opacity 0.2s;">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          ` : '';
          
          if (isEditable) {
            if (isPersonCheckbox) {
              // Person-level checkbox fields
              const valueStr = (value || '').trim();
              const valueStrLower = valueStr.toLowerCase();
              const isChecked = valueStrLower === 'true' || valueStr === 'TRUE' || 
                               valueStrLower === 'yes' || 
                               (valueStr !== '' && valueStrLower !== 'false' && valueStr !== 'FALSE' && valueStrLower !== 'no');
              html += `<div class="person-info">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                  <input type="checkbox" 
                         class="editable-checkbox" 
                         data-address="${address.replace(/"/g, '&quot;')}" 
                         data-original-row-index="${originalRowIndex}" 
                         data-column="${col}"
                         data-address-level="false"
                         data-original-value="${value.replace(/"/g, '&quot;')}"
                         ${isChecked ? 'checked' : ''}
                         style="width: 18px; height: 18px; cursor: pointer;">
                  <strong>${formatLabelForDisplay(displayLabel)}</strong>
                </label>
              </div>`;
            } else {
              html += `<div class="person-info">
                <strong>${formatLabelForDisplay(displayLabel)}</strong>
                <span class="editable-inline" contenteditable="true" 
                      data-address="${address.replace(/"/g, '&quot;')}" 
                      data-original-row-index="${originalRowIndex}" 
                      data-column="${col}"
                      data-address-level="false"
                      data-original-value="${value.replace(/"/g, '&quot;')}">${value || ''}</span>
                ${copyButton}
              </div>`;
            }
          } else {
            if (isPersonCheckbox) {
              // For checkboxes, show as Yes/No
              const valueStr = (value || '').trim();
              const valueStrLower = valueStr.toLowerCase();
              const isChecked = valueStrLower === 'true' || valueStr === 'TRUE' || 
                               valueStrLower === 'yes' || 
                               (valueStr !== '' && valueStrLower !== 'false' && valueStr !== 'FALSE' && valueStrLower !== 'no');
              html += `<div class="person-info"><strong>${formatLabelForDisplay(displayLabel)}</strong> ${isChecked ? 'Yes' : 'No'}</div>`;
            } else {
              html += `<div class="person-info">
                <strong>${formatLabelForDisplay(displayLabel)}</strong> ${value || '(not set)'}
                ${copyButton}
              </div>`;
            }
          }
        });
        // Person Notes last
        deferredNotesCols.forEach(col => {
          const value = row[col] || '';
          const displayLabel = formatColumnLabel(col);
          if (accessToken) {
            html += `<div class="person-info">
                <strong>${formatLabelForDisplay(displayLabel)}</strong>
                <textarea class="editable-notes" 
                     data-address="${address.replace(/"/g, '&quot;')}" 
                     data-original-row-index="${originalRowIndex}" 
                     data-column="${col}"
                     data-address-level="false"
                     data-original-value="${(row[col] || '').replace(/"/g, '&quot;')}">${row[col] || ''}</textarea>
              </div>`;
          } else {
            html += `<div class="person-info">
                <strong>${formatLabelForDisplay(displayLabel)}</strong> ${value || '(not set)'}
              </div>`;
          }
        });
        
        // Display other non-notes fields that aren't address-level (but exclude hidden fields)
        detailCols.forEach(col => {
          const lower = col.toLowerCase();
          const isHidden = hiddenFromPersonView.some(field => lower.includes(field)) || isHouseOrZipField(lower);
          if (!addressLevelCols.includes(col) && !personLevelCols.includes(col) && 
              !col.toLowerCase().includes('note') && !isHidden) {
            if (row[col] && row[col].trim()) {
              html += `<div class="person-info"><strong>${col}:</strong> ${row[col]}</div>`;
            }
          }
        });

        html += '</div>';
      });

      // Add save button if signed in and there are editable fields
      if (accessToken) {
        html += `
          <div style="margin-top: 16px; padding-top: 16px; border-top: 2px solid var(--river);">
            <button class="btn-save" id="saveChangesBtn">Save Changes</button>
            <span class="save-status" id="saveStatus"></span>
          </div>
        `;
      }

      html += '</div>';
      addressPanelContent.innerHTML = html;
      
      // Add save button handlers (both top and bottom buttons)
      const saveBtn = document.getElementById('saveChangesBtn');
      if (saveBtn) {
        saveBtn.addEventListener('click', saveChanges);
      }
      const saveBtnTop = document.getElementById('saveChangesBtnTop');
      if (saveBtnTop) {
        saveBtnTop.addEventListener('click', saveChanges);
      }
      const refreshBtnTop = document.getElementById('refreshBtnTop');
      if (refreshBtnTop) {
        refreshBtnTop.addEventListener('click', () => {
          if (currentSheetUrl) {
            loadAddressData(currentSheetUrl);
          }
        });
      }
      
      // Add change handlers for dropdowns with auto-save
      document.querySelectorAll('.editable-dropdown').forEach(dropdown => {
        dropdown.addEventListener('change', () => {
          // Mark as changed for save
          dropdown.setAttribute('data-changed', 'true');
          
          const colName = dropdown.getAttribute('data-column');
          const colLower = (colName || '').toLowerCase();
          
          // If this is an Address Plan dropdown, show/hide Rebuild Stage field
          if (dropdown.classList.contains('address-plan-dropdown')) {
            const address = dropdown.getAttribute('data-address');
            const addressPlanVal = dropdown.value.trim().toLowerCase();
            const rebuildStageId = `rebuild-stage-${address.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const rebuildStageField = document.getElementById(rebuildStageId);
            
            if (rebuildStageField) {
              rebuildStageField.style.display = addressPlanVal === 'building' ? '' : 'none';
            }
          }
          
          // Trigger auto-save
          triggerAutoSave();
        });
      });
      
      // Add change handlers for checkboxes with auto-save
      document.querySelectorAll('.editable-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
          // Trigger auto-save
          triggerAutoSave();
        });
      });
      
      // Add change handlers for contenteditable fields with auto-save
      document.querySelectorAll('.editable-field[contenteditable="true"], .editable-inline[contenteditable="true"]').forEach(field => {
        field.addEventListener('input', () => {
          triggerAutoSave();
        });
        field.addEventListener('blur', () => {
          // Also trigger on blur in case user clicks away
          triggerAutoSave();
        });
      });
      
      // Add change handlers for textareas with auto-save
      document.querySelectorAll('.editable-notes, .contact-notes-quick').forEach(textarea => {
        textarea.addEventListener('input', () => {
          triggerAutoSave();
        });
        textarea.addEventListener('blur', () => {
          triggerAutoSave();
        });
      });
      
      // Add copy button handlers for email addresses
      document.querySelectorAll('.copy-email-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          const email = btn.getAttribute('data-email');
          if (email) {
            try {
              await navigator.clipboard.writeText(email);
              // Visual feedback
              const originalOpacity = btn.style.opacity;
              btn.style.opacity = '1';
              btn.style.color = '#4caf50';
              setTimeout(() => {
                btn.style.opacity = originalOpacity;
                btn.style.color = '';
              }, 500);
            } catch (err) {
              // Fallback for older browsers
              const textArea = document.createElement('textarea');
              textArea.value = email;
              textArea.style.position = 'fixed';
              textArea.style.left = '-999999px';
              document.body.appendChild(textArea);
              textArea.select();
              try {
                document.execCommand('copy');
                btn.style.opacity = '1';
                btn.style.color = '#4caf50';
                setTimeout(() => {
                  btn.style.opacity = '0.6';
                  btn.style.color = '';
                }, 500);
              } catch (fallbackErr) {
                console.error('Failed to copy email:', fallbackErr);
              }
              document.body.removeChild(textArea);
            }
          }
        });
        // Hover effect
        btn.addEventListener('mouseenter', () => {
          btn.style.opacity = '1';
        });
        btn.addEventListener('mouseleave', () => {
          if (btn.style.color !== '#4caf50') {
            btn.style.opacity = '0.6';
          }
        });
      });
      
      // Restore scroll position if refreshing, otherwise scroll to top
      setTimeout(() => {
        if (preserveScroll) {
          addressPanelContent.scrollTop = savedScrollPosition;
        } else {
          addressPanelContent.scrollTop = 0; // Start at top for new address
        }
      }, 0);
    }

    // Load sheet button handler
    btn.addEventListener("click", () => {
      // Validate sign-in first
      if (!accessToken) {
        alert('Please sign in with Google first before loading your spreadsheet.');
        return;
      }

      let url = input.value.trim();
      if (!url) {
        alert('Please enter a Google Sheets URL.');
        return;
      }

      if (url.includes("/view")) {
        url = url.replace("/view", "/edit");
      }

      currentSheetUrl = url;
      // Save to localStorage
      localStorage.setItem('savedSheetUrl', url);
      
      // Update UI
      updateSheetLinkLabel();
      updateWelcomeMessage();
      updateNavigationState();
      
      // Load the address data
      loadAddressData(url);
    });

    // Refresh button handler
    // Refresh button removed - data auto-loads after sign-in

    // Navigation System - Single Page Navigation
    function switchView(viewName) {
      // Prevent switching to non-home views if no spreadsheet is linked
      // Exception: Profile view is always accessible
      const hasSheet = currentSheetUrl || localStorage.getItem('savedSheetUrl');
      if (!hasSheet && viewName !== 'home' && viewName !== 'profile') {
        // Force back to home view
        viewName = 'home';
        currentView = 'home';
      }
      
      currentView = viewName;
      
      // Save current view to localStorage
      localStorage.setItem('currentView', viewName);
      
      // Hide all content views
      document.querySelectorAll('.content-view').forEach(view => {
        view.classList.add('hidden');
        view.classList.remove('active');
      });
      
      // Update nav items
      document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
      });
      
      // Show selected view (map view doesn't need a content overlay)
      if (viewName !== 'map') {
        const selectedView = document.getElementById(viewName + 'View');
        if (selectedView) {
          selectedView.classList.remove('hidden');
          selectedView.classList.add('active');
        }
      }
      
      // Update nav button
      const navButton = document.getElementById('nav' + viewName.charAt(0).toUpperCase() + viewName.slice(1));
      if (navButton) {
        navButton.classList.add('active');
      }
      
      // Show/hide floating panel based on view
      const floatingPanel = document.getElementById('floatingPanel');
      if (viewName === 'people' || viewName === 'map') {
        // Show floating panel for people and map views
        if (floatingPanel) floatingPanel.classList.remove('hidden');
      } else {
        // Hide floating panel for other views (including home)
        if (floatingPanel) floatingPanel.classList.add('hidden');
      }
      
      // Show/hide filter bar based on view
      const filterBar = document.getElementById('filterBar');
      const shouldShowFilters = (viewName === 'people' || viewName === 'map');
      
      // Show/hide map container based on view
      const mapContainer = document.querySelector('.map-container');
      if (viewName === 'map') {
        if (mapContainer) {
          mapContainer.classList.remove('hidden');
          mapContainer.style.display = 'block';
        }
        // Initialize map if not already done, and ensure it's properly sized
        // Start watchdog immediately when switching to map view
        startColorFilterWatchdog();
        
        if (!zoneMap) {
          initializeMap();
          loadZoneBoundary(); // Boundary may not have been loaded if map was created just now
          refreshAdditionalMapboxLayer();
          // After map is initialized, ensure color filter control exists and restore color mode
          setTimeout(() => {
            ensureColorFilterControl();
            setTimeout(() => {
              restoreColorMode();
            }, 100);
          }, 200);
        } else {
          // Map already exists - ensure color filter control is present
          ensureAdditionalMapboxLayerControl();
          ensureColorFilterControl();
          // Wait a bit for control to be added to DOM before restoring
          setTimeout(() => {
            restoreColorMode();
          }, 100);
        }
        // Wait for container to be visible, then invalidate size and update markers
        setTimeout(() => {
          if (zoneMap) {
            zoneMap.invalidateSize();
            // Ensure control still exists after invalidation
            ensureColorFilterControl();
            // Update markers after map is properly sized
            setTimeout(() => {
              if (sheetData && sheetData.addressMap) {
                updateMapMarkers();
                // Restore saved color mode if available
                restoreColorMode();
              } else {
                // Data not loaded yet - restore color mode anyway (control should be visible)
                restoreColorMode();
              }
              // Final check after everything settles - ensure control is still there
              setTimeout(() => {
                if (currentView === 'map' && zoneMap) {
                  ensureColorFilterControl();
                }
              }, 500);
            }, 100);
          }
        }, 150);
      } else {
        if (mapContainer) {
          mapContainer.classList.add('hidden');
          mapContainer.style.display = 'none';
        }
        // Stop watchdog when leaving map view
        stopColorFilterWatchdog();
      }
      if (shouldShowFilters) {
        // Show filter bar for people and map views
        if (filterBar && sheetData && sheetData.addressMap) {
          filterBar.classList.remove('hidden');
        }
        // Adjust content views to account for filter bar height
        // Use a small delay to ensure filter bar has rendered and height is accurate
        setTimeout(() => {
          adjustContentViewsForFilterBar();
        }, 50);
      } else {
        // Hide filter bar for other views
        if (filterBar) filterBar.classList.add('hidden');
        // Adjust content views to start at top (no filter bar)
        document.querySelectorAll('.content-view').forEach(view => {
          view.style.top = '0';
        });
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
          mapContainer.style.top = '0';
        }
      }
      
      // Update welcome message visibility
      updateWelcomeMessage();
      
      // Update sign-in UI when switching views
      updateSignInUI();
      
      // Update content based on view
      if (viewName === 'home') {
        if (sheetData && sheetData.addressMap) {
          updateHomeDashboard();
          // Ensure home map is properly sized and KML is loaded when switching to home view
          setTimeout(() => {
            if (homeMap) {
              homeMap.invalidateSize();
              // Load zone boundary on home map (Mapbox or KML) if map wasn't ready before
              if (zoneKmlUrl || (isMapboxEnabled() && currentZoneName)) {
                setTimeout(() => loadHomeZoneBoundary(), 200);
              }
            }
          }, 100);
        } else {
          displayQuickActions(); // Show loading state even without data
        }
      } else if (viewName === 'meetups') {
        // Display actions page when switching to Actions view
        if (sheetData && sheetData.addressMap) {
          displayActionsPage();
        } else {
          const actionsContent = document.getElementById('actionsPageContent');
          if (actionsContent) {
            actionsContent.innerHTML = '<div class="loading">Loading actions...</div>';
          }
        }
      } else if (viewName === 'people' && sheetData && sheetData.addressMap) {
        displayAddressTable();
      } else if (viewName === 'progress' && sheetData && sheetData.addressMap) {
        updateZoneProgressCharts();
      } else if (viewName === 'tools') {
        // Initialize Contact List Creator, Zone Report Generator, and Batch Tagging when Tools view is shown
        setTimeout(() => {
          initializeContactListCreator();
          initializeZoneReportGenerator();
          initializeBatchTagging();
          setupToolModuleExpansion();
        }, 100);
      } else if (viewName === 'resources') {
        // Setup tool module expansion for Resources view
        setTimeout(() => {
          setupToolModuleExpansion();
        }, 100);
      } else if (viewName === 'profile') {
        loadProfileView();
      }
      // Map view doesn't need special content updates - it just shows the map with floating panel
    }
    
    // Set up navigation event listeners
    document.querySelectorAll('.nav-item[data-view]').forEach(item => {
      item.addEventListener('click', (e) => {
        // Use currentTarget to get the button, not the clicked child element (like span)
        const viewName = e.currentTarget.getAttribute('data-view');
        // Prevent navigation if no spreadsheet is linked (except Home, Profile)
        if (!currentSheetUrl && viewName !== 'home' && viewName !== 'profile') {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        switchView(viewName);
      });
    });
    
    // Initialize with saved view or home view (default landing page)
    const savedView = localStorage.getItem('currentView');
    // Allow restoring any view if we have a saved sheet URL, or if it's home view
    // Note: savedSheetUrl is already loaded above (line 2177), so we can check it directly
    if (savedView && (savedView === 'home' || savedSheetUrl)) {
      currentView = savedView;
      switchView(savedView);
    } else {
      currentView = 'home';
      switchView('home');
    }
    
    // Set up Open Map button

    // indexToColumnLetter moved to js/utils.js

    // Save changes to spreadsheet
    // Debounced auto-save function
    function triggerAutoSave() {
      // Clear existing timer
      if (autoSaveTimer) {
        clearTimeout(autoSaveTimer);
      }
      
      // Set new timer (1.2 seconds delay)
      autoSaveTimer = setTimeout(() => {
        saveChanges(true); // true = isAutoSave
      }, 1200);
      
      // Show "Auto-saving..." indicator in both locations (top and bottom)
      const saveStatus = document.getElementById('saveStatus');
      const saveStatusTop = document.getElementById('saveStatusTop');
      
      if (saveStatus) {
        saveStatus.textContent = 'Auto-saving...';
        saveStatus.className = 'save-status saving';
      }
      if (saveStatusTop) {
        saveStatusTop.textContent = 'Auto-saving...';
        saveStatusTop.className = 'save-status saving';
      }
    }

    async function saveChanges(isAutoSave = false) {
      if (!accessToken || !currentSheetId) {
        if (!isAutoSave) {
          alert('Please sign in to save changes.');
        }
        return;
      }

      const saveBtn = document.getElementById('saveChangesBtn');
      const saveStatus = document.getElementById('saveStatus');
      const saveStatusTop = document.getElementById('saveStatusTop');
      // Get all editable elements: Notes fields (textareas), inline fields, dropdowns, checkboxes, and Quick Contact Notes
      const editableFields = document.querySelectorAll('.editable-field[contenteditable="true"], .editable-inline[contenteditable="true"], .editable-notes, .contact-notes-quick');
      const editableDropdowns = document.querySelectorAll('.editable-dropdown');
      const editableCheckboxes = document.querySelectorAll('.editable-checkbox');
      
      if (editableFields.length === 0 && editableDropdowns.length === 0 && editableCheckboxes.length === 0) {
        return;
      }

      if (!saveBtn || !saveStatus) {
        console.warn('Save button or status element not found');
        return;
      }

      saveBtn.disabled = true;
      if (saveStatus) {
        saveStatus.textContent = isAutoSave ? 'Auto-saving...' : 'Saving...';
        saveStatus.className = 'save-status saving';
      }
      if (saveStatusTop) {
        saveStatusTop.textContent = isAutoSave ? 'Auto-saving...' : 'Saving...';
        saveStatusTop.className = 'save-status saving';
      }

      try {
        // Collect all changes
        const updates = [];
        editableFields.forEach(field => {
          // Handle textareas differently from contenteditable divs
          const newValue = field.tagName === 'TEXTAREA' ? field.value.trim() : field.textContent.trim();
          const originalValue = field.getAttribute('data-original-value') || '';
          const column = field.getAttribute('data-column');
          const isAddressLevel = field.getAttribute('data-address-level') === 'true';
          const address = field.getAttribute('data-address');
          const originalRowIndex = parseInt(field.getAttribute('data-original-row-index'));

          if (newValue !== originalValue) {
            // Find the column index - handle Contact Notes with flexible matching
            let colIndex = -1;
            if (column === 'Contact Notes' || field.classList.contains('contact-notes-quick')) {
              // For Contact Notes, use flexible search like markContact does
              colIndex = sheetData.headers.findIndex(h => 
                h.toLowerCase().includes('contact') && h.toLowerCase().includes('note')
              );
            } else {
              colIndex = sheetData.headers.indexOf(column);
            }
            if (colIndex === -1) {
              console.warn(`Column not found: ${column}`);
              return;
            }

            // Convert column index to letter (A, B, C, etc.)
            const colLetter = indexToColumnLetter(colIndex);
            
            if (isAddressLevel) {
              // Address-level: update ALL rows for this address
              const rows = sheetData.addressMap.get(address);
              if (rows) {
                rows.forEach(row => {
                  const rowIndex = row.__originalIndex;
                  if (rowIndex !== undefined && rowIndex !== -1) {
                    const rowNumber = rowIndex + 2; // +2 because +1 for header row, +1 for 1-based indexing
                    const range = `${colLetter}${rowNumber}`;
                    updates.push({
                      range: `Sheet1!${range}`,
                      values: [[newValue]]
                    });
                  }
                });
              }
            } else {
              // Person-level: update only this specific row
              if (originalRowIndex !== -1) {
                const rowNumber = originalRowIndex + 2; // +2 because +1 for header row, +1 for 1-based indexing
                const range = `${colLetter}${rowNumber}`;
                updates.push({
                  range: `Sheet1!${range}`,
                  values: [[newValue]]
                });
              }
            }
          }
        });
        
        // Handle dropdown fields
        editableDropdowns.forEach(dropdown => {
          const newValue = dropdown.value.trim();
          const originalValue = dropdown.getAttribute('data-original-value');
          const column = dropdown.getAttribute('data-column');
          const isAddressLevel = dropdown.getAttribute('data-address-level') === 'true';
          const address = dropdown.getAttribute('data-address');

          if (newValue !== originalValue) {
            // Find the column index
            const colIndex = sheetData.headers.indexOf(column);
            if (colIndex === -1) return;

            // Convert column index to letter
            const colLetter = indexToColumnLetter(colIndex);
            
            if (isAddressLevel) {
              // Address-level: update ALL rows for this address
              const rows = sheetData.addressMap.get(address);
              if (rows) {
                rows.forEach(row => {
                  const rowIndex = row.__originalIndex;
                  if (rowIndex !== undefined && rowIndex !== -1) {
                    const rowNumber = rowIndex + 2;
                    const range = `${colLetter}${rowNumber}`;
                    updates.push({
                      range: `Sheet1!${range}`,
                      values: [[newValue]]
                    });
                  }
                });
              }
            }
          }
        });
        
        // Handle checkbox fields
        editableCheckboxes.forEach(checkbox => {
          const newValue = checkbox.checked ? 'TRUE' : 'FALSE';
          const originalValue = checkbox.getAttribute('data-original-value') || '';
          // Convert original value to boolean for comparison - handle TRUE/FALSE, yes/no, true/false
          const originalValueStr = (originalValue || '').trim();
          const originalValueStrLower = originalValueStr.toLowerCase();
          const originalChecked = originalValueStrLower === 'true' || originalValueStr === 'TRUE' || 
                                 originalValueStrLower === 'yes' || 
                                 (originalValueStr !== '' && originalValueStrLower !== 'false' && originalValueStr !== 'FALSE' && originalValueStrLower !== 'no');
          const column = checkbox.getAttribute('data-column');
          const isAddressLevel = checkbox.getAttribute('data-address-level') === 'true';
          const address = checkbox.getAttribute('data-address');

          if (checkbox.checked !== originalChecked) {
            // Find the column index
            const colIndex = sheetData.headers.indexOf(column);
            if (colIndex === -1) return;

            // Convert column index to letter
            const colLetter = indexToColumnLetter(colIndex);
            
            if (isAddressLevel) {
              // Address-level: update ALL rows for this address
              const rows = sheetData.addressMap.get(address);
              if (rows) {
                rows.forEach(row => {
                  const rowIndex = row.__originalIndex;
                  if (rowIndex !== undefined && rowIndex !== -1) {
                    const rowNumber = rowIndex + 2;
                    const range = `${colLetter}${rowNumber}`;
                    updates.push({
                      range: `Sheet1!${range}`,
                      values: [[newValue]]
                    });
                  }
                });
              }
            } else {
              // Person-level: update only this specific row
              const originalRowIndex = parseInt(checkbox.getAttribute('data-original-row-index'));
              if (originalRowIndex !== -1) {
                const rowNumber = originalRowIndex + 2;
                const range = `${colLetter}${rowNumber}`;
                updates.push({
                  range: `Sheet1!${range}`,
                  values: [[newValue]]
                });
              }
            }
          }
        });

        if (updates.length === 0) {
          if (saveStatus) {
            saveStatus.textContent = 'No changes to save';
            saveStatus.className = 'save-status';
          }
          if (saveBtn) {
            saveBtn.disabled = false;
          }
          return;
        }

        const response = await fetch('/api/sheets/batch-update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sheetId: currentSheetId,
            valueInputOption: 'USER_ENTERED',
            data: updates
          })
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({}));
          throw new Error(error.message || error.error || 'Failed to save');
        }

        // Update original values and in-memory data structure
        editableFields.forEach(field => {
          const value = field.tagName === 'TEXTAREA' ? field.value.trim() : field.textContent.trim();
          // Escape HTML entities for data attribute
          const escapedValue = value.replace(/"/g, '&quot;').replace(/\n/g, '&#10;');
          field.setAttribute('data-original-value', escapedValue);
          
          // Update in-memory data structure
          const column = field.getAttribute('data-column');
          const isAddressLevel = field.getAttribute('data-address-level') === 'true';
          const address = field.getAttribute('data-address');
          const originalRowIndex = parseInt(field.getAttribute('data-original-row-index'));
          
          if (column && address) {
            // Find the column index - handle Contact Notes with flexible matching
            let colIndex = -1;
            if (column === 'Contact Notes' || field.classList.contains('contact-notes-quick')) {
              colIndex = sheetData.headers.findIndex(h => 
                h.toLowerCase().includes('contact') && h.toLowerCase().includes('note')
              );
            } else {
              colIndex = sheetData.headers.indexOf(column);
            }
            
            if (colIndex !== -1) {
              const columnName = sheetData.headers[colIndex];
              if (isAddressLevel) {
                // Address-level: update ALL rows for this address
                const rows = sheetData.addressMap.get(address);
                if (rows) {
                  rows.forEach(row => {
                    row[columnName] = value;
                  });
                }
              } else {
                // Person-level: update only this specific row
                if (originalRowIndex !== -1) {
                  const rows = sheetData.addressMap.get(address);
                  if (rows) {
                    const row = rows.find(r => r.__originalIndex === originalRowIndex);
                    if (row) {
                      row[columnName] = value;
                    }
                  }
                }
              }
            }
          }
        });
        editableDropdowns.forEach(dropdown => {
          dropdown.setAttribute('data-original-value', dropdown.value.trim());
          
          // Update in-memory data structure
          const column = dropdown.getAttribute('data-column');
          const isAddressLevel = dropdown.getAttribute('data-address-level') === 'true';
          const address = dropdown.getAttribute('data-address');
          const originalRowIndex = parseInt(dropdown.getAttribute('data-original-row-index'));
          const value = dropdown.value.trim();
          
          if (column && address) {
            const colIndex = sheetData.headers.indexOf(column);
            if (colIndex !== -1) {
              const columnName = sheetData.headers[colIndex];
              if (isAddressLevel) {
                const rows = sheetData.addressMap.get(address);
                if (rows) {
                  rows.forEach(row => {
                    row[columnName] = value;
                  });
                }
              } else {
                if (originalRowIndex !== -1) {
                  const rows = sheetData.addressMap.get(address);
                  if (rows) {
                    const row = rows.find(r => r.__originalIndex === originalRowIndex);
                    if (row) {
                      row[columnName] = value;
                    }
                  }
                }
              }
            }
          }
        });
        editableCheckboxes.forEach(checkbox => {
          const value = checkbox.checked ? 'TRUE' : 'FALSE';
          checkbox.setAttribute('data-original-value', value);
          
          // Update in-memory data structure
          const column = checkbox.getAttribute('data-column');
          const isAddressLevel = checkbox.getAttribute('data-address-level') === 'true';
          const address = checkbox.getAttribute('data-address');
          const originalRowIndex = parseInt(checkbox.getAttribute('data-original-row-index'));
          const checkboxValue = checkbox.checked ? 'TRUE' : 'FALSE';
          
          if (column && address) {
            const colIndex = sheetData.headers.indexOf(column);
            if (colIndex !== -1) {
              const columnName = sheetData.headers[colIndex];
              if (isAddressLevel) {
                const rows = sheetData.addressMap.get(address);
                if (rows) {
                  rows.forEach(row => {
                    row[columnName] = checkboxValue;
                  });
                }
              } else {
                if (originalRowIndex !== -1) {
                  const rows = sheetData.addressMap.get(address);
                  if (rows) {
                    const row = rows.find(r => r.__originalIndex === originalRowIndex);
                    if (row) {
                      row[columnName] = checkboxValue;
                    }
                  }
                }
              }
            }
          }
        });

        if (saveStatus) {
          saveStatus.textContent = isAutoSave ? 'Auto-saved!' : 'Saved!';
          saveStatus.className = 'save-status saved';
          // Clear auto-save message after 2 seconds
          if (isAutoSave) {
            setTimeout(() => {
              if (saveStatus && saveStatus.textContent === 'Auto-saved!') {
                saveStatus.textContent = '';
                saveStatus.className = 'save-status';
              }
            }, 2000);
          }
        }
        if (saveStatusTop) {
          saveStatusTop.textContent = isAutoSave ? 'Auto-saved!' : 'Saved!';
          saveStatusTop.className = 'save-status saved';
          // Clear auto-save message after 2 seconds
          if (isAutoSave) {
            setTimeout(() => {
              if (saveStatusTop && saveStatusTop.textContent === 'Auto-saved!') {
                saveStatusTop.textContent = '';
                saveStatusTop.className = 'save-status';
              }
            }, 2000);
          }
        }
        
        // Update Home page statistics immediately (for both auto-save and manual save)
        // This ensures changes are reflected on the Home page without requiring a browser refresh
        updateHomeDashboard();
        
        // Refresh data after a short delay (only for manual saves to avoid too many refreshes)
        if (!isAutoSave) {
          setTimeout(() => {
            if (currentSheetUrl) {
              loadAddressData(currentSheetUrl);
            }
          }, 1000);
        }

      } catch (error) {
        console.error('Save error:', error);
        if (saveStatus) {
          saveStatus.textContent = `Error: ${error.message}`;
          saveStatus.className = 'save-status error';
        }
        if (saveStatusTop) {
          saveStatusTop.textContent = `Error: ${error.message}`;
          saveStatusTop.className = 'save-status error';
        }
        // For auto-save errors, also show a console warning (less intrusive than alert)
        if (isAutoSave) {
          console.warn('Auto-save failed:', error.message);
        } else {
          alert(`Error saving changes: ${error.message}`);
        }
      } finally {
        if (saveBtn) {
          saveBtn.disabled = false;
        }
      }
    }

    // Default marker colors (using our palette)
    const DEFAULT_MARKER_COLOR = '#347072';  // Teal - matches our accent
    const SELECTED_MARKER_COLOR = '#BC5838'; // Clay - stands out when selected
    
    // Create colored marker icon using SVG (circle style with zine shadow)
    function createColoredMarkerIcon(color, isSelected = false, smallSize = false) {
      const baseSize = smallSize ? 16 : 20;  // Slightly larger to accommodate shadow
      const size = isSelected ? baseSize * 1.25 : baseSize;
      const strokeWidth = isSelected ? 2 : 1.5;  // Thinner charcoal border
      const anchor = (size / 2) - 1;  // Offset anchor slightly to account for shadow
      
      // Zine-style circle with hard offset shadow
      const svgIcon = `
        <svg width="${size}" height="${size}" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg">
          <circle cx="12" cy="12" r="8" fill="#1F2937"/>
          <circle cx="10" cy="10" r="8" fill="${color}" stroke="#1F2937" stroke-width="${strokeWidth}"/>
        </svg>
      `;
      
      return L.divIcon({
        html: svgIcon,
        className: 'custom-colored-marker',
        iconSize: [size, size],
        iconAnchor: [anchor, anchor],
        popupAnchor: [0, -anchor]
      });
    }
    
    // Get default marker icon (teal for normal, clay for selected)
    function getDefaultMarkerIcon(isSelected = false, smallSize = false) {
      const color = isSelected ? SELECTED_MARKER_COLOR : DEFAULT_MARKER_COLOR;
      return createColoredMarkerIcon(color, isSelected, smallSize);
    }

    // Color palette
    const colorPalette = {
      'dry-sage': '#afc892',
      'dusty-mauve': '#bc455a',
      'light-caramel': '#fdba77',
      'apricot-cream': '#f6cf98',
      'sky-blue-light': '#81bdc3',
      'floral-white': '#fdf8ec',
      'soft-blush': '#f9d6d3',
      'ash-grey': '#e5e5e5'
    };

    // Get captain color mapping (assigns colors to unique captain names)
    function getCaptainColorMapping() {
      if (!sheetData || !sheetData.headers || !sheetData.data) return {};
      
      const captainAssignedCol = findColumn(sheetData.headers, 'captain assigned');
      if (!captainAssignedCol) return {};
      
      const captains = new Set();
      sheetData.data.forEach(row => {
        if (row[captainAssignedCol] !== undefined && row[captainAssignedCol] !== null) {
          const captain = String(row[captainAssignedCol]).trim();
          if (captain) captains.add(captain);
        }
      });
      
      const captainArray = Array.from(captains).sort();
      const colorKeys = ['dry-sage', 'dusty-mauve', 'light-caramel', 'apricot-cream', 'sky-blue-light', 'soft-blush', 'ash-grey'];
      const mapping = {};
      
      captainArray.forEach((captain, index) => {
        mapping[captain] = colorPalette[colorKeys[index % colorKeys.length]];
      });
      
      return mapping;
    }

    // Get rebuild status -> color mapping (sequential stages + any custom values)
    function getRebuildColorMapping() {
      const stages = getFullRebuildStatusOptions();
      const colorKeys = ['dusty-mauve', 'light-caramel', 'apricot-cream', 'sky-blue-light', 'dry-sage', 'soft-blush', 'ash-grey'];
      const mapping = {};
      stages.forEach((stage, index) => {
        mapping[stage] = colorPalette[colorKeys[index % colorKeys.length]];
      });
      return mapping;
    }

    // Get marker color based on current color mode and address data
    function getMarkerColor(address) {
      if (!currentColorMode || !sheetData) return null;
      
      if (currentColorMode === 'contact') {
        return isAddressContacted(address) ? colorPalette['sky-blue-light'] : colorPalette['dusty-mauve'];
      } else if (currentColorMode === 'damage') {
        const damage = getAddressDamage(address);
        if (!damage) return colorPalette['ash-grey'];
        const damageLower = damage.toLowerCase();
        if (damageLower.includes('total')) return colorPalette['dusty-mauve'];
        if (damageLower.includes('partial')) return colorPalette['light-caramel'];
        if (damageLower.includes('standing')) return colorPalette['sky-blue-light'];
        return colorPalette['ash-grey'];
      } else if (currentColorMode === 'rebuild') {
        const rebuild = getAddressRebuildStatus(address);
        if (!rebuild) return colorPalette['ash-grey'];
        const rebuildColorMapping = getRebuildColorMapping();
        return rebuildColorMapping[rebuild] || colorPalette['ash-grey'];
      } else if (currentColorMode === 'captain') {
        const captain = getAddressCaptainAssigned(address);
        if (!captain) return colorPalette['ash-grey'];
        const captainColorMapping = getCaptainColorMapping();
        return captainColorMapping[captain] || colorPalette['ash-grey'];
      }
      return null;
    }

    // Get marker color for home map based on home color mode
    function getHomeMapMarkerColor(address) {
      if (!homeColorMode || !sheetData) return null;
      
      if (homeColorMode === 'contact') {
        return isAddressContacted(address) ? colorPalette['sky-blue-light'] : colorPalette['dusty-mauve'];
      } else if (homeColorMode === 'damage') {
        const damage = getAddressDamage(address);
        if (!damage) return colorPalette['ash-grey'];
        const damageLower = damage.toLowerCase();
        if (damageLower.includes('total')) return colorPalette['dusty-mauve'];
        if (damageLower.includes('partial')) return colorPalette['light-caramel'];
        if (damageLower.includes('standing')) return colorPalette['sky-blue-light'];
        return colorPalette['ash-grey'];
      } else if (homeColorMode === 'rebuild') {
        const rebuild = getAddressRebuildStatus(address);
        if (!rebuild) return colorPalette['ash-grey'];
        const rebuildColorMapping = getRebuildColorMapping();
        return rebuildColorMapping[rebuild] || colorPalette['ash-grey'];
      } else if (homeColorMode === 'captain') {
        const captain = getAddressCaptainAssigned(address);
        if (!captain) return colorPalette['ash-grey'];
        const captainColorMapping = getCaptainColorMapping();
        return captainColorMapping[captain] || colorPalette['ash-grey'];
      }
      return null;
    }

    // Recolor all markers based on current color mode
    function recolorMarkers() {
      if (!addressMarkers || !zoneMap) return;
      
      addressMarkers.forEach(marker => {
        const address = marker.address;
        const isSelected = selectedAddress === address;
        
        if (currentColorMode) {
          const color = getMarkerColor(address);
          if (color) {
            marker.setIcon(createColoredMarkerIcon(color, isSelected));
          } else {
            // Fallback to default if no color determined
            marker.setIcon(getDefaultMarkerIcon(isSelected));
          }
        } else {
          // Default: teal for normal, clay for selected
          marker.setIcon(getDefaultMarkerIcon(isSelected));
        }
      });
    }

    // Show color legend
    function showColorLegend(mode) {
      // Remove existing legend if any
      if (colorLegendControl) {
        zoneMap.removeControl(colorLegendControl);
      }
      
      const ColorLegendControl = L.Control.extend({
        onAdd: function(map) {
          const container = L.DomUtil.create('div', 'color-legend-control');
          container.style.cssText = 'background: white; border-radius: 4px; box-shadow: 0 1px 5px rgba(0,0,0,0.4); padding: 10px; font-size: 0.75rem; min-width: 160px; max-width: 200px;';
          
          let html = '';
          
          if (mode === 'contact') {
            html = `
              <div style="font-weight: 600; margin-bottom: 8px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">Contact Status</div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['sky-blue-light']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Contacted</span>
              </div>
              <div style="display: flex; align-items: center;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['dusty-mauve']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Not Contacted</span>
              </div>
            `;
          } else if (mode === 'damage') {
            html = `
              <div style="font-weight: 600; margin-bottom: 8px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">Damage Status</div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['dusty-mauve']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Total Loss</span>
              </div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['light-caramel']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Partial Loss</span>
              </div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['sky-blue-light']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Standing</span>
              </div>
              <div style="display: flex; align-items: center;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['ash-grey']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Unknown</span>
              </div>
            `;
          } else if (mode === 'rebuild') {
            const rebuildColorMapping = getRebuildColorMapping();
            const stages = Object.keys(rebuildColorMapping);
            html = `
              <div style="font-weight: 600; margin-bottom: 8px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">Build Status</div>
              ${stages.map(stage => `
                <div style="display: flex; align-items: center; margin-bottom: 6px;">
                  <div style="width: 16px; height: 16px; border-radius: 50%; background: ${rebuildColorMapping[stage]}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                  <span style="font-size: 0.7rem;">${escapeHtml(stage)}</span>
                </div>
              `).join('')}
              <div style="display: flex; align-items: center;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['ash-grey']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Not set</span>
              </div>
            `;
          } else if (mode === 'captain') {
            const captainColorMapping = getCaptainColorMapping();
            const captains = Object.keys(captainColorMapping).sort();
            html = `
              <div style="font-weight: 600; margin-bottom: 8px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">Captain Assigned</div>
              ${captains.map(captain => `
                <div style="display: flex; align-items: center; margin-bottom: 6px;">
                  <div style="width: 16px; height: 16px; border-radius: 50%; background: ${captainColorMapping[captain]}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                  <span style="font-size: 0.7rem;">${escapeHtml(captain)}</span>
                </div>
              `).join('')}
              <div style="display: flex; align-items: center;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['ash-grey']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Not Assigned</span>
              </div>
            `;
          }
          
          container.innerHTML = html;
          L.DomEvent.disableClickPropagation(container);
          
          return container;
        }
      });
      
      colorLegendControl = new ColorLegendControl({ position: 'topleft' });
      colorLegendControl.addTo(zoneMap);
    }

    // Hide color legend
    function hideColorLegend() {
      if (colorLegendControl) {
        zoneMap.removeControl(colorLegendControl);
        colorLegendControl = null;
      }
    }

    // Show color legend for home map
    function showHomeColorLegend(mode) {
      // Remove existing legend if any
      if (homeColorLegendControl) {
        homeMap.removeControl(homeColorLegendControl);
      }
      
      const ColorLegendControl = L.Control.extend({
        onAdd: function(map) {
          const container = L.DomUtil.create('div', 'color-legend-control');
          container.style.cssText = 'background: white; border-radius: 4px; box-shadow: 0 1px 5px rgba(0,0,0,0.4); padding: 10px; font-size: 0.75rem; min-width: 160px; max-width: 200px;';
          
          let html = '';
          if (mode === 'contact') {
            html = `
              <div style="font-weight: 600; margin-bottom: 8px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">Contact Status</div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['sky-blue-light']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Contacted</span>
              </div>
              <div style="display: flex; align-items: center;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['dusty-mauve']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Not Contacted</span>
              </div>
            `;
          } else if (mode === 'damage') {
            html = `
              <div style="font-weight: 600; margin-bottom: 8px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">Damage Status</div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['dusty-mauve']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Total Loss</span>
              </div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['light-caramel']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Partial Loss</span>
              </div>
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['sky-blue-light']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Standing</span>
              </div>
              <div style="display: flex; align-items: center;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['ash-grey']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Unknown</span>
              </div>
            `;
          } else if (mode === 'rebuild') {
            const rebuildColorMapping = getRebuildColorMapping();
            const stages = Object.keys(rebuildColorMapping);
            html = `
              <div style="font-weight: 600; margin-bottom: 8px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">Build Status</div>
              ${stages.map(stage => `
                <div style="display: flex; align-items: center; margin-bottom: 6px;">
                  <div style="width: 16px; height: 16px; border-radius: 50%; background: ${rebuildColorMapping[stage]}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                  <span style="font-size: 0.7rem;">${escapeHtml(stage)}</span>
                </div>
              `).join('')}
              <div style="display: flex; align-items: center;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['ash-grey']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Not set</span>
              </div>
            `;
          } else if (mode === 'captain') {
            const captainColorMapping = getCaptainColorMapping();
            const captains = Object.keys(captainColorMapping).sort();
            html = `
              <div style="font-weight: 600; margin-bottom: 8px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">Captain Assigned</div>
              ${captains.map(captain => `
                <div style="display: flex; align-items: center; margin-bottom: 6px;">
                  <div style="width: 16px; height: 16px; border-radius: 50%; background: ${captainColorMapping[captain]}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                  <span style="font-size: 0.7rem;">${escapeHtml(captain)}</span>
                </div>
              `).join('')}
              <div style="display: flex; align-items: center;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${colorPalette['ash-grey']}; margin-right: 8px; border: 1px solid #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>
                <span style="font-size: 0.7rem;">Not Assigned</span>
              </div>
            `;
          }
          
          container.innerHTML = html;
          L.DomEvent.disableClickPropagation(container);
          
          return container;
        }
      });
      
      homeColorLegendControl = new ColorLegendControl({ position: 'topleft' });
      homeColorLegendControl.addTo(homeMap);
    }

    // Hide color legend for home map
    function hideHomeColorLegend() {
      if (homeColorLegendControl) {
        homeMap.removeControl(homeColorLegendControl);
        homeColorLegendControl = null;
      }
    }

    // Create color filter control for home map
    function createHomeColorFilterControl() {
      if (!homeMap) return;
      
      // Check if zone has multiple captains
      let hasMultipleCaptains = false;
      let captainAssignedCol = null;
      if (sheetData && sheetData.headers && sheetData.data && sheetData.data.length > 0) {
        const headers = sheetData.headers;
        const ncNameCol = findColumn(headers, 'nc name');
        const ncPhoneCol = findColumn(headers, 'nc phone');
        const ncEmailCol = findColumn(headers, 'nc email');
        captainAssignedCol = findColumn(headers, 'captain assigned');
        
        if (ncNameCol && captainAssignedCol) {
          const firstRow = sheetData.data[0];
          const ncName = firstRow[ncNameCol] ? (firstRow[ncNameCol] || '').trim() : '';
          const ncPhone = ncPhoneCol ? (firstRow[ncPhoneCol] || '').trim() : '';
          const ncEmail = ncEmailCol ? (firstRow[ncEmailCol] || '').trim() : '';
          const captains = parseCaptains(ncName, ncPhone, ncEmail);
          hasMultipleCaptains = captains.length > 1;
        }
      }
      
      const ColorFilterControl = L.Control.extend({
        onAdd: function(map) {
          const container = L.DomUtil.create('div', 'color-filter-control');
          container.style.cssText = 'background: white; border-radius: 4px; box-shadow: 0 1px 5px rgba(0,0,0,0.4); padding: 8px; font-size: 0.75rem; width: 120px;';
          
          // Header
          const header = L.DomUtil.create('div', 'color-filter-header', container);
          header.textContent = 'Color By:';
          header.style.cssText = 'font-weight: 600; margin-bottom: 6px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;';
          
          // Contact Status button
          const contactBtn = L.DomUtil.create('button', 'color-filter-btn', container);
          contactBtn.textContent = 'Contact Status';
          contactBtn.style.cssText = 'width: 100%; padding: 6px 8px; margin-bottom: 4px; border: 1px solid #ddd; border-radius: 3px; background: white; cursor: pointer; font-size: 0.7rem; text-align: left; transition: all 0.2s;';
          contactBtn.onmouseover = () => contactBtn.style.background = '#f5f5f5';
          contactBtn.onmouseout = () => {
            if (homeColorMode !== 'contact') contactBtn.style.background = 'white';
          };
          
          // Damage Status button
          const damageBtn = L.DomUtil.create('button', 'color-filter-btn', container);
          damageBtn.textContent = 'Damage Status';
          damageBtn.style.cssText = 'width: 100%; padding: 6px 8px; margin-bottom: 4px; border: 1px solid #ddd; border-radius: 3px; background: white; cursor: pointer; font-size: 0.7rem; text-align: left; transition: all 0.2s;';
          damageBtn.onmouseover = () => damageBtn.style.background = '#f5f5f5';
          damageBtn.onmouseout = () => {
            if (homeColorMode !== 'damage') damageBtn.style.background = 'white';
          };
          
          // Build Status button
          const rebuildBtn = L.DomUtil.create('button', 'color-filter-btn', container);
          rebuildBtn.textContent = 'Build Status';
          rebuildBtn.style.cssText = 'width: 100%; padding: 6px 8px; margin-bottom: 4px; border: 1px solid #ddd; border-radius: 3px; background: white; cursor: pointer; font-size: 0.7rem; text-align: left; transition: all 0.2s;';
          rebuildBtn.onmouseover = () => rebuildBtn.style.background = '#f5f5f5';
          rebuildBtn.onmouseout = () => {
            if (homeColorMode !== 'rebuild') rebuildBtn.style.background = 'white';
          };
          
          // Captain Assigned button (only if zone has multiple captains)
          let captainBtn = null;
          if (hasMultipleCaptains && captainAssignedCol) {
            captainBtn = L.DomUtil.create('button', 'color-filter-btn', container);
            captainBtn.textContent = 'Captain Assigned';
            captainBtn.style.cssText = 'width: 100%; padding: 6px 8px; margin-bottom: 4px; border: 1px solid #ddd; border-radius: 3px; background: white; cursor: pointer; font-size: 0.7rem; text-align: left; transition: all 0.2s;';
            captainBtn.onmouseover = () => captainBtn.style.background = '#f5f5f5';
            captainBtn.onmouseout = () => {
              if (homeColorMode !== 'captain') captainBtn.style.background = 'white';
            };
          }
          
          // Helper function to reset all buttons
          const resetButtons = () => {
            contactBtn.style.background = 'white';
            contactBtn.style.fontWeight = 'normal';
            damageBtn.style.background = 'white';
            damageBtn.style.fontWeight = 'normal';
            rebuildBtn.style.background = 'white';
            rebuildBtn.style.fontWeight = 'normal';
            if (captainBtn) {
              captainBtn.style.background = 'white';
              captainBtn.style.fontWeight = 'normal';
            }
          };
          
          // Click handlers
          contactBtn.onclick = () => {
            if (homeColorMode === 'contact') {
              homeColorMode = null;
              resetButtons();
              hideHomeColorLegend();
            } else {
              homeColorMode = 'contact';
              resetButtons();
              contactBtn.style.background = '#e8f4f8';
              contactBtn.style.fontWeight = '600';
              showHomeColorLegend('contact');
            }
            recolorHomeMapMarkers();
          };
          
          damageBtn.onclick = () => {
            if (homeColorMode === 'damage') {
              homeColorMode = null;
              resetButtons();
              hideHomeColorLegend();
            } else {
              homeColorMode = 'damage';
              resetButtons();
              damageBtn.style.background = '#e8f4f8';
              damageBtn.style.fontWeight = '600';
              showHomeColorLegend('damage');
            }
            recolorHomeMapMarkers();
          };
          
          rebuildBtn.onclick = () => {
            if (homeColorMode === 'rebuild') {
              homeColorMode = null;
              resetButtons();
              hideHomeColorLegend();
            } else {
              homeColorMode = 'rebuild';
              resetButtons();
              rebuildBtn.style.background = '#e8f4f8';
              rebuildBtn.style.fontWeight = '600';
              showHomeColorLegend('rebuild');
            }
            recolorHomeMapMarkers();
          };
          
          if (captainBtn) {
            captainBtn.onclick = () => {
              if (homeColorMode === 'captain') {
                homeColorMode = null;
                resetButtons();
                hideHomeColorLegend();
              } else {
                homeColorMode = 'captain';
                resetButtons();
                captainBtn.style.background = '#e8f4f8';
                captainBtn.style.fontWeight = '600';
                showHomeColorLegend('captain');
              }
              recolorHomeMapMarkers();
            };
          }
          
          L.DomEvent.disableClickPropagation(container);
          
          return container;
        }
      });
      
      // Remove old control if it exists
      if (homeColorFilterControl && homeMap) {
        try {
          homeMap.removeControl(homeColorFilterControl);
        } catch (e) {
          // Control might already be removed
        }
        homeColorFilterControl = null;
      }
      
      // Create and store the control instance
      homeColorFilterControl = new ColorFilterControl({ position: 'topleft' });
      homeColorFilterControl.addTo(homeMap);
    }
    
    // Restore color mode from localStorage
    function restoreColorMode() {
      if (!zoneMap) return;
      
      const savedColorMode = localStorage.getItem('currentColorMode');
      if (!savedColorMode || savedColorMode === '') {
        currentColorMode = null;
        return;
      }
      
      // Find the color filter control buttons (order: Contact, Damage, Rebuild, Captain optional)
      const controlContainer = document.querySelector('.color-filter-control');
      if (!controlContainer) return;
      
      const buttons = controlContainer.querySelectorAll('button');
      if (buttons.length < 3) return;
      
      const contactBtn = buttons[0];
      const damageBtn = buttons[1];
      const rebuildBtn = buttons[2];
      const captainBtn = buttons.length > 3 ? buttons[3] : null;
      
      // Helper function to reset all buttons
      const resetButtons = () => {
        contactBtn.style.background = 'white';
        contactBtn.style.fontWeight = 'normal';
        damageBtn.style.background = 'white';
        damageBtn.style.fontWeight = 'normal';
        rebuildBtn.style.background = 'white';
        rebuildBtn.style.fontWeight = 'normal';
        if (captainBtn) {
          captainBtn.style.background = 'white';
          captainBtn.style.fontWeight = 'normal';
        }
      };
      
      if (savedColorMode === 'contact') {
        currentColorMode = 'contact';
        resetButtons();
        contactBtn.style.background = '#e8f4f8';
        contactBtn.style.fontWeight = '600';
        showColorLegend('contact');
      } else if (savedColorMode === 'damage') {
        currentColorMode = 'damage';
        resetButtons();
        damageBtn.style.background = '#e8f4f8';
        damageBtn.style.fontWeight = '600';
        showColorLegend('damage');
      } else if (savedColorMode === 'rebuild') {
        currentColorMode = 'rebuild';
        resetButtons();
        rebuildBtn.style.background = '#e8f4f8';
        rebuildBtn.style.fontWeight = '600';
        showColorLegend('rebuild');
      } else if (savedColorMode === 'captain' && captainBtn) {
        currentColorMode = 'captain';
        resetButtons();
        captainBtn.style.background = '#e8f4f8';
        captainBtn.style.fontWeight = '600';
        showColorLegend('captain');
      }
      
      // Recolor markers after a short delay
      setTimeout(() => {
        recolorMarkers();
      }, 300);
    }

    // Ensure color filter control exists (creates if missing)
    function ensureColorFilterControl() {
      if (!zoneMap) return;
      
      // Check if zone has multiple captains (to verify control has correct buttons)
      let shouldHaveCaptainBtn = false;
      if (sheetData && sheetData.headers && sheetData.data && sheetData.data.length > 0) {
        const headers = sheetData.headers;
        const ncNameCol = findColumn(headers, 'nc name');
        const ncPhoneCol = findColumn(headers, 'nc phone');
        const ncEmailCol = findColumn(headers, 'nc email');
        const captainAssignedCol = findColumn(headers, 'captain assigned');
        
        if (ncNameCol && captainAssignedCol) {
          const firstRow = sheetData.data[0];
          const ncName = firstRow[ncNameCol] ? (firstRow[ncNameCol] || '').trim() : '';
          const ncPhone = ncPhoneCol ? (firstRow[ncPhoneCol] || '').trim() : '';
          const ncEmail = ncEmailCol ? (firstRow[ncEmailCol] || '').trim() : '';
          const captains = parseCaptains(ncName, ncPhone, ncEmail);
          shouldHaveCaptainBtn = captains.length > 1;
        }
      }
      
      // Check if control instance exists and is on the map
      if (colorFilterControl) {
        // Check if the control's DOM element still exists
        const existingControl = document.querySelector('.color-filter-control');
        if (existingControl) {
          // Control DOM exists, check if it's properly attached
          const mapContainer = zoneMap.getContainer();
          const controlContainer = existingControl.closest('.leaflet-control-container');
          
          if (controlContainer && mapContainer.contains(controlContainer)) {
            // Check if control has the right number of buttons (Contact, Damage, Rebuild, + optional Captain)
            const buttons = existingControl.querySelectorAll('button');
            const hasCaptainBtn = buttons.length > 3;
            
            // If captain button state doesn't match, recreate the control
            if (shouldHaveCaptainBtn !== hasCaptainBtn) {
              // Remove old control and recreate
              if (existingControl.parentNode) {
                existingControl.parentNode.removeChild(existingControl);
              }
              colorFilterControl = null;
            } else {
              // Control is properly attached with correct buttons, just ensure it's visible
              if (controlContainer.style.display === 'none') {
                controlContainer.style.display = '';
              }
              return; // Control exists and is properly attached
            }
          }
        }
        // Control instance exists but DOM is missing or detached - reset reference
        colorFilterControl = null;
      }
      
      // Check if control exists in DOM but we don't have a reference
      const existingControl = document.querySelector('.color-filter-control');
      if (existingControl) {
        const mapContainer = zoneMap.getContainer();
        const controlContainer = existingControl.closest('.leaflet-control-container');
        
        if (controlContainer && mapContainer.contains(controlContainer)) {
          // Control exists and is attached, we're good
          if (controlContainer.style.display === 'none') {
            controlContainer.style.display = '';
          }
          return;
        }
        // Control exists but isn't properly attached - remove it
        if (existingControl.parentNode) {
          existingControl.parentNode.removeChild(existingControl);
        }
      }
      
      // Control doesn't exist, create it
      // First verify the map container is visible and ready
      const mapDiv = document.getElementById('zoneMap');
      if (mapDiv && mapDiv.offsetParent !== null) {
        createColorFilterControl();
        // After creating, verify it was actually added and has functional buttons
        setTimeout(() => {
          const newControl = document.querySelector('.color-filter-control');
          const buttons = newControl ? newControl.querySelectorAll('button') : [];
          if (!newControl || buttons.length < 3) {
            // Control creation failed or buttons missing (need at least Contact, Damage, Rebuild), try again
            if (newControl && newControl.parentNode) {
              newControl.parentNode.removeChild(newControl);
            }
            if (colorFilterControl && zoneMap) {
              try {
                zoneMap.removeControl(colorFilterControl);
              } catch (e) {
                // Control might not be properly attached
              }
              colorFilterControl = null;
            }
            createColorFilterControl();
          }
        }, 150);
      } else {
        // Map container not ready yet, schedule retry
        setTimeout(() => {
          ensureColorFilterControl();
        }, 200);
      }
    }

    // Start watchdog to monitor color filter control
    function startColorFilterWatchdog() {
      // Clear existing watchdog if any
      if (colorFilterWatchdog) {
        clearInterval(colorFilterWatchdog);
        colorFilterWatchdog = null;
      }
      
      // Only run watchdog when on map view
      colorFilterWatchdog = setInterval(() => {
        if (currentView === 'map' && zoneMap) {
          const control = document.querySelector('.color-filter-control');
          if (!control) {
            // Control is missing, recreate it
            ensureColorFilterControl();
            // Restore color mode after recreating
            setTimeout(() => {
              restoreColorMode();
            }, 100);
          }
        } else {
          // Not on map view, stop watchdog
          if (colorFilterWatchdog) {
            clearInterval(colorFilterWatchdog);
            colorFilterWatchdog = null;
          }
        }
      }, 1000); // Check every second
    }

    // Stop watchdog
    function stopColorFilterWatchdog() {
      if (colorFilterWatchdog) {
        clearInterval(colorFilterWatchdog);
        colorFilterWatchdog = null;
      }
    }

    // Create color filter control
    function createColorFilterControl() {
      // Check if zone has multiple captains
      let hasMultipleCaptains = false;
      let captainAssignedCol = null;
      if (sheetData && sheetData.headers && sheetData.data && sheetData.data.length > 0) {
        const headers = sheetData.headers;
        const ncNameCol = findColumn(headers, 'nc name');
        const ncPhoneCol = findColumn(headers, 'nc phone');
        const ncEmailCol = findColumn(headers, 'nc email');
        captainAssignedCol = findColumn(headers, 'captain assigned');
        
        if (ncNameCol && captainAssignedCol) {
          const firstRow = sheetData.data[0];
          const ncName = firstRow[ncNameCol] ? (firstRow[ncNameCol] || '').trim() : '';
          const ncPhone = ncPhoneCol ? (firstRow[ncPhoneCol] || '').trim() : '';
          const ncEmail = ncEmailCol ? (firstRow[ncEmailCol] || '').trim() : '';
          const captains = parseCaptains(ncName, ncPhone, ncEmail);
          hasMultipleCaptains = captains.length > 1;
        }
      }
      
      const ColorFilterControl = L.Control.extend({
        onAdd: function(map) {
          const container = L.DomUtil.create('div', 'color-filter-control');
          container.style.cssText = 'background: white; border-radius: 4px; box-shadow: 0 1px 5px rgba(0,0,0,0.4); padding: 8px; font-size: 0.75rem; width: 120px;';
          
          // Header
          const header = L.DomUtil.create('div', 'color-filter-header', container);
          header.textContent = 'Color By:';
          header.style.cssText = 'font-weight: 600; margin-bottom: 6px; color: #283618; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;';
          
          // Contact Status button
          const contactBtn = L.DomUtil.create('button', 'color-filter-btn', container);
          contactBtn.textContent = 'Contact Status';
          contactBtn.style.cssText = 'width: 100%; padding: 6px 8px; margin-bottom: 4px; border: 1px solid #ddd; border-radius: 3px; background: white; cursor: pointer; font-size: 0.7rem; text-align: left; transition: all 0.2s;';
          contactBtn.onmouseover = () => contactBtn.style.background = '#f5f5f5';
          contactBtn.onmouseout = () => {
            if (currentColorMode !== 'contact') contactBtn.style.background = 'white';
          };
          
          // Damage Status button
          const damageBtn = L.DomUtil.create('button', 'color-filter-btn', container);
          damageBtn.textContent = 'Damage Status';
          damageBtn.style.cssText = 'width: 100%; padding: 6px 8px; margin-bottom: 4px; border: 1px solid #ddd; border-radius: 3px; background: white; cursor: pointer; font-size: 0.7rem; text-align: left; transition: all 0.2s;';
          damageBtn.onmouseover = () => damageBtn.style.background = '#f5f5f5';
          damageBtn.onmouseout = () => {
            if (currentColorMode !== 'damage') damageBtn.style.background = 'white';
          };
          
          // Build Status button
          const rebuildBtn = L.DomUtil.create('button', 'color-filter-btn', container);
          rebuildBtn.textContent = 'Build Status';
          rebuildBtn.style.cssText = 'width: 100%; padding: 6px 8px; margin-bottom: 4px; border: 1px solid #ddd; border-radius: 3px; background: white; cursor: pointer; font-size: 0.7rem; text-align: left; transition: all 0.2s;';
          rebuildBtn.onmouseover = () => rebuildBtn.style.background = '#f5f5f5';
          rebuildBtn.onmouseout = () => {
            if (currentColorMode !== 'rebuild') rebuildBtn.style.background = 'white';
          };
          
          // Captain Assigned button (only if zone has multiple captains)
          let captainBtn = null;
          if (hasMultipleCaptains && captainAssignedCol) {
            captainBtn = L.DomUtil.create('button', 'color-filter-btn', container);
            captainBtn.textContent = 'Captain Assigned';
            captainBtn.style.cssText = 'width: 100%; padding: 6px 8px; margin-bottom: 4px; border: 1px solid #ddd; border-radius: 3px; background: white; cursor: pointer; font-size: 0.7rem; text-align: left; transition: all 0.2s;';
            captainBtn.onmouseover = () => captainBtn.style.background = '#f5f5f5';
            captainBtn.onmouseout = () => {
              if (currentColorMode !== 'captain') captainBtn.style.background = 'white';
            };
          }
          
          // Helper function to reset all buttons
          const resetButtons = () => {
            contactBtn.style.background = 'white';
            contactBtn.style.fontWeight = 'normal';
            damageBtn.style.background = 'white';
            damageBtn.style.fontWeight = 'normal';
            rebuildBtn.style.background = 'white';
            rebuildBtn.style.fontWeight = 'normal';
            if (captainBtn) {
              captainBtn.style.background = 'white';
              captainBtn.style.fontWeight = 'normal';
            }
          };
          
          // Click handlers
          contactBtn.onclick = () => {
            if (currentColorMode === 'contact') {
              currentColorMode = null;
              resetButtons();
              hideColorLegend();
              localStorage.setItem('currentColorMode', '');
            } else {
              currentColorMode = 'contact';
              resetButtons();
              contactBtn.style.background = '#e8f4f8';
              contactBtn.style.fontWeight = '600';
              showColorLegend('contact');
              localStorage.setItem('currentColorMode', 'contact');
            }
            recolorMarkers();
          };
          
          damageBtn.onclick = () => {
            if (currentColorMode === 'damage') {
              currentColorMode = null;
              resetButtons();
              hideColorLegend();
              localStorage.setItem('currentColorMode', '');
            } else {
              currentColorMode = 'damage';
              resetButtons();
              damageBtn.style.background = '#e8f4f8';
              damageBtn.style.fontWeight = '600';
              showColorLegend('damage');
              localStorage.setItem('currentColorMode', 'damage');
            }
            recolorMarkers();
          };
          
          rebuildBtn.onclick = () => {
            if (currentColorMode === 'rebuild') {
              currentColorMode = null;
              resetButtons();
              hideColorLegend();
              localStorage.setItem('currentColorMode', '');
            } else {
              currentColorMode = 'rebuild';
              resetButtons();
              rebuildBtn.style.background = '#e8f4f8';
              rebuildBtn.style.fontWeight = '600';
              showColorLegend('rebuild');
              localStorage.setItem('currentColorMode', 'rebuild');
            }
            recolorMarkers();
          };
          
          if (captainBtn) {
            captainBtn.onclick = () => {
              if (currentColorMode === 'captain') {
                currentColorMode = null;
                resetButtons();
                hideColorLegend();
                localStorage.setItem('currentColorMode', '');
              } else {
                currentColorMode = 'captain';
                resetButtons();
                captainBtn.style.background = '#e8f4f8';
                captainBtn.style.fontWeight = '600';
                showColorLegend('captain');
                localStorage.setItem('currentColorMode', 'captain');
              }
              recolorMarkers();
            };
          }
          
          // Don't restore color mode here - let restoreColorMode() handle it after control is fully added
          // This ensures buttons are fully ready and attached before trying to restore state
          
          L.DomEvent.disableClickPropagation(container);
          
          return container;
        }
      });
      
      // Remove old control if it exists
      if (colorFilterControl && zoneMap) {
        try {
          zoneMap.removeControl(colorFilterControl);
        } catch (e) {
          // Control might already be removed
        }
        colorFilterControl = null;
      }
      
      // Create and store the control instance
      colorFilterControl = new ColorFilterControl({ position: 'topleft' });
      colorFilterControl.addTo(zoneMap);
      
      // After control is added, restore color mode (buttons will be ready)
      setTimeout(() => {
        restoreColorMode();
      }, 100);
    }

    // Minimum zoom for Map tab - match Home page minimap (16) so we're never more zoomed out
    const ZONE_MAP_MIN_ZOOM = 16;
    function clampZoneMapZoom() {
      if (zoneMap && zoneMap.getZoom() < ZONE_MAP_MIN_ZOOM) zoneMap.setZoom(ZONE_MAP_MIN_ZOOM);
    }

    // Initialize Leaflet map
    function initializeMap() {
      const mapDiv = document.getElementById('zoneMap');
      if (!mapDiv) {
        console.error('Map div not found');
        return;
      }
      
      if (!zoneMap) {
        try {
          // Default center (Altadena, CA - adjust as needed)
          zoneMap = L.map('zoneMap', { attributionControl: false, maxZoom: 22 }).setView([34.19, -118.15], 16);
          
          // Add CartoDB Voyager tiles (warm, colorful with labels)
          currentTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
            attribution: '¬© OpenStreetMap contributors, ¬© CARTO',
            maxZoom: 22,
            subdomains: 'abcd'
          }).addTo(zoneMap);
          
          // Add expandable Layers control (Satellite + Zones toggle)
          ensureAdditionalMapboxLayerControl();
          
          // Don't create color filter control here - it will be created via ensureColorFilterControl()
          // after the map container is visible and ready
          
          // Invalidate size to ensure map renders correctly in full screen
          // Use a longer delay and check if container is visible
          setTimeout(() => {
            if (zoneMap) {
              const mapDiv = document.getElementById('zoneMap');
              if (mapDiv && mapDiv.offsetParent !== null) {
                zoneMap.invalidateSize();
                ensureAdditionalMapboxLayerControl();
                // Now that map is ready and visible, ensure color filter control exists
                if (currentView === 'map') {
                  ensureColorFilterControl();
                  // Restore color mode after a short delay to ensure control is fully ready
                  setTimeout(() => {
                    restoreColorMode();
                  }, 200);
                }
              }
            }
          }, 500); // Increased delay to ensure map is fully ready
        } catch (error) {
          console.error('Error initializing map:', error);
        }
      } else {
        // If map already exists, invalidate size in case container changed
        // Only invalidate if container is visible
        setTimeout(() => {
          if (zoneMap) {
            const mapDiv = document.getElementById('zoneMap');
            if (mapDiv && mapDiv.offsetParent !== null) {
              zoneMap.invalidateSize();
              ensureAdditionalMapboxLayerControl();
              // Ensure color filter control exists when map already exists
              if (currentView === 'map') {
                ensureColorFilterControl();
                // Restore color mode after a short delay
                setTimeout(() => {
                  restoreColorMode();
                }, 200);
              }
            }
          }
        }, 300);
      }
      
      // Load KML if URL is provided (commented out for now)
      // const kmlUrlInput = document.getElementById("kmlUrlInput");
      // const kmlUrl = kmlUrlInput && kmlUrlInput.value ? kmlUrlInput.value.trim() : '';
      // if (kmlUrl) {
      //   loadKMLBoundary(kmlUrl);
      // }
    }

    // Initialize homepage map
    function initializeHomeMap() {
      const mapDiv = document.getElementById('homeMap');
      if (!mapDiv) {
        return;
      }
      
      if (!homeMap) {
        try {
          // Default center (Altadena, CA - adjust as needed)
          homeMap = L.map('homeMap', { attributionControl: false, maxZoom: 22 }).setView([34.19, -118.15], 15);
          
          // Add CartoDB Voyager tiles (warm, colorful with labels)
          homeTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
            attribution: '¬© OpenStreetMap contributors, ¬© CARTO',
            maxZoom: 22,
            subdomains: 'abcd'
          }).addTo(homeMap);
          
          // Create satellite toggle control for home map
          const HomeSatelliteToggleControl = L.Control.extend({
            onAdd: function(map) {
              const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
              const button = L.DomUtil.create('a', 'satellite-toggle-btn', container);
              button.href = '#';
              button.title = 'Switch to satellite view';
              button.innerHTML = 'üõ∞Ô∏è';
              button.style.cssText = 'width: 30px; height: 30px; line-height: 30px; text-align: center; text-decoration: none; display: block; font-size: 18px;';
              
              L.DomEvent.disableClickPropagation(button);
              L.DomEvent.on(button, 'click', L.DomEvent.stop);
              L.DomEvent.on(button, 'click', () => {
                if (!homeMap) return;
                
                // Remove current tile layer
                if (homeTileLayer) {
                  homeMap.removeLayer(homeTileLayer);
                }
                
                // Toggle between street and satellite
                if (isHomeSatelliteMode) {
                  // Switch to street map (CartoDB Voyager)
                  homeTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                    attribution: '¬© OpenStreetMap contributors, ¬© CARTO',
                    maxZoom: 22,
                    subdomains: 'abcd'
                  }).addTo(homeMap);
                  button.innerHTML = 'üõ∞Ô∏è';
                  button.title = 'Switch to satellite view';
                  isHomeSatelliteMode = false;
                } else {
                  // Switch to satellite - using Google Satellite for more recent imagery
                  homeTileLayer = L.tileLayer('https://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                    subdomains: ['0', '1', '2', '3'],
                    attribution: '¬© Google',
                    maxZoom: 22
                  }).addTo(homeMap);
                  button.innerHTML = 'üó∫Ô∏è';
                  button.title = 'Switch to street map';
                  isHomeSatelliteMode = true;
                }
              });
              
              return container;
            }
          });
          
          // Add satellite toggle control next to zoom controls
          new HomeSatelliteToggleControl({ position: 'topleft' }).addTo(homeMap);
          
          // Invalidate size to ensure map renders correctly
          setTimeout(() => {
            if (homeMap) {
              homeMap.invalidateSize();
            }
          }, 100);
        } catch (error) {
          console.error('Error initializing home map:', error);
        }
      } else {
        // If map already exists, invalidate size in case container changed
        setTimeout(() => {
          if (homeMap) {
            homeMap.invalidateSize();
          }
        }, 100);
      }
      
      // Update markers on home map
      updateHomeMapMarkers();
      
      // Create color filter control for home map
      createHomeColorFilterControl();
      
      // Load zone boundary on home map (Mapbox or KML) with delay to ensure map is ready
      if (zoneKmlUrl || (isMapboxEnabled() && currentZoneName)) {
        setTimeout(() => loadHomeZoneBoundary(), 300);
      }
    }

    // Update homepage map markers
    function updateHomeMapMarkers() {
      if (!sheetData || !sheetData.addressMap || !homeMap) {
        return;
      }
      
      // Clear existing markers
      homeMapMarkers.forEach(marker => homeMap.removeLayer(marker));
      homeMapMarkers = [];
      
      const headers = sheetData.headers;
      const addressMap = sheetData.addressMap;
      
      // Find lat/lon columns
      const latCol = headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lat') || lower === 'latitude';
      });
      const lonCol = headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lon') || lower.includes('lng') || lower === 'longitude';
      });
      
      if (!latCol || !lonCol) {
        return;
      }
      
      // Get all addresses
      const addresses = Array.from(addressMap.keys());
      const bounds = [];
      
      addresses.forEach(address => {
        const rows = addressMap.get(address);
        if (!rows || rows.length === 0) return;
        
        const row = rows[0];
        const latVal = row[latCol];
        const lonVal = row[lonCol];
        
        if (latVal && lonVal) {
          const lat = parseFloat(latVal);
          const lon = parseFloat(lonVal);
          
          if (!isNaN(lat) && !isNaN(lon)) {
            addHomeMapMarker(address, lat, lon, rows);
            bounds.push([lat, lon]);
          }
        }
      });
      
      // Fit bounds to show all markers
      if (bounds.length > 0 && homeMap) {
        homeMap.fitBounds(bounds, { padding: [20, 20], maxZoom: 22 });
      }
    }

    // Add marker to homepage map
    function addHomeMapMarker(address, lat, lng, rows) {
      if (!homeMap) return;
      
      let icon;
      if (homeColorMode) {
        const color = getHomeMapMarkerColor(address);
        if (color) {
          icon = createColoredMarkerIcon(color, false, true);  // smallSize = true for home map
        } else {
          // Fallback to default teal
          icon = getDefaultMarkerIcon(false, true);
        }
      } else {
        // Default teal marker
        icon = getDefaultMarkerIcon(false, true);
      }
      
      const marker = L.marker([lat, lng], { icon }).addTo(homeMap);
      
      // Build popup content (same as main map)
      let popupContent = `<strong>${address}</strong>`;
      
      // Get resident names and ages
      const nameCol = findColumn(sheetData.headers, 'resident name') || findColumn(sheetData.headers, 'name');
      const ageCol = sheetData.headers.find(h => h.toLowerCase() === 'age');
      const residents = [];
      rows.forEach(row => {
        if (nameCol && row[nameCol] && row[nameCol].trim()) {
          let residentLine = row[nameCol].trim();
          // Add age if available
          if (ageCol && row[ageCol] && row[ageCol].toString().trim()) {
            residentLine += ', ' + row[ageCol].toString().trim();
          }
          residents.push(residentLine);
        }
      });
      if (residents.length > 0) {
        popupContent += '<br>' + residents.join('<br>');
      }
      
      // Get damage, intent to rebuild, real estate status
      const firstRow = rows[0];
      const damageCol = findColumn(sheetData.headers, 'damage');
      const addressPlanCol = findColumn(sheetData.headers, ['address', 'plan'], ['note']);
      const info = [];
      if (damageCol && firstRow[damageCol] && firstRow[damageCol].trim()) {
        info.push(firstRow[damageCol].trim());
      }
      if (addressPlanCol && firstRow[addressPlanCol] && firstRow[addressPlanCol].trim()) {
        info.push(firstRow[addressPlanCol].trim());
      }
      if (info.length > 0) {
        popupContent += '<br><small>' + info.join(' ‚Ä¢ ') + '</small>';
      }
      
      // Add popup with address, residents, and info
      marker.bindPopup(popupContent);
      
      // Click handler to show address details (same as main map)
      marker.on('click', () => {
        displayAddressDetails(address);
      });
      
      marker.address = address;
      
      homeMapMarkers.push(marker);
    }

    // Recolor all home map markers based on home color mode
    function recolorHomeMapMarkers() {
      if (!homeMapMarkers || !homeMap) return;
      
      homeMapMarkers.forEach(marker => {
        const address = marker.address;
        
        if (homeColorMode) {
          const color = getHomeMapMarkerColor(address);
          if (color) {
            marker.setIcon(createColoredMarkerIcon(color, false, true));  // smallSize = true for home map
          } else {
            // Fallback to default teal
            marker.setIcon(getDefaultMarkerIcon(false, true));
          }
        } else {
          // Default teal marker
          marker.setIcon(getDefaultMarkerIcon(false, true));
        }
      });
    }

    // Load KML boundary for homepage
    async function loadHomeKMLBoundary(kmlUrl) {
      if (!kmlUrl || !kmlUrl.trim()) {
        return;
      }
      
      if (!homeMap) {
        // Retry after a delay if map isn't ready
        setTimeout(() => {
          if (homeMap && kmlUrl) {
            loadHomeKMLBoundary(kmlUrl);
          }
        }, 500);
        return;
      }
      
      // Prevent duplicate parallel loads that cause transparency inconsistency
      if (homeKmlLoading) {
        return;
      }
      homeKmlLoading = true;
      
      try {
        // Remove existing KML layer
        if (homeKmlLayer) {
          homeMap.removeLayer(homeKmlLayer);
          homeKmlLayer = null;
        }
        
        // Clean the URL - remove any quotes or extra whitespace
        const cleanUrl = kmlUrl.replace(/^["']|["']$/g, '').trim();
        
        // Convert Google Drive URL if needed
        const directUrl = convertGoogleDriveUrl(cleanUrl);
        
        // Fetch KML file with CORS proxy fallback and timeout handling (same as main map)
        let kmlText;
        try {
          // Try direct fetch first with timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
          
          try {
            const response = await fetch(directUrl, { signal: controller.signal });
            clearTimeout(timeoutId);
            
            if (!response.ok) {
              throw new Error(`Direct fetch failed: ${response.status}`);
            }
            kmlText = await response.text();
            if (isHtmlResponse(kmlText)) {
              throw new Error('Google Drive returned HTML instead of KML (virus-scan page)');
            }
          } catch (fetchError) {
            clearTimeout(timeoutId);
            throw fetchError; // Re-throw to be caught by outer catch
          }
        } catch (error) {
          // If direct fetch fails (CORS, timeout, or HTML response), try multiple proxy services
          
          const proxyServices = [
            `https://api.allorigins.win/raw?url=${encodeURIComponent(directUrl)}`,
            `https://corsproxy.io/?${encodeURIComponent(directUrl)}`,
            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(directUrl)}`
          ];
          
          let proxySuccess = false;
          for (const proxyUrl of proxyServices) {
            try {
              const proxyResponse = await fetch(proxyUrl);
              if (proxyResponse.ok) {
                kmlText = await proxyResponse.text();
                if (isHtmlResponse(kmlText)) continue;
                proxySuccess = true;
                break;
              }
            } catch (proxyError) {
              continue;
            }
          }
          
          if (!proxySuccess) {
            throw new Error('All proxy services failed');
          }
        }
        
        if (isHtmlResponse(kmlText)) {
          throw new Error('KML URL returned an HTML page (e.g. Google Drive virus-scan).');
        }
        
        const parser = new DOMParser();
        const kml = parser.parseFromString(kmlText, 'text/xml');
        const parseError = kml.querySelector('parsererror');
        if (parseError) {
          console.error('KML parsing error for home map:', parseError.textContent);
          throw new Error('KML parsing error');
        }
        
        if (typeof toGeoJSON !== 'undefined' && toGeoJSON.kml) {
          const geojson = toGeoJSON.kml(kml);
          homeKmlLayer = L.geoJSON(geojson, {
            style: {
              color: '#214025',
              weight: 2,
              opacity: 0.8,
              fillColor: '#214025',
              fillOpacity: 0.1
            }
          }).addTo(homeMap);
          
          if (homeKmlLayer.getBounds && homeKmlLayer.getBounds().isValid()) {
            homeMap.fitBounds(homeKmlLayer.getBounds(), { padding: [10, 10], maxZoom: 22 });
          }
        } else {
          console.error('toGeoJSON not available for home map KML loading');
        }
      } catch (error) {
        console.error('Error loading KML for home map:', error);
      } finally {
        homeKmlLoading = false; // Always reset the flag
      }
    }

    // Detect if response body is HTML (e.g. Google Drive virus-scan page) instead of KML.
    // When Drive can't virus-scan a file it returns 200 with an HTML page; we must retry via proxy.
    function isHtmlResponse(text) {
      if (!text || typeof text !== 'string') return true;
      const t = text.trim();
      if (!t.length) return true;
      const start = t.substring(0, 200).toLowerCase();
      return start.startsWith('<!') || start.startsWith('<html') || start.includes('<!doctype');
    }

    // Convert Google Drive sharing URL to direct download URL
    function convertGoogleDriveUrl(url) {
      // Extract file ID from Google Drive sharing URL
      // Format: https://drive.google.com/file/d/FILE_ID/view?usp=sharing
      // Or: https://drive.google.com/open?id=FILE_ID
      let fileId = null;
      
      // Try pattern 1: /file/d/FILE_ID/
      const match1 = url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
      if (match1 && match1[1]) {
        fileId = match1[1];
      } else {
        // Try pattern 2: ?id=FILE_ID
        const match2 = url.match(/[?&]id=([a-zA-Z0-9_-]+)/);
        if (match2 && match2[1]) {
          fileId = match2[1];
        }
      }
      
      if (fileId) {
        // Try alternative Google Drive export URL format
        // The confirm=t parameter sometimes helps bypass virus scan
        return `https://drive.google.com/uc?export=download&id=${fileId}&confirm=t`;
      }
      
      // If it's already a direct download URL or other format, return as-is
      return url;
    }

    // Fetch all features from a Mapbox dataset (with pagination; max 1000 per request)
    async function fetchMapboxDatasetFeatures(username, datasetId, accessToken) {
      const baseUrl = `https://api.mapbox.com/datasets/v1/${encodeURIComponent(username)}/${encodeURIComponent(datasetId)}/features`;
      const allFeatures = [];
      let start = null;
      do {
        const params = new URLSearchParams({ limit: '1000', access_token: accessToken });
        if (start) params.set('start', start);
        const url = `${baseUrl}?${params.toString()}`;
        const res = await fetch(url);
        if (!res.ok) {
          const err = await res.text();
          throw new Error(`Mapbox Datasets API: ${res.status} ${err || res.statusText}`);
        }
        const fc = await res.json();
        if (fc.type !== 'FeatureCollection' || !Array.isArray(fc.features)) {
          throw new Error('Mapbox API did not return a FeatureCollection');
        }
        allFeatures.push(...fc.features);
        const link = res.headers.get('Link');
        start = null;
        if (link) {
          const nextMatch = link.match(/<[^>]*[?&]start=([^>&\s]+)/);
          if (nextMatch && nextMatch[1]) start = nextMatch[1];
        }
      } while (start);
      return { type: 'FeatureCollection', features: allFeatures };
    }

    // Find the zone feature by ZoneName (or "Zone name") and return a single-feature GeoJSON FeatureCollection, or null
    function getZoneBoundaryFromMapbox(featureCollection, zoneName) {
      if (!featureCollection || !featureCollection.features || !zoneName || !zoneName.trim()) return null;
      const needle = zoneName.trim();
      const feature = featureCollection.features.find(f => {
        const p = f.properties || {};
        const name = p.ZoneName ?? p['Zone name'] ?? p.zoneName ?? '';
        return String(name).trim() === needle;
      });
      if (!feature || !feature.geometry) return null;
      return { type: 'FeatureCollection', features: [feature] };
    }

    // Parse `username.datasetId-tilesetSuffix` into { username, datasetId } for code-styled overlay loading.
    function parseMapboxTilesetId(tilesetId) {
      if (!tilesetId || typeof tilesetId !== 'string') return null;
      const clean = tilesetId.trim();
      if (!clean) return null;
      const dotIndex = clean.indexOf('.');
      if (dotIndex <= 0 || dotIndex >= clean.length - 1) return null;
      const username = clean.slice(0, dotIndex).trim();
      const layerPart = clean.slice(dotIndex + 1).trim();
      const datasetId = layerPart.split('-')[0].trim();
      if (!username || !datasetId) return null;
      return { username, datasetId };
    }

    function filterFeatureCollectionByZone(featureCollection, zoneName) {
      if (!featureCollection || !Array.isArray(featureCollection.features)) {
        return { type: 'FeatureCollection', features: [] };
      }
      if (!MAPBOX_ADDITIONAL_LAYER_CONFIG.filterToCurrentZone) return featureCollection;
      const needle = (zoneName || '').trim();
      if (!needle) return { type: 'FeatureCollection', features: [] };
      const features = featureCollection.features.filter((feature) => {
        const props = feature?.properties || {};
        return MAPBOX_ADDITIONAL_LAYER_CONFIG.zonePropertyKeys.some((key) => {
          const value = props[key];
          return value != null && String(value).trim() === needle;
        });
      });
      return { type: 'FeatureCollection', features };
    }

    async function fetchAdditionalMapboxFeatureCollection() {
      if (!isAdditionalMapboxLayerEnabled()) return null;
      if (cachedAdditionalMapboxFeatureCollection) return cachedAdditionalMapboxFeatureCollection;
      const parsed = parseMapboxTilesetId(MAPBOX_ADDITIONAL_LAYER_CONFIG.tilesetId);
      if (!parsed) {
        console.warn('Additional layer tilesetId is not in expected format "username.datasetId-..."');
        return null;
      }
      cachedAdditionalMapboxFeatureCollection = await fetchMapboxDatasetFeatures(
        parsed.username,
        parsed.datasetId,
        MAPBOX_CONFIG.accessToken
      );
      return cachedAdditionalMapboxFeatureCollection;
    }

    async function buildAdditionalMapboxLayer() {
      if (!zoneMap || !isAdditionalMapboxLayerEnabled()) return null;
      if (additionalMapboxLayerLoading) return additionalMapboxLayer;
      additionalMapboxLayerLoading = true;
      try {
        const featureCollection = await fetchAdditionalMapboxFeatureCollection();
        if (!featureCollection) return null;
        const filteredCollection = filterFeatureCollectionByZone(featureCollection, currentZoneName);
        if (!filteredCollection.features.length) {
          console.warn('Additional layer has no matching features to render.');
          return null;
        }
        if (additionalMapboxLayer) {
          zoneMap.removeLayer(additionalMapboxLayer);
          additionalMapboxLayer = null;
        }
        const getFirstNonEmptyProperty = (props, keys) => {
          for (const key of keys || []) {
            const value = props?.[key];
            if (value != null && String(value).trim()) return String(value).trim();
          }
          return '';
        };
        const splitSemicolonValues = (raw) => String(raw || '')
          .split(';')
          .map(v => v.trim())
          .filter(Boolean);
        const firstNameFromFullName = (rawName) => {
          const clean = String(rawName || '').trim().replace(/\s+/g, ' ');
          if (!clean) return '';
          const token = clean.split(' ')[0] || '';
          return token.replace(/[^A-Za-z'-]/g, '').trim();
        };
        const getZoneName = (props) => getFirstNonEmptyProperty(props, MAPBOX_ADDITIONAL_LAYER_CONFIG.zonePropertyKeys) || 'Zone';
        const getContactNames = (props) => getFirstNonEmptyProperty(props, MAPBOX_ADDITIONAL_LAYER_CONFIG.contactNamePropertyKeys);
        const getContactEmails = (props) => getFirstNonEmptyProperty(props, MAPBOX_ADDITIONAL_LAYER_CONFIG.contactEmailPropertyKeys);
        const getContactPhones = (props) => getFirstNonEmptyProperty(props, MAPBOX_ADDITIONAL_LAYER_CONFIG.contactPhonePropertyKeys);
        const escapeHtml = (text) => String(text || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
        const buildZoneTooltipLabel = (props) => {
          const zoneName = getZoneName(props).toUpperCase();
          const firstNames = splitSemicolonValues(getContactNames(props))
            .map(firstNameFromFullName)
            .filter(Boolean);
          const firstNamesLine = firstNames.length ? firstNames.join(', ') : 'Captain names pending';
          return `${escapeHtml(zoneName)}<br>${escapeHtml(firstNamesLine)}`;
        };
        const buildCaptainCards = (props) => {
          const names = splitSemicolonValues(getContactNames(props));
          const emails = splitSemicolonValues(getContactEmails(props));
          const phones = splitSemicolonValues(getContactPhones(props));
          const maxLen = Math.max(names.length, emails.length, phones.length);
          if (!maxLen) return '<div style="margin-top:10px; color:#4a4a4a;">Captain details pending.</div>';

          const cards = [];
          for (let i = 0; i < maxLen; i++) {
            const captainLabel = `Captain ${i + 1}`;
            const name = names[i] || '';
            const email = emails[i] || '';
            const phone = phones[i] || '';
            cards.push(`
              <div style="margin-top:10px; padding:10px 12px; border:1px solid #d7dfd2; border-radius:8px; background:#f9fbf8;">
                <div style="font-weight:700; color:#214025; margin-bottom:6px;">${captainLabel}</div>
                ${name ? `<div style="margin:2px 0;"><strong>Name:</strong> ${escapeHtml(name)}</div>` : ''}
                ${phone ? `<div style="margin:2px 0;"><strong>Phone:</strong> ${escapeHtml(phone)}</div>` : ''}
                ${email ? `<div style="margin:2px 0;"><strong>Email:</strong> ${escapeHtml(email)}</div>` : ''}
              </div>
            `);
          }
          return cards.join('');
        };
        const buildFeaturePopupHtml = (props) => {
          const zoneName = getZoneName(props).toUpperCase();
          return `
            <div style="min-width:220px; line-height:1.35;">
              <div style="font-size:15px; font-weight:700; letter-spacing:0.5px; color:#214025;">${escapeHtml(zoneName)}</div>
              ${buildCaptainCards(props)}
            </div>
          `;
        };
        const baseStyle = MAPBOX_ADDITIONAL_LAYER_CONFIG.style || {};
        const hoverStyle = MAPBOX_ADDITIONAL_LAYER_CONFIG.hoverStyle || {};
        additionalMapboxLayer = L.geoJSON(filteredCollection, {
          style: baseStyle,
          onEachFeature: (feature, layer) => {
            const props = feature?.properties || {};
            const label = buildZoneTooltipLabel(props);
            if (label && MAPBOX_ADDITIONAL_LAYER_CONFIG.tooltip?.enabled) {
              layer.bindTooltip(label, MAPBOX_ADDITIONAL_LAYER_CONFIG.tooltip);
            }
            const popupHtml = buildFeaturePopupHtml(props);
            if (popupHtml.trim()) {
              layer.bindPopup(popupHtml);
            }
            layer.on('mouseover', () => {
              layer.setStyle({ ...baseStyle, ...hoverStyle });
            });
            layer.on('mouseout', () => {
              layer.setStyle(baseStyle);
            });
          }
        });
        return additionalMapboxLayer;
      } catch (error) {
        console.warn('Failed to build additional map layer:', error);
        return null;
      } finally {
        additionalMapboxLayerLoading = false;
      }
    }

    function updateAdditionalMapboxLayerToggleButton() {
      const button = document.getElementById('additionalMapboxLayerToggleBtn');
      if (!button) return;
      const on = additionalMapboxLayerVisible;
      button.style.background = on ? '#214025' : '#ffffff';
      button.style.color = on ? '#ffffff' : '#2d3436';
      button.style.fontWeight = on ? '700' : '500';
      button.title = on
        ? `Hide ${MAPBOX_ADDITIONAL_LAYER_CONFIG.displayName}`
        : `Show ${MAPBOX_ADDITIONAL_LAYER_CONFIG.displayName}`;
    }

    function updateSatelliteLayerToggleButton() {
      const button = document.getElementById('satelliteLayerToggleBtn');
      if (!button) return;
      button.textContent = isSatelliteMode ? 'Street' : 'Satellite';
      button.title = isSatelliteMode ? 'Switch to street map' : 'Switch to satellite map';
    }

    function updateMapLayersExpandButton() {
      const panel = document.getElementById('mapLayersPanel');
      const toggleBtn = document.getElementById('mapLayersExpandBtn');
      if (!panel || !toggleBtn) return;
      const expanded = panel.style.display !== 'none';
      toggleBtn.innerHTML = expanded ? 'Layers ‚ñæ' : 'Layers ‚ñ∏';
      toggleBtn.title = expanded ? 'Collapse layers' : 'Expand layers';
    }

    function toggleSatelliteBaseLayer() {
      if (!zoneMap) return;
      if (currentTileLayer) {
        zoneMap.removeLayer(currentTileLayer);
      }
      if (isSatelliteMode) {
        currentTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
          attribution: '¬© OpenStreetMap contributors, ¬© CARTO',
          maxZoom: 22,
          subdomains: 'abcd'
        }).addTo(zoneMap);
        isSatelliteMode = false;
      } else {
        currentTileLayer = L.tileLayer('https://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
          subdomains: ['0', '1', '2', '3'],
          attribution: '¬© Google',
          maxZoom: 22
        }).addTo(zoneMap);
        isSatelliteMode = true;
      }
      updateSatelliteLayerToggleButton();
    }

    function updateAdditionalMapboxLabelVisibility() {
      if (!zoneMap) return;
      const minZoom = MAPBOX_ADDITIONAL_LAYER_CONFIG.labelMinZoom || 0;
      const shouldShowLabels = additionalMapboxLayerVisible && zoneMap.getZoom() >= minZoom;
      const mapContainer = zoneMap.getContainer();
      if (!mapContainer) return;
      mapContainer.classList.toggle('show-nearby-zone-labels', shouldShowLabels);
    }

    async function setAdditionalMapboxLayerVisible(isVisible) {
      if (!zoneMap || !isAdditionalMapboxLayerEnabled()) return;
      additionalMapboxLayerVisible = !!isVisible;
      if (!additionalMapboxLayerVisible) {
        if (additionalMapboxZoomHandler) {
          zoneMap.off('zoomend', additionalMapboxZoomHandler);
          additionalMapboxZoomHandler = null;
        }
        if (additionalMapboxLayer && zoneMap.hasLayer(additionalMapboxLayer)) {
          zoneMap.removeLayer(additionalMapboxLayer);
        }
        updateAdditionalMapboxLabelVisibility();
        updateAdditionalMapboxLayerToggleButton();
        return;
      }
      if (!additionalMapboxZoomHandler) {
        additionalMapboxZoomHandler = () => updateAdditionalMapboxLabelVisibility();
        zoneMap.on('zoomend', additionalMapboxZoomHandler);
      }
      const layer = await buildAdditionalMapboxLayer();
      if (layer && !zoneMap.hasLayer(layer)) {
        layer.addTo(zoneMap);
      }
      updateAdditionalMapboxLabelVisibility();
      updateAdditionalMapboxLayerToggleButton();
    }

    async function refreshAdditionalMapboxLayer() {
      if (!MAPBOX_ADDITIONAL_LAYER_CONFIG.filterToCurrentZone) return;
      if (!additionalMapboxLayerVisible) return;
      await setAdditionalMapboxLayerVisible(true);
    }

    function ensureAdditionalMapboxLayerControl() {
      if (!zoneMap) return;
      if (additionalMapboxLayerControl) return;
      const AdditionalMapboxLayerToggleControl = L.Control.extend({
        onAdd: function() {
          const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control map-layers-control');
          const expandBtn = L.DomUtil.create('a', 'map-layers-expand-btn', container);
          expandBtn.id = 'mapLayersExpandBtn';
          expandBtn.href = '#';
          expandBtn.style.cssText = 'min-width: 66px; height: 30px; line-height: 30px; text-align: center; text-decoration: none; display: block; padding: 0 8px; font-size: 12px; font-weight: 700;';
          expandBtn.innerHTML = 'Layers ‚ñ∏';

          const panel = L.DomUtil.create('div', 'map-layers-panel', container);
          panel.id = 'mapLayersPanel';
          panel.style.display = 'none';

          const satelliteBtn = L.DomUtil.create('a', 'map-layer-item-btn satellite-layer-toggle-btn', panel);
          satelliteBtn.id = 'satelliteLayerToggleBtn';
          satelliteBtn.href = '#';
          satelliteBtn.style.cssText = 'min-width: 66px; height: 30px; line-height: 30px; text-align: center; text-decoration: none; display: block; padding: 0 8px; font-size: 12px;';

          const zonesBtn = L.DomUtil.create('a', 'map-layer-item-btn additional-mapbox-layer-toggle-btn', panel);
          zonesBtn.id = 'additionalMapboxLayerToggleBtn';
          zonesBtn.href = '#';
          zonesBtn.innerHTML = MAPBOX_ADDITIONAL_LAYER_CONFIG.displayName;
          zonesBtn.style.cssText = 'min-width: 66px; height: 30px; line-height: 30px; text-align: center; text-decoration: none; display: block; padding: 0 8px; font-size: 12px;';

          L.DomEvent.disableClickPropagation(container);
          L.DomEvent.on(expandBtn, 'click', L.DomEvent.stop);
          L.DomEvent.on(expandBtn, 'click', () => {
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            updateMapLayersExpandButton();
          });

          L.DomEvent.on(satelliteBtn, 'click', L.DomEvent.stop);
          L.DomEvent.on(satelliteBtn, 'click', () => {
            toggleSatelliteBaseLayer();
          });

          L.DomEvent.on(zonesBtn, 'click', L.DomEvent.stop);
          L.DomEvent.on(zonesBtn, 'click', async () => {
            await setAdditionalMapboxLayerVisible(!additionalMapboxLayerVisible);
          });

          updateMapLayersExpandButton();
          updateSatelliteLayerToggleButton();
          updateAdditionalMapboxLayerToggleButton();
          return container;
        }
      });
      additionalMapboxLayerControl = new AdditionalMapboxLayerToggleControl({ position: 'topleft' });
      additionalMapboxLayerControl.addTo(zoneMap);
      if (MAPBOX_ADDITIONAL_LAYER_CONFIG.defaultVisible && isAdditionalMapboxLayerEnabled()) {
        setAdditionalMapboxLayerVisible(true);
      }
    }

    const ZONE_BOUNDARY_STYLE = {
      color: '#214025',
      weight: 3,
      opacity: 0.8,
      fillColor: '#214025',
      fillOpacity: 0.1
    };
    const HOME_BOUNDARY_STYLE = {
      color: '#214025',
      weight: 2,
      opacity: 0.8,
      fillColor: '#214025',
      fillOpacity: 0.1
    };

    // Load zone boundary from Mapbox (main zone map). Returns true if a layer was added.
    async function loadMapboxBoundary(zoneName) {
      if (!zoneMap || !zoneName || !zoneName.trim()) return false;
      try {
        const fc = await fetchMapboxDatasetFeatures(MAPBOX_CONFIG.username, MAPBOX_CONFIG.datasetId, MAPBOX_CONFIG.accessToken);
        const zoneFc = getZoneBoundaryFromMapbox(fc, zoneName);
        if (!zoneFc || zoneFc.features.length === 0) return false;
        if (kmlLayer) {
          zoneMap.removeLayer(kmlLayer);
          kmlLayer = null;
        }
        kmlLayer = L.geoJSON(zoneFc, { style: ZONE_BOUNDARY_STYLE }).addTo(zoneMap);
        if (kmlLayer.getBounds && kmlLayer.getBounds().isValid()) {
          zoneMap.fitBounds(kmlLayer.getBounds(), { padding: [20, 20], maxZoom: 17 });
          setTimeout(clampZoneMapZoom, 350);
        }
        return true;
      } catch (e) {
        console.warn('Mapbox boundary load failed:', e);
        return false;
      }
    }

    // Load zone boundary from Mapbox (home map). Returns true if a layer was added.
    async function loadMapboxBoundaryForHome(zoneName) {
      if (!homeMap || !zoneName || !zoneName.trim()) return false;
      if (homeKmlLoading) return false;
      homeKmlLoading = true;
      try {
        const fc = await fetchMapboxDatasetFeatures(MAPBOX_CONFIG.username, MAPBOX_CONFIG.datasetId, MAPBOX_CONFIG.accessToken);
        const zoneFc = getZoneBoundaryFromMapbox(fc, zoneName);
        if (!zoneFc || zoneFc.features.length === 0) return false;
        if (homeKmlLayer) {
          homeMap.removeLayer(homeKmlLayer);
          homeKmlLayer = null;
        }
        homeKmlLayer = L.geoJSON(zoneFc, { style: HOME_BOUNDARY_STYLE }).addTo(homeMap);
        if (homeKmlLayer.getBounds && homeKmlLayer.getBounds().isValid()) {
          homeMap.fitBounds(homeKmlLayer.getBounds(), { padding: [10, 10], maxZoom: 22 });
        }
        return true;
      } catch (e) {
        console.warn('Mapbox boundary load failed (home):', e);
        return false;
      } finally {
        homeKmlLoading = false;
      }
    }

    // Load zone boundary: try Mapbox first (if configured and zone name set), then KML URL fallback.
    async function loadZoneBoundary() {
      if (!zoneMap) return;
      if (isMapboxEnabled() && currentZoneName && currentZoneName.trim()) {
        const ok = await loadMapboxBoundary(currentZoneName.trim());
        if (ok) return;
      }
      if (zoneKmlUrl && zoneKmlUrl.trim()) {
        await loadKMLBoundary(zoneKmlUrl);
      }
    }

    // Load zone boundary on home map: try Mapbox first, then KML fallback.
    async function loadHomeZoneBoundary() {
      if (isMapboxEnabled() && currentZoneName && currentZoneName.trim()) {
        if (homeMap) {
          const ok = await loadMapboxBoundaryForHome(currentZoneName.trim());
          if (ok) return;
        } else {
          setTimeout(() => loadHomeZoneBoundary(), 500);
          return;
        }
      }
      if (zoneKmlUrl && zoneKmlUrl.trim()) {
        await loadHomeKMLBoundary(zoneKmlUrl);
      }
    }

    // Load KML boundary
    async function loadKMLBoundary(kmlUrl) {
      if (!kmlUrl || !kmlUrl.trim()) {
        return;
      }
      
      try {
        // Remove existing KML layer
        if (kmlLayer) {
          zoneMap.removeLayer(kmlLayer);
        }
        
        // Clean the URL - remove any quotes or extra whitespace
        const cleanUrl = kmlUrl.replace(/^["']|["']$/g, '').trim();
        
        // Convert Google Drive URL if needed
        const directUrl = convertGoogleDriveUrl(cleanUrl);
        
        // Fetch KML file with CORS proxy fallback and timeout handling
        let kmlText;
        try {
          // Try direct fetch first with timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
          
          try {
            const response = await fetch(directUrl, { signal: controller.signal });
            clearTimeout(timeoutId);
            
            if (!response.ok) {
              throw new Error(`Direct fetch failed: ${response.status}`);
            }
            kmlText = await response.text();
            // Google Drive sometimes returns 200 with an HTML virus-scan page instead of the file
            if (isHtmlResponse(kmlText)) {
              throw new Error('Google Drive returned HTML instead of KML (virus-scan page)');
            }
          } catch (fetchError) {
            clearTimeout(timeoutId);
            throw fetchError; // Re-throw to be caught by outer catch
          }
        } catch (error) {
          // If direct fetch fails (CORS, timeout, or HTML response), try multiple proxy services
          
          // Try multiple proxy services with fallback
          const proxyServices = [
            `https://api.allorigins.win/raw?url=${encodeURIComponent(directUrl)}`,
            `https://corsproxy.io/?${encodeURIComponent(directUrl)}`,
            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(directUrl)}`
          ];
          
          let lastError = null;
          let success = false;
          
          for (const proxyUrl of proxyServices) {
            try {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 second timeout for proxy
              
              const response = await fetch(proxyUrl, { signal: controller.signal });
              clearTimeout(timeoutId);
              
              if (response.ok) {
                kmlText = await response.text();
                if (isHtmlResponse(kmlText)) {
                  lastError = new Error('Google Drive returned HTML instead of KML');
                  continue;
                }
                success = true;
                break; // Success, exit loop
              } else {
                lastError = new Error(`Proxy returned ${response.status}: ${response.statusText}`);
              }
            } catch (proxyError) {
              if (proxyError.name === 'AbortError') {
                lastError = new Error('Proxy request timed out');
              } else {
                lastError = proxyError;
              }
              continue; // Try next proxy
            }
          }
          
          if (!success) {
            throw new Error(`Failed to fetch KML: ${lastError ? lastError.message : 'All proxy services failed'}. The KML file may be too large, the URL may be invalid, or the file may not be publicly accessible. Try using a direct download link or a smaller KML file.`);
          }
        }
        
        if (isHtmlResponse(kmlText)) {
          throw new Error('KML URL returned an HTML page (e.g. Google Drive virus-scan). Use a direct download link or make the file publicly viewable.');
        }
        
        // Parse KML to GeoJSON
        const parser = new DOMParser();
        const kml = parser.parseFromString(kmlText, 'text/xml');
        
        // Check for parsing errors
        const parseError = kml.querySelector('parsererror');
        if (parseError) {
          throw new Error('KML parsing error: ' + parseError.textContent);
        }
        
        // Convert KML to GeoJSON (toGeoJSON is from @mapbox/togeojson)
        let geojson;
        if (typeof toGeoJSON !== 'undefined' && toGeoJSON.kml) {
          geojson = toGeoJSON.kml(kml);
        } else {
          throw new Error('toGeoJSON library not loaded');
        }
        
        // Add to map
        kmlLayer = L.geoJSON(geojson, {
          style: {
            color: '#214025',
            weight: 3,
            opacity: 0.8,
            fillColor: '#214025',
            fillOpacity: 0.1
          }
        }).addTo(zoneMap);
        
        // Fit map to boundary
        if (kmlLayer.getBounds && kmlLayer.getBounds().isValid()) {
          zoneMap.fitBounds(kmlLayer.getBounds(), { padding: [20, 20], maxZoom: 17 });
          setTimeout(clampZoneMapZoom, 350);
        }
      } catch (error) {
        console.error('Error loading KML:', error);
        alert('Error loading KML file: ' + error.message);
      }
    }

    // Highlight the selected address marker
    function highlightSelectedMarker(address) {
      if (!zoneMap || !addressMarkers) return;
      
      let selectedMarker = null;
      addressMarkers.forEach(marker => {
        if (marker.address === address) {
          selectedMarker = marker;
          // Highlight selected marker - use colored icon if color mode is active
          if (currentColorMode) {
            const color = getMarkerColor(address);
            if (color) {
              marker.setIcon(createColoredMarkerIcon(color, true));
            } else {
              marker.setIcon(getDefaultMarkerIcon(true));
            }
          } else {
            marker.setIcon(getDefaultMarkerIcon(true));
          }
        } else if (selectedAddress && marker.address !== selectedAddress) {
          // Reset other markers - use colored icon if color mode is active
          if (currentColorMode) {
            const color = getMarkerColor(marker.address);
            if (color) {
              marker.setIcon(createColoredMarkerIcon(color, false));
            } else {
              marker.setIcon(getDefaultMarkerIcon(false));
            }
          } else {
            marker.setIcon(getDefaultMarkerIcon(false));
          }
        }
      });
      
      // Don't pan or zoom - just highlight the marker
    }

    // Update map markers based on filtered addresses
    function updateMapMarkers() {
      if (!sheetData || !sheetData.addressMap) {
        return;
      }
      
      // Make sure map is initialized
      if (!zoneMap) {
        initializeMap();
        if (!zoneMap) {
          console.error('Failed to initialize map');
          return;
        }
      }
      
      // Clear existing markers
      addressMarkers.forEach(marker => zoneMap.removeLayer(marker));
      addressMarkers = [];
      
      // Get filtered addresses (same logic as displayAddressTable)
      const addresses = Array.from(sheetData.addressMap.keys());
      const contactDateCol = findColumn(sheetData.headers, ['contact', 'date']);
      const filteredAddresses = addresses.filter(address => {
        // Street filter
        if (currentStreetFilter !== 'all') {
          const street = extractStreet(address);
          if (street !== currentStreetFilter) return false;
        }
        
        // Damage filter
        if (currentDamageFilter !== 'all') {
          const damage = getAddressDamage(address);
          if (currentDamageFilter === '') {
            // Filter for "(not set)" - addresses with no damage status
            if (damage && damage.trim() !== '' && damage !== '(not set)') return false;
          } else {
            if (damage !== currentDamageFilter) return false;
          }
        }
        
        // Address Plan filter
        if (currentAddressPlanFilter !== 'all') {
          const addrPlan = getAddressPlan(address);
          if (currentAddressPlanFilter === '') {
            if (addrPlan !== null && addrPlan !== '') return false;
          } else if (addrPlan !== currentAddressPlanFilter) {
            return false;
          }
        }
        
        // Rebuild filter
        const rebuildCol = findColumn(sheetData.headers, ['build', 'status'], ['intent']);
        if (currentRebuildFilter !== 'all' && rebuildCol) {
          const rows = sheetData.addressMap.get(address);
          if (rows && rows[0]) {
            const rebuildValue = normalizeRebuildStatusLabel((rows[0][rebuildCol] || '').trim());
            if (rebuildValue !== currentRebuildFilter) return false;
          } else {
            return false;
          }
        }
        
        // Captain assigned filter
        if (currentCaptainFilter !== 'all') {
          const captainAssignedCol = findColumn(sheetData.headers, 'captain assigned');
          if (captainAssignedCol) {
            const rows = sheetData.addressMap.get(address);
            if (rows && rows[0]) {
              const captainValue = (rows[0][captainAssignedCol] || '').trim();
              if (currentCaptainFilter === '') {
                // Filter for "(not specified)" - addresses with no captain assigned
                if (captainValue && captainValue.trim() !== '') return false;
              } else {
                if (captainValue !== currentCaptainFilter) return false;
              }
            } else {
              // No rows for address - check if we're filtering for "(not specified)"
              if (currentCaptainFilter !== '') return false;
            }
          }
        }
        
        // Contact status filter
        if (contactDateCol) {
          const isContacted = isAddressContacted(address);
          if (isContacted && !showContactedAddresses) return false;
          if (!isContacted && !showUncontactedAddresses) return false;
        }
        
        return true;
      });
      
      // Check for lat/lon columns
      const latCol = sheetData.headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lat') || lower === 'latitude';
      });
      const lonCol = sheetData.headers.find(h => {
        const lower = h.toLowerCase().trim();
        return lower.includes('lon') || lower.includes('lng') || lower === 'longitude';
      });
      
      if (!latCol || !lonCol) {
        return;
      }
      
      // Add markers for filtered addresses
      const bounds = [];
      let markerCount = 0;
      filteredAddresses.forEach(address => {
        const rows = sheetData.addressMap.get(address);
        if (!rows || rows.length === 0) return;
        
        const firstRow = rows[0];
        let lat, lon;
        
        // Try to get coordinates from lat/lon columns
        const latVal = firstRow[latCol];
        const lonVal = firstRow[lonCol];
        
        if (latVal !== undefined && latVal !== null && latVal !== '' && 
            lonVal !== undefined && lonVal !== null && lonVal !== '') {
          lat = parseFloat(String(latVal).trim());
          lon = parseFloat(String(lonVal).trim());
          if (isNaN(lat) || isNaN(lon)) {
            return;
          }
          // Skip placeholder coordinates that can zoom the map way out
          if (Math.abs(lat) < 0.0001 && Math.abs(lon) < 0.0001) {
            return;
          }
        } else {
          return; // Skip if no coordinates
        }
        
        // Create marker
        try {
          // Use colored icon if color mode is active, otherwise use default
          const isSelected = selectedAddress === address;
          let icon;
          
          if (currentColorMode) {
            const color = getMarkerColor(address);
            if (color) {
              icon = createColoredMarkerIcon(color, isSelected);
            } else {
              // Fallback to default if no color determined
              icon = getDefaultMarkerIcon(isSelected);
            }
          } else {
            // Default: teal for normal, clay for selected
            icon = getDefaultMarkerIcon(isSelected);
          }
          
          const marker = L.marker([lat, lon], { icon: icon }).addTo(zoneMap);
          
          // Build popup content
          let popupContent = `<strong>${address}</strong>`;
          
          // Get resident names and ages
          const nameCol = findColumn(sheetData.headers, 'resident name') || findColumn(sheetData.headers, 'name');
          const ageCol = sheetData.headers.find(h => h.toLowerCase() === 'age');
          const residents = [];
          rows.forEach(row => {
            if (nameCol && row[nameCol] && row[nameCol].trim()) {
              let residentLine = row[nameCol].trim();
              // Add age if available
              if (ageCol && row[ageCol] && row[ageCol].toString().trim()) {
                residentLine += ', ' + row[ageCol].toString().trim();
              }
              residents.push(residentLine);
            }
          });
          if (residents.length > 0) {
            popupContent += '<br>' + residents.join('<br>');
          }
          
          // Get damage, intent to rebuild, real estate status
          const damageCol = findColumn(sheetData.headers, 'damage');
          const addressPlanCol = findColumn(sheetData.headers, ['address', 'plan'], ['note']);
          const info = [];
          if (damageCol && firstRow[damageCol] && firstRow[damageCol].trim()) {
            info.push(firstRow[damageCol].trim());
          }
          if (addressPlanCol && firstRow[addressPlanCol] && firstRow[addressPlanCol].trim()) {
            info.push(firstRow[addressPlanCol].trim());
          }
          if (info.length > 0) {
            popupContent += '<br><small>' + info.join(' ‚Ä¢ ') + '</small>';
          }
          
          // Add popup with address, residents, and info
          marker.bindPopup(popupContent);
          
          // Click handler to show address details
          marker.on('click', () => {
            displayAddressDetails(address);
          });
          
          // Store address with marker for highlighting
          marker.address = address;
          
          addressMarkers.push(marker);
          bounds.push([lat, lon]);
          markerCount++;
        } catch (error) {
          console.error(`Error creating marker for ${address}:`, error);
        }
      });
      
      if (markerCount === 0) {
        return;
      }
      
      // Fit map to show zone bounds or markers
      // Wait for map to be properly sized before fitting bounds
      setTimeout(() => {
        if (!zoneMap) return;
        const mapDiv = document.getElementById('zoneMap');
        if (!mapDiv || mapDiv.offsetParent === null) return;
        try {
          // Prefer zone boundary if available (home map loads it early)
          if (!kmlLayer && homeKmlLayer && homeKmlLayer.getBounds && homeKmlLayer.getBounds().isValid()) {
            zoneMap.fitBounds(homeKmlLayer.getBounds(), { padding: [20, 20], maxZoom: 17 });
            setTimeout(clampZoneMapZoom, 350);
            return;
          }
          // If a boundary is expected but not loaded yet, avoid fitting to outlier markers
          if (!kmlLayer && (isMapboxEnabled() || zoneKmlUrl) && currentZoneName) {
            return;
          }
          // If no boundary is available, keep a sane default zoom/center
          if (!kmlLayer && (!homeKmlLayer || !homeKmlLayer.getBounds || !homeKmlLayer.getBounds().isValid())) {
            zoneMap.setView([34.19, -118.15], 16);
            return;
          }
          // Otherwise, fit to markers when no zone boundary is present
          if (bounds.length > 0 && !kmlLayer) {
            zoneMap.fitBounds(bounds, { 
              padding: [20, 20],
              maxZoom: 17
            });
            setTimeout(clampZoneMapZoom, 350);
          }
        } catch (error) {
          console.error('Error fitting bounds:', error);
        }
      }, 200);
    }

    // Satellite toggle is now handled by Leaflet control (created in initializeMap)

    // KML URL input handler (commented out for now)
    // if (kmlUrlInput) {
    //   kmlUrlInput.addEventListener('keypress', (e) => {
    //     if (e.key === 'Enter') {
    //       if (zoneMap) {
    //         loadKMLBoundary(kmlUrlInput.value.trim());
    //       }
    //     }
    //   });
    // }

    // Update Zone Notes UI
    function updateZoneNotesUI() {
      const zoneNotesText = document.getElementById('zoneNotesText');
      
      if (zoneNotesText) {
        zoneNotesText.value = zoneNotes || '';
      } else {
        console.error('Zone Notes UI elements not found');
      }
    }

    // Tab switching functionality
    const addressesTab = document.getElementById('addressesTab');
    const zoneNotesTab = document.getElementById('zoneNotesTab');
    const zoneNotesContent = document.getElementById('zoneNotesContent');

    if (addressesTab && zoneNotesTab) {
      addressesTab.addEventListener('click', () => {
        addressesTab.classList.add('active');
        zoneNotesTab.classList.remove('active');
        if (addressPanelContent) addressPanelContent.classList.remove('hidden');
        if (zoneNotesContent) zoneNotesContent.classList.add('hidden');
      });

      zoneNotesTab.addEventListener('click', () => {
        zoneNotesTab.classList.add('active');
        addressesTab.classList.remove('active');
        if (addressPanelContent) addressPanelContent.classList.add('hidden');
        if (zoneNotesContent) zoneNotesContent.classList.remove('hidden');
      });
    }

    // Save Zone Notes to Metadata sheet
    async function saveZoneNotes() {
      if (!metadataSheetId || !accessToken) {
        alert('Please sign in to save notes.');
        return;
      }

      const zoneNotesText = document.getElementById('zoneNotesText');
      const saveStatus = document.getElementById('zoneNotesStatus');
      const saveBtn = document.getElementById('saveZoneNotesBtn');
      
      if (!zoneNotesText) return;
      
      const newNotes = zoneNotesText.value.trim();
      saveBtn.disabled = true;
      saveStatus.textContent = 'Saving...';
      saveStatus.className = 'save-status-small';

      try {
        // First, try to read existing metadata to preserve KML URL
        let kmlUrlValue = zoneKmlUrl;
        try {
          const existingMetadata = await fetchMetadata(metadataSheetId);
          if (existingMetadata && existingMetadata.kmlUrl) {
            kmlUrlValue = existingMetadata.kmlUrl;
          }
        } catch (e) {
          // If Zone Notes sheet doesn't exist, we'll create it
        }

        // Prepare the metadata rows
        const values = [
          ['Zone Notes', newNotes],
          ['KML URL', kmlUrlValue || '']
        ];

        const response = await fetch('/api/sheets/batch-update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sheetId: metadataSheetId,
            valueInputOption: 'USER_ENTERED',
            data: [{ range: 'Zone Notes!A1:B2', values: values }]
          })
        });
        if (!response.ok) {
          // If Zone Notes sheet doesn't exist, try to create it first
          // For now, just show error - user can create the sheet manually
          throw new Error('Zone Notes sheet not found. Please create a sheet named "Zone Notes" with columns A (key) and B (value).');
        }

        zoneNotes = newNotes;
        saveStatus.textContent = 'Saved!';
        saveStatus.className = 'save-status-small saved';
        
        setTimeout(() => {
          saveStatus.textContent = '';
        }, 2000);

      } catch (error) {
        console.error('Save error:', error);
        saveStatus.textContent = `Error: ${error.message}`;
        saveStatus.className = 'save-status-small error';
      } finally {
        saveBtn.disabled = false;
      }
    }

    // Zone Notes save button handler
    const saveZoneNotesBtn = document.getElementById('saveZoneNotesBtn');
    if (saveZoneNotesBtn) {
      saveZoneNotesBtn.addEventListener('click', saveZoneNotes);
    }

    // Contact Mode toggle
    let contactModeActive = false;
    window.contactModeActive = false;
    const contactModeBtn = document.getElementById('contactModeBtn');
    if (contactModeBtn) {
      contactModeBtn.addEventListener('click', () => {
        contactModeActive = !contactModeActive;
        window.contactModeActive = contactModeActive;
        contactModeBtn.classList.toggle('active', contactModeActive);
        
        // If we're viewing an address detail, refresh it to show/hide contact mode UI
        const addressDetails = document.querySelector('.address-details.active');
        if (addressDetails) {
          const addressHeading = addressDetails.querySelector('h3');
          if (addressHeading) {
            const address = addressHeading.textContent.trim();
            displayAddressDetails(address);
          }
        }
      });
    }

    // Mark contact function
    window.markContact = async function(button, address, originalRowIndex, contactColumn) {
      if (!accessToken) {
        alert('Please sign in to mark contacts.');
        return;
      }

      // Get the current sheet URL - try multiple sources
      let sheetUrl = currentSheetUrl;
      if (!sheetUrl) {
        sheetUrl = localStorage.getItem('savedSheetUrl') || '';
      }
      if (!sheetUrl) {
        alert('No sheet loaded. Please load a spreadsheet first.');
        return;
      }

      const today = new Date().toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric' 
      });

      try {
        const sheetInfo = extractSheetId(sheetUrl);
        if (!sheetInfo || !sheetInfo.sheetId) {
          throw new Error('Invalid sheet URL. Make sure a spreadsheet is loaded.');
        }

        // Find the row to update (using originalRowIndex + 2 because row 1 is header, row 2 is first data)
        const rowNumber = originalRowIndex + 2;

        // Get column letters for contact date and contact notes
        const headers = sheetData.headers;
        const contactColIndex = headers.findIndex(h => 
          h.toLowerCase() === 'last contact date' ||
          h.toLowerCase().includes('last contact') || 
          h.toLowerCase().includes('contact date') ||
          h.toLowerCase().includes('contacted')
        );
        
        const contactNotesColIndex = headers.findIndex(h => 
          h.toLowerCase() === 'contact notes' ||
          h.toLowerCase().includes('contact notes')
        );

        // Get contact notes from the textarea
        const contactNotesTextarea = button.parentNode.querySelector('.contact-notes-quick');
        const contactNotes = contactNotesTextarea ? contactNotesTextarea.value.trim() : '';

        // Prepare updates for both date and notes
        const updates = [];
        
        // Update Last Contact Date
        if (contactColIndex >= 0) {
          const columnLetter = indexToColumnLetter(contactColIndex);
          const sheetName = 'Sheet1';
          const cellRange = `${sheetName}!${columnLetter}${rowNumber}`;
          updates.push({
            range: cellRange,
            values: [[today]]
          });
        }

        // Update Contact Notes if column exists (save even if empty to allow clearing)
        if (contactNotesColIndex >= 0) {
          const notesColumnLetter = indexToColumnLetter(contactNotesColIndex);
          const sheetName = 'Sheet1';
          const notesCellRange = `${sheetName}!${notesColumnLetter}${rowNumber}`;
          updates.push({
            range: notesCellRange,
            values: [[contactNotes]]
          });
        } else {
          console.warn('Contact Notes column not found in headers:', headers);
        }

        if (updates.length > 0) {
          const response = await fetch('/api/sheets/batch-update', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              sheetId: sheetInfo.sheetId,
              valueInputOption: 'USER_ENTERED',
              data: updates
            })
          });
          if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            console.error('Batch update error:', error);
            throw new Error(error.message || error.error || 'Failed to save contact');
          }
        }

        // Update UI
        button.classList.add('contacted');
        button.textContent = '‚úì Contacted';
        
        // Add date display if it doesn't exist
        const existingDate = button.parentNode.querySelector('.contact-date');
        if (!existingDate) {
          const dateDiv = document.createElement('div');
          dateDiv.className = 'contact-date';
          dateDiv.textContent = `Last contact: ${today}`;
          button.parentNode.insertBefore(dateDiv, button.nextSibling);
        } else {
          existingDate.textContent = `Last contact: ${today}`;
        }

        // Update local data
        if (sheetData && sheetData.data && sheetData.data[originalRowIndex]) {
          const contactCol = headers.find(h => 
            h.toLowerCase() === 'last contact date' ||
            h.toLowerCase().includes('last contact') || 
            h.toLowerCase().includes('contact date') ||
            h.toLowerCase().includes('contacted')
          ) || contactColumn;
          sheetData.data[originalRowIndex][contactCol] = today;
          
          // Update contact notes in local data if column exists
          if (contactNotesColIndex >= 0 && contactNotes) {
            const contactNotesCol = headers[contactNotesColIndex];
            sheetData.data[originalRowIndex][contactNotesCol] = contactNotes;
          }
          
          // Update address map
          if (sheetData.addressMap && sheetData.addressMap.has(address)) {
            const rows = sheetData.addressMap.get(address);
            const row = rows.find(r => r.__originalIndex === originalRowIndex);
            if (row) {
              row[contactCol] = today;
              if (contactNotesColIndex >= 0 && contactNotes) {
                const contactNotesCol = headers[contactNotesColIndex];
                row[contactNotesCol] = contactNotes;
              }
            }
          }
        }

        // Update person entry styling
        const personEntry = button.closest('.person-entry');
        if (personEntry) {
          personEntry.classList.remove('no-contact');
          personEntry.classList.add('recent-contact');
        }

      } catch (error) {
        console.error('Error marking contact:', error);
        alert('Error saving contact: ' + error.message);
      }
    };


    // Chart instances
    let peopleContactChart = null;
    let householdsContactChart = null;
    let damageChart = null;
    let householdStatusChart = null;
    let rebuildStatusChart = null;
    let rebuildStatusFunnelChart = null;
    let zoneOverviewAddressesChart = null;
    let zoneOverviewDamageChart = null;
    
    // Chart carousel state
    let zoneOverviewCarouselLeft = { currentIndex: 0, charts: [] };
    let zoneOverviewCarouselRight = { currentIndex: 0, charts: [] };

    // Update Zone Progress Charts
    function updateZoneProgressCharts() {
      if (!sheetData || !sheetData.data || sheetData.data.length === 0) {
        return;
      }

      // Charts are now in the progress view, not a separate panel
      // The view will be shown/hidden by the navigation system

      const headers = sheetData.headers;
      const data = sheetData.data;
      const addressMap = sheetData.addressMap || new Map();

      // Find relevant columns
      const lastContactCol = headers.find(h => 
        h.toLowerCase() === 'last contact date' ||
        h.toLowerCase().includes('last contact') || 
        h.toLowerCase().includes('contact date') ||
        h.toLowerCase().includes('contacted')
      );
      const damageCol = findColumn(headers, 'damage');
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);

      // 1. People Contacted Chart
      let peopleContacted = 0;
      let peopleNotContacted = 0;
      data.forEach(row => {
        const hasContact = lastContactCol && row[lastContactCol] && String(row[lastContactCol]).trim().length > 0;
        if (hasContact) {
          peopleContacted++;
        } else {
          peopleNotContacted++;
        }
      });

      const peopleTotal = peopleContacted + peopleNotContacted;
      const peopleContactedPct = peopleTotal > 0 ? ((peopleContacted / peopleTotal) * 100).toFixed(1) : '0';
      const peopleNotContactedPct = peopleTotal > 0 ? ((peopleNotContacted / peopleTotal) * 100).toFixed(1) : '0';

      const peopleContactCtx = document.getElementById('peopleContactChart');
      if (peopleContactChart) peopleContactChart.destroy();
      if (peopleContactCtx) {
        peopleContactChart = new Chart(peopleContactCtx, {
          type: 'pie',
          data: {
            labels: [`Contacted (${peopleContactedPct}%)`, `Not Contacted (${peopleNotContactedPct}%)`],
            datasets: [{
              data: [peopleContacted, peopleNotContacted],
              backgroundColor: ['#afc892', '#bc455a'],
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    return context.label + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }

      // 2. Households Contacted Chart
      const households = new Set();
      const householdsContacted = new Set();
      const houseNumCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'House #' || lower === 'house #' || lower.includes('house #') || 
               lower.includes('house#') || lower === 'house number' || lower === 'house num' ||
               (lower === 'house' && !lower.includes('hold'));
      });
      const streetCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'Street' || lower === 'street' || (lower.includes('street') && !lower.includes('address'));
      });

      data.forEach(row => {
        const houseNum = houseNumCol ? (row[houseNumCol] || '').trim() : '';
        const street = streetCol ? (row[streetCol] || '').trim() : '';
        const address = houseNum && street ? `${houseNum} ${street}` : '';
        if (address) {
          households.add(address);
          const hasContact = lastContactCol && row[lastContactCol] && String(row[lastContactCol]).trim().length > 0;
          if (hasContact) {
            householdsContacted.add(address);
          }
        }
      });

      const householdsContactedCount = householdsContacted.size;
      const householdsNotContactedCount = households.size - householdsContactedCount;
      const householdsTotal = householdsContactedCount + householdsNotContactedCount;
      const householdsContactedPct = householdsTotal > 0 ? ((householdsContactedCount / householdsTotal) * 100).toFixed(1) : '0';
      const householdsNotContactedPct = householdsTotal > 0 ? ((householdsNotContactedCount / householdsTotal) * 100).toFixed(1) : '0';

      const householdsContactCtx = document.getElementById('householdsContactChart');
      if (householdsContactChart) householdsContactChart.destroy();
      if (householdsContactCtx) {
        householdsContactChart = new Chart(householdsContactCtx, {
          type: 'pie',
          data: {
            labels: [`Contacted (${householdsContactedPct}%)`, `Not Contacted (${householdsNotContactedPct}%)`],
            datasets: [{
              data: [householdsContactedCount, householdsNotContactedCount],
              backgroundColor: ['#afc892', '#bc455a'],
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    return context.label + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }

      // 3. Damage Chart (by address, like Addresses Contacted and Address Plan)
      const damageCounts = {};
      let damageUnknown = 0;
      if (damageCol && addressMap && addressMap.size > 0) {
        addressMap.forEach((rows, address) => {
          const row = rows[0];
          const damage = row && row[damageCol] ? String(row[damageCol]).trim() : '';
          if (damage) {
            damageCounts[damage] = (damageCounts[damage] || 0) + 1;
          } else {
            damageUnknown++;
          }
        });
      } else if (damageCol) {
        data.forEach(row => {
          const damage = row[damageCol] ? String(row[damageCol]).trim() : '';
          if (damage) {
            damageCounts[damage] = (damageCounts[damage] || 0) + 1;
          } else {
            damageUnknown++;
          }
        });
      } else {
        damageUnknown = addressMap ? addressMap.size : data.length;
      }

      const damageLabels = Object.keys(damageCounts);
      const damageData = Object.values(damageCounts);
      const damageTotal = damageData.reduce((a, b) => a + b, 0) + damageUnknown;
      
      // Add Unknown if there are any
      if (damageUnknown > 0) {
        damageLabels.push('Unknown');
        damageData.push(damageUnknown);
      }
      
      // Calculate percentages for labels
      const damageLabelsWithPct = damageLabels.map((label, index) => {
        const value = damageData[index];
        const pct = damageTotal > 0 ? ((value / damageTotal) * 100).toFixed(1) : '0';
        return `${label} (${pct}%)`;
      });
      
      // Map damage status to map pin colors
      const getDamageColor = (label) => {
        const labelLower = (label || '').toLowerCase();
        if (labelLower.includes('total')) return '#bc455a'; // Red - total loss
        if (labelLower.includes('partial')) return '#fdba77'; // Yellow - partial loss
        if (labelLower.includes('standing')) return '#81bdc3'; // Blue - standing
        return '#e5e5e5'; // Pale green/gray - unknown
      };
      const damageColors = damageLabels.map(label => getDamageColor(label));

      const damageCtx = document.getElementById('damageChart');
      if (damageChart) damageChart.destroy();
      if (damageCtx && (damageLabels.length > 0 || damageUnknown > 0)) {
        damageChart = new Chart(damageCtx, {
          type: 'pie',
          data: {
            labels: damageLabelsWithPct,
            datasets: [{
              data: damageData,
              backgroundColor: damageColors,
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    // Remove percentage from label for tooltip (it's already in the label)
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }

      // 4. Address Plan Chart (conditional on Partial/Total Loss in data)
      const addressPlanCounts = {};
      let addressPlanUnknown = 0;
      if (addressPlanCol) {
        data.forEach(row => {
          const val = row[addressPlanCol] ? String(row[addressPlanCol]).trim() : '';
          if (val) {
            addressPlanCounts[val] = (addressPlanCounts[val] || 0) + 1;
          } else {
            addressPlanUnknown++;
          }
        });
      } else {
        addressPlanUnknown = data.length;
      }

      const statusLabels = Object.keys(addressPlanCounts);
      const statusData = Object.values(addressPlanCounts);
      const statusTotal = statusData.reduce((a, b) => a + b, 0) + addressPlanUnknown;
      
      if (addressPlanUnknown > 0) {
        statusLabels.push('(not set)');
        statusData.push(addressPlanUnknown);
      }
      
      // Calculate percentages for labels
      const statusLabelsWithPct = statusLabels.map((label, index) => {
        const value = statusData[index];
        const pct = statusTotal > 0 ? ((value / statusTotal) * 100).toFixed(1) : '0';
        return `${label} (${pct}%)`;
      });
      
      const statusColors = ['#afc892', '#81bdc3', '#fdba77', '#f6cf98', '#bc455a', '#e5e5e5', '#f9d6d3'];

      const statusCtx = document.getElementById('householdStatusChart');
      if (householdStatusChart) householdStatusChart.destroy();
      if (statusCtx && (statusLabels.length > 0 || addressPlanUnknown > 0)) {
        householdStatusChart = new Chart(statusCtx, {
          type: 'pie',
          data: {
            labels: statusLabelsWithPct,
            datasets: [{
              data: statusData,
              backgroundColor: statusColors.slice(0, statusLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    // Remove percentage from label for tooltip (it's already in the label)
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }
    }

    // Update Rebuild Progress Charts (bar charts for home page)
    function updateRebuildProgressCharts() {
      if (!sheetData || !sheetData.data || sheetData.data.length === 0) {
        return;
      }
      
      const headers = sheetData.headers;
      const data = sheetData.data;
      const addressMap = sheetData.addressMap;
      
      // Find relevant columns
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
      const rebuildCol = findColumn(headers, ['build', 'status'], ['intent']);
      
      // 1. Address Plan Bar Chart (for Partial/Total Loss addresses)
      const statusCounts = {};
      let statusUnknown = 0;
      if (addressPlanCol) {
        data.forEach(row => {
          const val = row[addressPlanCol] ? String(row[addressPlanCol]).trim() : '';
          if (val) {
            statusCounts[val] = (statusCounts[val] || 0) + 1;
          } else {
            statusUnknown++;
          }
        });
      } else {
        statusUnknown = data.length;
      }
      
      const statusLabels = Object.keys(statusCounts);
      const statusData = Object.values(statusCounts);
      if (statusUnknown > 0) {
        statusLabels.push('Unknown');
        statusData.push(statusUnknown);
      }
      
      const statusColors = ['#afc892', '#81bdc3', '#fdba77', '#f6cf98', '#bc455a', '#e5e5e5', '#f9d6d3'];
      
      const statusCtx = document.getElementById('householdStatusChart');
      if (householdStatusChart) householdStatusChart.destroy();
      if (statusCtx && (statusLabels.length > 0 || statusUnknown > 0)) {
        // Calculate percentages for labels
        const statusTotal = statusData.reduce((a, b) => a + b, 0);
        const statusLabelsWithPct = statusLabels.map((label, index) => {
          const value = statusData[index];
          const pct = statusTotal > 0 ? ((value / statusTotal) * 100).toFixed(1) : '0';
          return `${label} (${pct}%)`;
        });
        
        householdStatusChart = new Chart(statusCtx, {
          type: 'doughnut',
          data: {
            labels: statusLabelsWithPct,
            datasets: [{
              data: statusData,
              backgroundColor: statusColors.slice(0, statusLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            cutout: '60%',
            plugins: {
              legend: {
                position: 'bottom',
                padding: 10,
                labels: {
                  padding: 12,
                  font: {
                    size: 11
                  },
                  usePointStyle: true
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }
      
      // 2. Build Status Bar Chart
      const rebuildStages = [
        'Planning/Not Ready to Build Yet',
        'Permits & Pre-Construction',
        'Under Construction',
        'Finishing/Preparing to Move Back',
        'Moved In'
      ];
      
      const rebuildCounts = {};
      rebuildStages.forEach(stage => {
        rebuildCounts[stage] = 0;
      });
      rebuildCounts['Not Started'] = 0;
      rebuildCounts['Unknown'] = 0;
      
      if (rebuildCol && addressMap) {
        addressMap.forEach((rows, address) => {
          const row = rows[0];
          if (!row || !row[rebuildCol]) {
            rebuildCounts['Not Started']++;
            return;
          }
          
          const stage = String(row[rebuildCol] || '').trim();
          if (!stage || stage === '' || stage.toLowerCase() === 'none') {
            rebuildCounts['Not Started']++;
            return;
          }
          
          const stageLower = stage.toLowerCase();
          let matched = false;
          
          // Try exact match first (case-insensitive) with predefined stages
          for (const knownStage of rebuildStages) {
            const knownStageLower = knownStage.toLowerCase().trim();
            if (stageLower === knownStageLower) {
              rebuildCounts[knownStage]++;
              matched = true;
              break;
            }
          }
          
          // If no exact match, check for "Not Started" variations
          if (!matched) {
            if (stageLower.includes('not started') || 
                stageLower === 'none' ||
                stageLower === '') {
              rebuildCounts['Not Started']++;
              matched = true;
            }
          }
          
          // If still not matched, use the actual value from spreadsheet (preserve original case)
          // This allows for custom stages in the spreadsheet
          if (!matched) {
            // Check if we already have this exact value in rebuildCounts (preserve original case)
            if (rebuildCounts.hasOwnProperty(stage)) {
              rebuildCounts[stage]++;
            } else {
              // Use the actual stage value from spreadsheet (preserve original case)
              rebuildCounts[stage] = 1;
            }
          }
        });
      } else {
        rebuildCounts['Not Started'] = addressMap ? addressMap.size : 0;
      }
      
      // Collect all stages (predefined + custom from spreadsheet)
      const allStagesSet = new Set(rebuildStages);
      Object.keys(rebuildCounts).forEach(key => {
        if (key !== 'Not Started' && key !== 'Unknown') {
          allStagesSet.add(key);
        }
      });
      
      // Build final labels array: Not Started first, then predefined stages, then custom stages, then Unknown
      const customStages = Array.from(allStagesSet).filter(s => !rebuildStages.includes(s) && s !== 'Not Started' && s !== 'Unknown');
      const allRebuildLabels = ['Not Started', ...rebuildStages, ...customStages, 'Unknown'];
      
      // Generate data array for all labels (use 0 if stage doesn't exist in rebuildCounts)
      const rebuildData = allRebuildLabels.map(label => rebuildCounts[label] || 0);
      
      // Show all stages even if they're zero (as requested)
      const rebuildColors = ['#9e9e9e', '#bc455a', '#fdba77', '#f6cf98', '#afc892', '#81bdc3', '#e5e5e5', '#f9d6d3', '#e0e0e0', '#d4a574', '#c8a2c8', '#a8d8ea'];
      
      const rebuildCtx = document.getElementById('rebuildStatusChart');
      if (rebuildStatusChart) rebuildStatusChart.destroy();
      if (rebuildCtx) {
        rebuildStatusChart = new Chart(rebuildCtx, {
          type: 'bar',
          data: {
            labels: allRebuildLabels,
            datasets: [{
              label: 'Count',
              data: rebuildData,
              backgroundColor: rebuildColors.slice(0, allRebuildLabels.length),
              borderColor: rebuildColors.slice(0, allRebuildLabels.length),
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    // Use the full label from allRebuildLabels array (not truncated version)
                    const fullLabel = allRebuildLabels[context.dataIndex] || context.label;
                    return fullLabel + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            },
            scales: {
              x: {
                beginAtZero: true,
                ticks: {
                  stepSize: 1,
                  precision: 0,
                  font: {
                    size: 11
                  }
                },
                grid: {
                  display: true,
                  color: 'rgba(0, 0, 0, 0.05)'
                }
              },
              y: {
                ticks: {
                  font: {
                    size: 10
                  },
                  maxRotation: 0,
                  autoSkip: false,
                  callback: function(value, index) {
                    const label = allRebuildLabels[index];
                    // Truncate long labels and show full text in tooltip
                    if (label && label.length > 35) {
                      return label.substring(0, 32) + '...';
                    }
                    return label;
                  }
                },
                grid: {
                  display: false
                }
              }
            },
            layout: {
              padding: {
                right: 10
              }
            }
          }
        });
      }
      
      // 3. Build Status Funnel Chart (Sequential Left-to-Right, All Stages)
      const rebuildFunnelCtx = document.getElementById('rebuildStatusFunnelChart');
      if (rebuildStatusFunnelChart) rebuildStatusFunnelChart.destroy();
      if (rebuildFunnelCtx) {
        // Define sequential order of stages
        const sequentialOrder = [
          'Planning/Not Ready to Build Yet',
          'Permits & Pre-Construction',
          'Under Construction',
          'Finishing/Preparing to Move Back',
          'Moved In'
        ];
        
        // Build funnel data in sequential order (left to right) - include ALL stages
        const funnelStages = [];
        const funnelCounts = [];
        const funnelColors = [];
        
        // Add "Not Started" at the beginning
        const notStartedIndex = allRebuildLabels.indexOf('Not Started');
        if (notStartedIndex >= 0) {
          funnelStages.push('Not Started');
          funnelCounts.push(rebuildData[notStartedIndex] || 0);
          funnelColors.push(rebuildColors[notStartedIndex % rebuildColors.length]);
        }
        
        // Add all stages in sequential order (including those with 0 counts)
        sequentialOrder.forEach((stage) => {
          const stageIndex = allRebuildLabels.indexOf(stage);
          if (stageIndex >= 0) {
            funnelStages.push(stage);
            funnelCounts.push(rebuildData[stageIndex] || 0);
            funnelColors.push(rebuildColors[stageIndex % rebuildColors.length]);
          } else {
            // Stage not in data, add with 0 count
            funnelStages.push(stage);
            funnelCounts.push(0);
            funnelColors.push('#e0e0e0'); // Light gray for empty stages
          }
        });
        
        // Add "Unknown" at the end
        const unknownIndex = allRebuildLabels.indexOf('Unknown');
        if (unknownIndex >= 0) {
          funnelStages.push('Unknown');
          funnelCounts.push(rebuildData[unknownIndex] || 0);
          funnelColors.push(rebuildColors[unknownIndex % rebuildColors.length]);
        }
        
        const total = funnelCounts.reduce((a, b) => a + b, 0);
        
        rebuildStatusFunnelChart = new Chart(rebuildFunnelCtx, {
          type: 'bar',
          data: {
            labels: funnelStages,
            datasets: [{
              label: 'Households',
              data: funnelCounts,
              backgroundColor: funnelColors,
              borderColor: funnelColors.map(c => c),
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'x', // Vertical bars - stages on x-axis going left to right
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    const fullLabel = funnelStages[context.dataIndex] || context.label;
                    return fullLabel + ': ' + context.parsed + (total > 0 ? ' (' + percentage + '%)' : '');
                  }
                }
              }
            },
            scales: {
              x: {
                ticks: {
                  font: {
                    size: 10
                  },
                  maxRotation: 45,
                  minRotation: 45,
                  autoSkip: false,
                  callback: function(value, index) {
                    const label = funnelStages[index];
                    if (label && label.length > 25) {
                      return label.substring(0, 22) + '...';
                    }
                    return label;
                  }
                },
                grid: {
                  display: false
                }
              },
              y: {
                beginAtZero: true,
                ticks: {
                  stepSize: 1,
                  precision: 0,
                  font: {
                    size: 11
                  }
                },
                grid: {
                  display: true,
                  color: 'rgba(0, 0, 0, 0.05)'
                },
                title: {
                  display: true,
                  text: 'Number of Households',
                  font: {
                    size: 12
                  }
                }
              }
            },
            layout: {
              padding: {
                top: 10,
                bottom: 60,
                left: 10,
                right: 10
              }
            }
          }
        });
      }
    }

    // Home Dashboard Functions
    
    // Update all home dashboard panels
    function updateHomeDashboard() {
      if (!sheetData || !sheetData.addressMap) {
        // Show empty state
        const zoneSnapshotContent = document.getElementById('zoneSnapshotContent');
        const homeMapContainer = document.getElementById('homeMapContainer');
        if (zoneSnapshotContent) {
          zoneSnapshotContent.innerHTML = '<div class="empty">Load a spreadsheet to see zone stats</div>';
        }
        if (homeMapContainer) {
          homeMapContainer.innerHTML = '<div class="empty">Load a spreadsheet to see map</div>';
        }
        return;
      }
      
      updateZoneSnapshot();
      updateZoneProgressCharts();
      updateRebuildProgressCharts();
      initializeHomeMap();
      // Load zone boundary on home map (Mapbox or KML) if available
      if (zoneKmlUrl || (isMapboxEnabled() && currentZoneName)) {
        if (homeMap) {
          loadHomeZoneBoundary();
        } else {
          setTimeout(() => loadHomeZoneBoundary(), 500);
        }
      }
      fetchAndDisplayCentralFeed();
      displayQuickActions();
      updateZoneLeadership();
      
      // Update Actions page if it's currently visible
      if (currentView === 'meetups') {
        displayActionsPage();
      }
      
      // Update Zone Overview charts after a short delay to ensure DOM is ready
      setTimeout(() => {
        if (sheetData && sheetData.addressMap) {
          updateZoneOverviewCharts();
        }
      }, 100);
    }
    
    // Panel A: Zone Overview
    function updateZoneSnapshot() {
      if (!sheetData || !sheetData.addressMap || !sheetData.headers) {
        return;
      }
      
      const content = document.getElementById('zoneSnapshotContent');
      if (!content) return;
      
      const headers = sheetData.headers;
      const data = sheetData.data;
      const addressMap = sheetData.addressMap;
      
      // 1. Households in your zone (count of addresses)
      const householdsCount = addressMap.size;
      
      // 2. People in your zone (count unique resident names, or use "# of residents" field per address)
      const residentsCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('# of residents') || 
               lower.includes('number of residents') ||
               (lower.includes('#') && lower.includes('resident'));
      });
      
      const residentNameCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('resident name') || 
               lower.includes('name') && !lower.includes('household') && !lower.includes('address');
      });
      
      let peopleCount = 0;
      if (residentsCol) {
        // Use "# of residents" field - count per address, not per row
        addressMap.forEach((rows, address) => {
          const row = rows[0]; // Get first row for this address
          const residents = parseInt(row[residentsCol]) || 0;
          peopleCount += residents > 0 ? residents : 1;
        });
      } else if (residentNameCol) {
        // Count unique resident names across all addresses
        const uniqueResidents = new Set();
        addressMap.forEach((rows, address) => {
          rows.forEach(row => {
            const name = (row[residentNameCol] || '').trim();
            if (name) {
              uniqueResidents.add(name.toLowerCase());
            }
          });
        });
        peopleCount = uniqueResidents.size || householdsCount;
      } else {
        // Fallback: 1 person per address
        peopleCount = householdsCount;
      }
      
      // 3. Homes by damage status
      const damageCol = findColumn(headers, 'damage');
      const damageCounts = {
        'Total Loss': 0,
        'Partial Loss': 0,
        'Standing Home': 0,
        'Unknown': 0
      };
      
      if (damageCol) {
        addressMap.forEach((rows, address) => {
          const row = rows[0];
          const damage = (row[damageCol] || '').trim();
          if (damage) {
            const damageLower = damage.toLowerCase();
            if (damageLower.includes('total')) {
              damageCounts['Total Loss']++;
            } else if (damageLower.includes('partial')) {
              damageCounts['Partial Loss']++;
            } else if (damageLower.includes('standing')) {
              damageCounts['Standing Home']++;
            } else {
              // Check if it matches one of our known values
              if (damageCounts.hasOwnProperty(damage)) {
                damageCounts[damage]++;
              } else {
                damageCounts['Unknown']++;
              }
            }
          } else {
            damageCounts['Unknown']++;
          }
        });
      }
      
      // 4. Households not yet contacted
      const contactStatusCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('contact status');
      });
      const contactDateCol = headers.find(h => {
        const lower = h.toLowerCase();
        return (lower.includes('contact') && lower.includes('date')) ||
               lower.includes('last contact');
      });
      
      let uncontactedCount = 0;
      addressMap.forEach((rows, address) => {
        const row = rows[0];
        let isContacted = false;
        
        if (contactStatusCol && row[contactStatusCol]) {
          const status = String(row[contactStatusCol]).toLowerCase().trim();
          isContacted = status && !status.includes('uncontacted') && status !== 'no';
        } else if (contactDateCol && row[contactDateCol]) {
          const date = String(row[contactDateCol]).trim();
          isContacted = date.length > 0;
        }
        
        if (!isContacted) {
          uncontactedCount++;
        }
      });
      
      // 5. Last updated - find most recent timestamp
      const timestampCols = headers.filter(h => {
        const lower = h.toLowerCase();
        return lower.includes('date') || 
               lower.includes('timestamp') ||
               lower.includes('updated') ||
               lower.includes('last modified');
      });
      
      let lastUpdated = null;
      timestampCols.forEach(col => {
        data.forEach(row => {
          const value = row[col];
          if (value) {
            const date = new Date(value);
            if (!isNaN(date.getTime())) {
              if (!lastUpdated || date > lastUpdated) {
                lastUpdated = date;
              }
            }
          }
        });
      });
      
      // Format last updated date
      let lastUpdatedText = 'Not available';
      if (lastUpdated) {
        lastUpdatedText = lastUpdated.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
      }
      
      // Render the panel
      content.innerHTML = `
        <div class="stat-group">
          <div class="stat-item">
            <span class="stat-value">${householdsCount}</span>
            <span class="stat-label">addresses in your zone</span>
          </div>
          <div class="stat-item">
            <span class="stat-value">${peopleCount}</span>
            <span class="stat-label">people in your zone</span>
          </div>
          <div class="stat-item">
            <span class="stat-value">${uncontactedCount}</span>
            <span class="stat-label">addresses not yet contacted</span>
          </div>
        </div>
        
      `;
      
      // Show charts container and render charts
      const chartsContainer = document.getElementById('zoneOverviewCharts');
      const footerContainer = document.getElementById('zoneOverviewFooter');
      if (chartsContainer) {
        chartsContainer.classList.remove('hidden');
        updateZoneOverviewCharts();
      }
      
      // Update footer with last updated
      if (footerContainer) {
        footerContainer.classList.remove('hidden');
        const lastUpdatedSpan = footerContainer.querySelector('.stat-value');
        if (lastUpdatedSpan) {
          lastUpdatedSpan.textContent = lastUpdatedText;
        }
      }
    }
    
    // Panel E: Zone Leadership
    function updateZoneLeadership() {
      if (!sheetData || !sheetData.headers || !sheetData.data || sheetData.data.length === 0) {
        const content = document.getElementById('zoneLeadershipContent');
        if (content) {
          content.innerHTML = '<div class="empty">No zone leadership data available</div>';
        }
        return;
      }
      
      const content = document.getElementById('zoneLeadershipContent');
      if (!content) return;
      
      const headers = sheetData.headers;
      const allRows = sheetData.data;
      
      // Find NC columns (case-insensitive)
      const ncNameCol = findColumn(headers, 'nc name');
      const ncPhoneCol = findColumn(headers, 'nc phone');
      const ncEmailCol = findColumn(headers, 'nc email');
      
      // Get captain data from first row (should be the same for all rows in a zone)
      const firstRow = allRows[0];
      if (!firstRow) {
        content.innerHTML = '<div class="empty">No zone leadership data available</div>';
        return;
      }
      
      const ncName = ncNameCol ? (firstRow[ncNameCol] || '').trim() : '';
      const ncPhone = ncPhoneCol ? (firstRow[ncPhoneCol] || '').trim() : '';
      const ncEmail = ncEmailCol ? (firstRow[ncEmailCol] || '').trim() : '';
      
      // Parse captains
      const captains = parseCaptains(ncName, ncPhone, ncEmail);
      
      if (captains.length === 0) {
        content.innerHTML = '<div class="empty">No neighborhood captains assigned to this zone</div>';
        return;
      }
      
      // Build HTML for each captain
      let html = '<div style="display: flex; flex-direction: column; gap: 20px;">';
      
      captains.forEach((captain, index) => {
        html += `
          <div style="padding: 16px; background: rgba(96, 108, 56, 0.05); border-radius: 8px; border: 2px solid rgba(96, 108, 56, 0.2);">
            <div style="font-weight: 700; font-size: 1.1rem; color: var(--primary-dark); margin-bottom: 12px; font-family: 'Chivo', sans-serif;">
              ${escapeHtml(captain.name)}
            </div>
            <div style="display: flex; flex-direction: column; gap: 8px; font-size: 0.95rem;">
              ${captain.phone !== 'N/A' ? `
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="color: var(--text-light); font-weight: 600;">Phone:</span>
                  <a href="tel:${captain.phone.replace(/[^0-9+()-]/g, '')}" style="color: var(--primary); text-decoration: none;">${escapeHtml(captain.phone)}</a>
                </div>
              ` : ''}
              ${captain.email !== 'N/A' ? `
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="color: var(--text-light); font-weight: 600;">Email:</span>
                  <a href="mailto:${escapeHtml(captain.email)}" style="color: var(--primary); text-decoration: none; word-break: break-word;">${escapeHtml(captain.email)}</a>
                </div>
              ` : ''}
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      content.innerHTML = html;
    }
    
    // Store chart references
    const zoneOverviewChartRefs = {};
    
    // Chart carousel helper functions
    function renderChartInCanvas(canvasId, chartConfig) {
      const ctx = document.getElementById(canvasId);
      if (!ctx) return null;
      
      // Destroy existing chart if it exists
      if (zoneOverviewChartRefs[canvasId]) {
        zoneOverviewChartRefs[canvasId].destroy();
        zoneOverviewChartRefs[canvasId] = null;
      }
      
      if (!chartConfig) return null;
      
      const chart = new Chart(ctx, {
        type: chartConfig.type,
        data: chartConfig.data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: {
              top: 5,
              bottom: 5
            }
          },
          plugins: {
            legend: {
              position: 'bottom',
              padding: 6,
              labels: {
                font: {
                  size: 10
                },
                boxWidth: 10,
                boxHeight: 10,
                padding: 8
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.dataset.data.reduce((a, b) => a + b, 0);
                  const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                  const labelText = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                  return labelText + ': ' + context.parsed + ' (' + percentage + '%)';
                }
              }
            }
          },
          ...(chartConfig.options || {})
        }
      });
      
      // Store chart reference
      zoneOverviewChartRefs[canvasId] = chart;
      return chart;
    }

    // Get chart data functions
    function getAddressesContactedData(headers, data) {
      const lastContactCol = headers.find(h => 
        h.toLowerCase() === 'last contact date' ||
        h.toLowerCase().includes('last contact') || 
        h.toLowerCase().includes('contact date') ||
        h.toLowerCase().includes('contacted')
      );
      const houseNumCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'House #' || lower === 'house #' || lower.includes('house #') || 
               lower.includes('house#') || lower === 'house number' || lower === 'house num' ||
               (lower === 'house' && !lower.includes('hold'));
      });
      const streetCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'Street' || lower === 'street' || (lower.includes('street') && !lower.includes('address'));
      });

      const households = new Set();
      const householdsContacted = new Set();

      data.forEach(row => {
        const houseNum = houseNumCol ? (row[houseNumCol] || '').trim() : '';
        const street = streetCol ? (row[streetCol] || '').trim() : '';
        const address = houseNum && street ? `${houseNum} ${street}` : '';
        if (address) {
          households.add(address);
          const hasContact = lastContactCol && row[lastContactCol] && String(row[lastContactCol]).trim().length > 0;
          if (hasContact) {
            householdsContacted.add(address);
          }
        }
      });

      return {
        contacted: householdsContacted.size,
        notContacted: households.size - householdsContacted.size
      };
    }

    function getDamageStatusData(headers, data, addressMap) {
      const damageCol = findColumn(headers, 'damage');
      const damageCounts = {};
      let damageUnknown = 0;

      if (damageCol && addressMap && addressMap.size > 0) {
        addressMap.forEach((rows, address) => {
          const row = rows[0];
          const damage = row && row[damageCol] ? String(row[damageCol]).trim() : '';
          if (damage) {
            damageCounts[damage] = (damageCounts[damage] || 0) + 1;
          } else {
            damageUnknown++;
          }
        });
      } else if (damageCol) {
        data.forEach(row => {
          const damage = row[damageCol] ? String(row[damageCol]).trim() : '';
          if (damage) {
            damageCounts[damage] = (damageCounts[damage] || 0) + 1;
          } else {
            damageUnknown++;
          }
        });
      } else {
        damageUnknown = addressMap ? addressMap.size : (data ? data.length : 0);
      }

      const labels = Object.keys(damageCounts);
      const dataValues = Object.values(damageCounts);

      if (damageUnknown > 0) {
        labels.push('Unknown');
        dataValues.push(damageUnknown);
      }

      return { labels, data: dataValues };
    }

    function getHouseholdStatusData(headers, data, addressMap) {
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
      const statusCounts = {};
      let statusUnknown = 0;
      
      if (addressPlanCol) {
        addressMap.forEach((rows, address) => {
          const row = rows[0];
          const val = row[addressPlanCol] ? String(row[addressPlanCol]).trim() : '';
          if (val) {
            statusCounts[val] = (statusCounts[val] || 0) + 1;
          } else {
            statusUnknown++;
          }
        });
      } else {
        statusUnknown = addressMap.size;
      }

      const labels = Object.keys(statusCounts);
      const dataValues = Object.values(statusCounts);
      
      if (statusUnknown > 0) {
        labels.push('Unknown');
        dataValues.push(statusUnknown);
      }

      return { labels, data: dataValues };
    }

    function getStreetsDistributionData(headers, data) {
      const streetCol = headers.find(h => {
        const lower = h.toLowerCase();
        return h === 'Street' || lower === 'street' || (lower.includes('street') && !lower.includes('address'));
      });
      
      if (!streetCol) return { labels: [], data: [] };
      
      const streetCounts = {};
      data.forEach(row => {
        const street = row[streetCol] ? String(row[streetCol]).trim() : '';
        if (street) {
          streetCounts[street] = (streetCounts[street] || 0) + 1;
        }
      });

      // Sort by count (descending) and take top 8
      const sorted = Object.entries(streetCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);
      
      const labels = sorted.map(([street]) => street);
      const dataValues = sorted.map(([, count]) => count);

      return { labels, data: dataValues };
    }

    function getPeoplePerAddressData(headers, data, addressMap) {
      const residentNameCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('resident name') || (lower.includes('name') && !lower.includes('first') && !lower.includes('last') && !lower.includes('nc'));
      });
      
      const peoplePerAddress = {};
      addressMap.forEach((rows, address) => {
        let peopleCount = 0;
        rows.forEach(row => {
          if (residentNameCol && row[residentNameCol] && String(row[residentNameCol]).trim()) {
            peopleCount++;
          }
        });
        if (peopleCount > 0) {
          peoplePerAddress[peopleCount] = (peoplePerAddress[peopleCount] || 0) + 1;
        }
      });

      const labels = Object.keys(peoplePerAddress).sort((a, b) => parseInt(a) - parseInt(b)).map(n => `${n} ${n === '1' ? 'person' : 'people'}`);
      const dataValues = Object.keys(peoplePerAddress).sort((a, b) => parseInt(a) - parseInt(b)).map(n => peoplePerAddress[n]);

      return { labels, data: dataValues };
    }

    function getRebuildStatusData(headers, addressMap) {
      const rebuildCol = findColumn(headers, ['build', 'status'], ['intent']);
      const rebuildCounts = {};
      let rebuildUnknown = 0;
      
      if (rebuildCol) {
        addressMap.forEach((rows, address) => {
          const row = rows[0];
          const rebuild = row[rebuildCol] ? String(row[rebuildCol]).trim() : '';
          if (rebuild) {
            rebuildCounts[rebuild] = (rebuildCounts[rebuild] || 0) + 1;
          } else {
            rebuildUnknown++;
          }
        });
      } else {
        rebuildUnknown = addressMap.size;
      }

      const labels = Object.keys(rebuildCounts);
      const dataValues = Object.values(rebuildCounts);
      
      if (rebuildUnknown > 0) {
        labels.push('Not Started');
        dataValues.push(rebuildUnknown);
      }

      return { labels, data: dataValues };
    }

    // Carousel navigation
    function navigateCarousel(carouselId, direction) {
      const carousel = carouselId === 'left' ? zoneOverviewCarouselLeft : zoneOverviewCarouselRight;
      const childIndex = carouselId === 'left' ? '1' : '2';
      const slides = document.querySelectorAll(`.chart-carousel-wrapper:nth-child(${childIndex}) .chart-carousel-slide`);
      const totalSlides = slides.length;
      
      if (totalSlides === 0) return;
      
      // Remove active class from current slide
      slides[carousel.currentIndex].classList.remove('active');
      
      // Calculate new index
      if (direction === 'next') {
        carousel.currentIndex = (carousel.currentIndex + 1) % totalSlides;
      } else {
        carousel.currentIndex = (carousel.currentIndex - 1 + totalSlides) % totalSlides;
      }
      
      // Add active class to new slide
      slides[carousel.currentIndex].classList.add('active');
      
      // Update dots
      updateCarouselDots(carouselId);
      
      // Render chart for active slide
      renderCarouselChart(carouselId, carousel.currentIndex);
    }

    function updateCarouselDots(carouselId) {
      const carousel = carouselId === 'left' ? zoneOverviewCarouselLeft : zoneOverviewCarouselRight;
      const dotsContainer = document.querySelector(`.chart-carousel-dots[data-carousel="${carouselId}"]`);
      if (!dotsContainer) return;
      
      const childIndex = carouselId === 'left' ? '1' : '2';
      const slides = document.querySelectorAll(`.chart-carousel-wrapper:nth-child(${childIndex}) .chart-carousel-slide`);
      const totalSlides = slides.length;
      
      dotsContainer.innerHTML = '';
      for (let i = 0; i < totalSlides; i++) {
        const dot = document.createElement('button');
        dot.className = `chart-carousel-dot ${i === carousel.currentIndex ? 'active' : ''}`;
        dot.setAttribute('aria-label', `Go to chart ${i + 1}`);
        dot.addEventListener('click', () => {
          const carousel = carouselId === 'left' ? zoneOverviewCarouselLeft : zoneOverviewCarouselRight;
          const childIndex = carouselId === 'left' ? '1' : '2';
          const slides = document.querySelectorAll(`.chart-carousel-wrapper:nth-child(${childIndex}) .chart-carousel-slide`);
          slides[carousel.currentIndex].classList.remove('active');
          carousel.currentIndex = i;
          slides[carousel.currentIndex].classList.add('active');
          updateCarouselDots(carouselId);
          renderCarouselChart(carouselId, i);
        });
        dotsContainer.appendChild(dot);
      }
    }

    function renderCarouselChart(carouselId, chartIndex) {
      if (!sheetData || !sheetData.data || !sheetData.addressMap) return;
      
      const headers = sheetData.headers;
      const data = sheetData.data;
      const addressMap = sheetData.addressMap;
      
      // Define chart configurations - same for both carousels
      const allCharts = [
        {
          canvasId: 'zoneOverviewAddressesChart',
          render: () => {
            const contactData = getAddressesContactedData(headers, data);
            return {
              type: 'pie',
              data: {
                labels: [`Contacted (${contactData.contacted})`, `Not Contacted (${contactData.notContacted})`],
                datasets: [{
                  data: [contactData.contacted, contactData.notContacted],
                  backgroundColor: ['#81bdc3', '#bc455a'],
                  borderWidth: 2,
                  borderColor: '#fff'
                }]
              },
              options: {}
            };
          }
        },
        {
          canvasId: 'zoneOverviewDamageChart',
          render: () => {
            const damageData = getDamageStatusData(headers, data, addressMap);
            // Map damage status to map pin colors
            const getDamageColor = (label) => {
              const labelLower = (label || '').toLowerCase();
              if (labelLower.includes('total')) return '#bc455a'; // Red - total loss
              if (labelLower.includes('partial')) return '#fdba77'; // Yellow - partial loss
              if (labelLower.includes('standing')) return '#81bdc3'; // Blue - standing
              return '#e5e5e5'; // Pale green/gray - unknown
            };
            const damageColors = damageData.labels.map(label => getDamageColor(label));
            const labelsWithCount = damageData.labels.map((label, i) => `${label} (${damageData.data[i]})`);
            return {
              type: 'pie',
              data: {
                labels: labelsWithCount,
                datasets: [{
                  data: damageData.data,
                  backgroundColor: damageColors,
                  borderWidth: 2,
                  borderColor: '#fff'
                }]
              },
              options: {}
            };
          }
        },
        {
          canvasId: 'zoneOverviewHouseholdChart',
          render: () => {
            const statusData = getHouseholdStatusData(headers, data, addressMap);
            const statusColors = ['#afc892', '#81bdc3', '#fdba77', '#f6cf98', '#bc455a', '#e5e5e5', '#f9d6d3'];
            const labelsWithCount = statusData.labels.map((label, i) => `${label} (${statusData.data[i]})`);
            return {
              type: 'doughnut',
              data: {
                labels: labelsWithCount,
                datasets: [{
                  data: statusData.data,
                  backgroundColor: statusColors.slice(0, statusData.labels.length),
                  borderWidth: 2,
                  borderColor: '#fff'
                }]
              },
              options: {
                cutout: '60%'
              }
            };
          }
        },
        {
          canvasId: 'zoneOverviewStreetsChart',
          render: () => {
            const streetsData = getStreetsDistributionData(headers, data);
            if (streetsData.labels.length === 0) return null;
            return {
              type: 'bar',
              data: {
                labels: streetsData.labels,
                datasets: [{
                  label: 'Addresses',
                  data: streetsData.data,
                  backgroundColor: '#81bdc3',
                  borderColor: '#606C38',
                  borderWidth: 1
                }]
              },
              options: {
                indexAxis: 'y',
                scales: {
                  x: {
                    beginAtZero: true,
                    ticks: { stepSize: 1, precision: 0 }
                  }
                }
              }
            };
          }
        },
        {
          canvasId: 'zoneOverviewPeopleChart',
          render: () => {
            const peopleData = getPeoplePerAddressData(headers, data, addressMap);
            if (peopleData.labels.length === 0) return null;
            return {
              type: 'bar',
              data: {
                labels: peopleData.labels,
                datasets: [{
                  label: 'Addresses',
                  data: peopleData.data,
                  backgroundColor: '#afc892',
                  borderColor: '#606C38',
                  borderWidth: 1
                }]
              },
              options: {
                scales: {
                  y: {
                    beginAtZero: true,
                    ticks: { stepSize: 1, precision: 0 }
                  }
                }
              }
            };
          }
        },
        {
          canvasId: 'zoneOverviewRebuildChart',
          render: () => {
            const rebuildData = getRebuildStatusData(headers, addressMap);
            if (rebuildData.labels.length === 0) return null;
            const rebuildColors = ['#9e9e9e', '#bc455a', '#fdba77', '#f6cf98', '#afc892', '#81bdc3', '#e5e5e5', '#f9d6d3'];
            const labelsWithCount = rebuildData.labels.map((label, i) => `${label} (${rebuildData.data[i]})`);
            return {
              type: 'doughnut',
              data: {
                labels: labelsWithCount,
                datasets: [{
                  data: rebuildData.data,
                  backgroundColor: rebuildColors.slice(0, rebuildData.labels.length),
                  borderWidth: 2,
                  borderColor: '#fff'
                }]
              },
              options: {
                cutout: '60%'
              }
            };
          }
        }
      ];

      // Map chart definitions to the correct canvas IDs for each carousel
      // LEFT: Addresses Contacted (0), Streets Distribution (3), People per Address (4)
      // RIGHT: Damage Status (1), Build Status (5), Address Plan (2)
      const chartIndexMap = {
        'left': [0, 3, 4],  // Addresses Contacted, Streets Distribution, People per Address
        'right': [1, 5, 2]  // Damage Status, Build Status, Address Plan
      };
      
      const canvasIdMap = {
        'left': [
          'zoneOverviewLeftAddressesChart',
          'zoneOverviewLeftStreetsChart',
          'zoneOverviewLeftPeopleChart'
        ],
        'right': [
          'zoneOverviewRightDamageChart',
          'zoneOverviewRightRebuildChart',
          'zoneOverviewRightHouseholdChart'
        ]
      };
      
      // Get the chart indices for this carousel
      const chartIndices = chartIndexMap[carouselId];
      const charts = chartIndices.map((originalIndex, carouselIndex) => ({
        ...allCharts[originalIndex],
        canvasId: canvasIdMap[carouselId][carouselIndex]
      }));
      if (chartIndex >= charts.length) return;
      
      const chartConfig = charts[chartIndex].render();
      if (chartConfig) {
        renderChartInCanvas(charts[chartIndex].canvasId, chartConfig);
      }
    }


    // Initialize carousel controls
    function initializeCarouselControls() {
      // Left carousel arrows
      const leftPrev = document.querySelector('.chart-carousel-wrapper:nth-child(1) .chart-carousel-arrow-left');
      const leftNext = document.querySelector('.chart-carousel-wrapper:nth-child(1) .chart-carousel-arrow-right');
      
      if (leftPrev) {
        leftPrev.addEventListener('click', () => {
          navigateCarousel('left', 'prev');
        });
      }
      if (leftNext) {
        leftNext.addEventListener('click', () => {
          navigateCarousel('left', 'next');
        });
      }

      // Right carousel arrows
      const rightPrev = document.querySelector('.chart-carousel-wrapper:nth-child(2) .chart-carousel-arrow-left');
      const rightNext = document.querySelector('.chart-carousel-wrapper:nth-child(2) .chart-carousel-arrow-right');
      
      if (rightPrev) {
        rightPrev.addEventListener('click', () => {
          navigateCarousel('right', 'prev');
        });
      }
      if (rightNext) {
        rightNext.addEventListener('click', () => {
          navigateCarousel('right', 'next');
        });
      }
    }

    // Update Zone Overview charts with carousel
    function updateZoneOverviewCharts() {
      if (!sheetData || !sheetData.data || sheetData.data.length === 0) {
        return;
      }
      
      // Reset carousel indices
      zoneOverviewCarouselLeft.currentIndex = 0;
      zoneOverviewCarouselRight.currentIndex = 0;
      
      // Show first slide in each carousel
      const leftSlides = document.querySelectorAll('.chart-carousel-wrapper:nth-child(1) .chart-carousel-slide');
      const rightSlides = document.querySelectorAll('.chart-carousel-wrapper:nth-child(2) .chart-carousel-slide');
      
      leftSlides.forEach((slide, index) => {
        slide.classList.remove('active');
        if (index === 0) {
          slide.classList.add('active');
        }
      });
      
      rightSlides.forEach((slide, index) => {
        slide.classList.remove('active');
        if (index === 0) {
          slide.classList.add('active');
        }
      });
      
      // Initialize dots
      updateCarouselDots('left');
      updateCarouselDots('right');
      
      // Render initial charts
      renderCarouselChart('left', 0);
      renderCarouselChart('right', 0);
      
      // Initialize controls (only once)
      const firstWrapper = document.querySelector('.chart-carousel-wrapper');
      if (firstWrapper && !firstWrapper.hasAttribute('data-initialized')) {
        initializeCarouselControls();
        document.querySelectorAll('.chart-carousel-wrapper').forEach(w => w.setAttribute('data-initialized', 'true'));
      }
    }
    
    // Panel B: Build Progress Snapshot
    function updateRebuildProgress() {
      if (!sheetData || !sheetData.addressMap || !sheetData.headers) {
        return;
      }
      
      const content = document.getElementById('rebuildProgressContent');
      if (!content) return;
      
      const headers = sheetData.headers;
      const addressMap = sheetData.addressMap;
      
      // Find Build/Rebuild Stage column
      const rebuildCol = headers.find(h => {
        const lower = h.toLowerCase();
        return lower.includes('rebuild stage') ||
               (lower.includes('rebuild') && lower.includes('stage')) ||
               lower.includes('build stage') ||
               (lower.includes('build') && lower.includes('stage'));
      });
      
      const rebuildCounts = {};
      const defaultStages = [
        'Not started',
        'Planning / Design',
        'Permits in progress',
        'Construction in progress',
        'Rebuild completed'
      ];
      
      // Initialize default stages
      defaultStages.forEach(stage => {
        rebuildCounts[stage] = 0;
      });
      rebuildCounts['Unknown'] = 0;
      
      if (rebuildCol) {
        addressMap.forEach((rows, address) => {
          const row = rows[0];
          const stage = (row[rebuildCol] || '').trim();
          if (stage) {
            // Try to match to known stages or use as-is
            let matched = false;
            for (const defaultStage of defaultStages) {
              if (stage.toLowerCase().includes(defaultStage.toLowerCase()) ||
                  defaultStage.toLowerCase().includes(stage.toLowerCase())) {
                rebuildCounts[defaultStage]++;
                matched = true;
                break;
              }
            }
            if (!matched) {
              // Check if it's an exact match to any key
              if (rebuildCounts.hasOwnProperty(stage)) {
                rebuildCounts[stage]++;
              } else {
                rebuildCounts['Unknown']++;
              }
            }
          } else {
            rebuildCounts['Unknown']++;
          }
        });
      } else {
        // No rebuild column found
        rebuildCounts['Unknown'] = addressMap.size;
      }
      
      // Render the panel
      content.innerHTML = `
        <div class="stat-group">
          ${Object.entries(rebuildCounts).filter(([stage, count]) => count > 0 || stage === 'Not started').map(([stage, count]) => `
            <div class="rebuild-stat-item">
              <span class="rebuild-stat-label">${stage}</span>
              <span class="rebuild-stat-count">${count}</span>
            </div>
          `).join('')}
        </div>
      `;
    }
    
    // Helper function to convert markdown-style links and URLs to clickable links
    // linkifyText moved to js/utils.js

    // Helper function to fetch Google Sheet directly (for static hosting like GitHub Pages)
    async function fetchSheetDirectly(sheetId) {
      const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
      
      const response = await fetch(csvUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch sheet: ${response.status}`);
      }
      
      const csvText = await response.text();
      const lines = csvText.split('\n').filter(line => line.trim());
      
      if (lines.length === 0) return { items: [], alert: null };
      
      // Parse CSV (simple parser for quoted fields)
      function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
            else { inQuotes = !inQuotes; }
          } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current.trim());
        return result;
      }
      
      const headers = parseCSVLine(lines[0]);
      const rows = lines.slice(1).map(line => {
        const values = parseCSVLine(line);
        const row = {};
        headers.forEach((header, index) => { row[header] = values[index] || ''; });
        return row;
      });
      
      // Build result (same logic as server.js)
      const result = { items: [], alert: null };
      const labelCol = headers[0] || 'Label';
      const contentCol = headers[1] || 'Content';
      
      // Check for alert in first row
      if (rows.length > 0) {
        const alertLabel = (rows[0][labelCol] || '').trim().toUpperCase();
        if (alertLabel === 'ALERT' || alertLabel === 'URGENT') {
          const alertText = (rows[0][contentCol] || '').trim();
          if (alertText) result.alert = alertText;
        }
      }
      
      // Process rows
      rows.forEach((row, index) => {
        if (index === 0) {
          const rowLabel = (row[labelCol] || '').trim().toUpperCase();
          if (rowLabel === 'ALERT' || rowLabel === 'URGENT') return;
        }
        
        const label = (row[labelCol] || '').trim();
        if (!label) return;
        
        const content = [];
        for (let i = 1; i < headers.length; i++) {
          const val = (row[headers[i]] || '').trim();
          if (val) content.push(val);
        }
        
        result.items.push({ label, content });
      });
      
      return result;
    }

    // Panel C: From Altagether (Central Feed)
    async function fetchAndDisplayCentralFeed() {
      const content = document.getElementById('altagetherContent');
      if (!content) return;
      
      content.innerHTML = '<div class="loading">Loading announcements...</div>';
      
      // Central sheet ID - same one from server.js
      const CENTRAL_SHEET_ID = '1PaqcX2BSypJjLBDMA3DnlAxCHK5y0TWMSbCIkTScIQU';
      
      try {
        // Try backend API first (for localhost), fallback to direct Google Sheets fetch
        let feed;
        try {
          const response = await fetch('/api/homepage-feed');
          if (response.ok) {
            feed = await response.json();
          } else {
            throw new Error('Backend not available');
          }
        } catch (backendError) {
          // Fallback: Fetch directly from Google Sheets (for GitHub Pages)
          console.log('Backend unavailable, fetching directly from Google Sheets...');
          feed = await fetchSheetDirectly(CENTRAL_SHEET_ID);
        }
        
        // Display alert in card if there's an alert
        const alertCard = document.getElementById('alertCard');
        const alertCardContent = document.getElementById('alertCardContent');
        const alertAcknowledgeBtn = document.getElementById('alertAcknowledgeBtn');
        
        if (feed.alert && feed.alert.trim()) {
          const dismissedAlert = localStorage.getItem('dismissedAlert');
          
          // Only show if not already dismissed (or content changed)
          if (dismissedAlert !== feed.alert) {
            alertCardContent.innerHTML = linkifyText(feed.alert);
            alertCard.classList.remove('hidden');
            
            // Set up acknowledge handler
            alertAcknowledgeBtn.onclick = () => {
              localStorage.setItem('dismissedAlert', feed.alert);
              alertCard.classList.add('hidden');
            };
          } else {
            alertCard.classList.add('hidden');
          }
        } else {
          alertCard.classList.add('hidden');
        }
        
        let html = '';
        
        // Display each item: Label (bold) followed by Content from columns B, C, D, etc.
        if (feed.items && feed.items.length > 0) {
          feed.items.forEach(item => {
            if (item.label) {
              html += `
                <div class="announcement-item">
                  <div class="announcement-title"><strong>${item.label}</strong></div>
                  ${item.content && item.content.length > 0 ? item.content.map(contentText => 
                    `<div class="announcement-description">${linkifyText(contentText)}</div>`
                  ).join('') : ''}
                </div>
              `;
            }
          });
        }
        
        if (!html) {
          html = '<div class="empty">No announcements at this time.</div>';
        }
        
        content.innerHTML = html;
      } catch (error) {
        console.error('Error fetching central feed:', error);
        content.innerHTML = '<div class="error">Failed to load announcements. Please try again later.</div>';
      }
    }

    // Helper function to fetch Actions sheet directly (for static hosting like GitHub Pages)
    async function fetchActionsSheetDirectly(sheetId) {
      const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
      
      const response = await fetch(csvUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch actions sheet: ${response.status}`);
      }
      
      const csvText = await response.text();
      const lines = csvText.split('\n').filter(line => line.trim());
      
      if (lines.length === 0) return { items: [] };
      
      // Parse CSV (simple parser for quoted fields)
      function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
            else { inQuotes = !inQuotes; }
          } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current.trim());
        return result;
      }
      
      const headers = parseCSVLine(lines[0]);
      const rows = lines.slice(1).map(line => {
        const values = parseCSVLine(line);
        const row = {};
        headers.forEach((header, index) => { row[header] = values[index] || ''; });
        return row;
      });
      
      // Build result
      const result = { items: [] };
      const labelCol = headers[0] || 'Label';
      
      // Look for ContentA, ContentB, ContentC, ContentD columns (case-insensitive)
      const contentCols = ['ContentA', 'ContentB', 'ContentC', 'ContentD'].map(colName => {
        return headers.find(h => h.trim().toLowerCase() === colName.toLowerCase());
      }).filter(Boolean);
      
      // Process rows
      rows.forEach((row) => {
        const label = (row[labelCol] || '').trim();
        if (!label) return;
        
        const content = [];
        contentCols.forEach(colName => {
          const val = (row[colName] || '').trim();
          if (val) content.push(val);
        });
        
        result.items.push({ label, content });
      });
      
      return result;
    }

    // Fetch and display actions from spreadsheet
    async function fetchAndDisplayActions() {
      const content = document.getElementById('actionsPageContent');
      if (!content) return '';
      
      // Actions sheet ID - same one from server.js
      const ACTIONS_SHEET_ID = '1g6gmdXF1yjrejpmT3HTY7JI1Zzb7jErYZQ2pwiH37I0';
      
      try {
        // Try backend API first (for localhost), fallback to direct Google Sheets fetch
        let feed;
        try {
          const response = await fetch('/api/actions-feed');
          if (response.ok) {
            feed = await response.json();
          } else {
            throw new Error('Backend not available');
          }
        } catch (backendError) {
          // Fallback: Fetch directly from Google Sheets (for GitHub Pages)
          console.log('Backend unavailable for actions, fetching directly from Google Sheets...');
          feed = await fetchActionsSheetDirectly(ACTIONS_SHEET_ID);
        }
        
        let html = '';
        
        // Display each action as a card (styled like "From Altagether" panel)
        if (feed.items && feed.items.length > 0) {
          feed.items.forEach(item => {
            if (item.label) {
              html += `
                <div class="action-card action-card--altagether">
                  <div class="action-card-title">${item.label}</div>
                  ${item.content && item.content.length > 0 ? item.content.map(contentText => 
                    `<div class="action-card-content">${linkifyText(contentText)}</div>`
                  ).join('') : ''}
                </div>
              `;
            }
          });
        }
        
        return html;
      } catch (error) {
        console.error('Error fetching actions feed:', error);
        return '<div class="error">Failed to load actions from spreadsheet. Please try again later.</div>';
      }
    }

    // Point-in-polygon (ray casting) for Batch Tagging map. Ring = array of L.LatLng; x=lon, y=lat.
    function pointInPolygon(lat, lng, ring) {
      const n = ring.length;
      if (n < 3) return false;
      const x = lng, y = lat;
      let inside = false;
      for (let i = 0, j = n - 1; i < n; j = i++) {
        const xi = ring[i].lng, yi = ring[i].lat;
        const xj = ring[j].lng, yj = ring[j].lat;
        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) inside = !inside;
      }
      return inside;
    }

    // ============================================
    // Batch Tagging Tool
    // ============================================
    function initializeBatchTagging() {
      const errEl = document.getElementById('batchTaggingError');
      const bodyEl = document.getElementById('batchTaggingBody');
      const listView = document.getElementById('batchTaggingListView');
      const mapView = document.getElementById('batchTaggingMapView');
      const listEl = document.getElementById('batchTaggingAddressList');
      const damageSelect = document.getElementById('batchTaggingDamage');
      const addressPlanSelect = document.getElementById('batchTaggingAddressPlan');
      const rebuildSelect = document.getElementById('batchTaggingRebuild');
      const applyBtn = document.getElementById('batchTaggingApply');
      const statusMsg = document.getElementById('batchTaggingStatusMsg');
      const selectAllBtn = document.getElementById('batchTaggingSelectAll');
      const selectNoneBtn = document.getElementById('batchTaggingSelectNone');
      const drawOnMapBtn = document.getElementById('batchTaggingDrawOnMap');
      const noCoordsNote = document.getElementById('batchTaggingNoCoordsNote');
      const mapBackBtn = document.getElementById('batchTaggingMapBackToList');
      const mapCloseBtn = document.getElementById('batchTaggingMapClosePolygon');
      const mapClearBtn = document.getElementById('batchTaggingMapClear');
      const mapContainer = document.getElementById('batchTaggingMapContainer');
      const mapStatusEl = document.getElementById('batchTaggingMapStatus');
      if (!listEl || !damageSelect || !addressPlanSelect || !rebuildSelect || !applyBtn) return;
      if (errEl) { errEl.classList.add('hidden'); errEl.textContent = ''; }
      if (statusMsg) statusMsg.textContent = '';
      if (!sheetData || !sheetData.addressMap) {
        if (errEl) { errEl.textContent = 'Please load a spreadsheet first.'; errEl.classList.remove('hidden'); }
        if (bodyEl) bodyEl.classList.add('hidden');
        return;
      }
      if (!accessToken || !currentSheetId) {
        if (errEl) { errEl.textContent = 'Please sign in with Google to use Batch Tagging.'; errEl.classList.remove('hidden'); }
        if (bodyEl) bodyEl.classList.add('hidden');
        return;
      }
      if (bodyEl) bodyEl.classList.remove('hidden');
      const addresses = getFilteredAddresses();
      const headers = sheetData.headers;
      const latCol = headers.find(h => { const l = h.toLowerCase().trim(); return l.includes('lat') || l === 'latitude'; });
      const lonCol = headers.find(h => { const l = h.toLowerCase().trim(); return l.includes('lon') || l.includes('lng') || l === 'longitude'; });
      const hasLatLon = !!(latCol && lonCol);
      if (drawOnMapBtn) {
        drawOnMapBtn.disabled = !hasLatLon;
        drawOnMapBtn.title = hasLatLon ? 'Select addresses by drawing a shape on the map' : 'Draw on map requires Latitude and Longitude columns in your sheet';
      }
      if (noCoordsNote) {
        if (hasLatLon && addresses.length > 0) {
          const withCoords = addresses.filter(addr => {
            const rows = sheetData.addressMap.get(addr);
            if (!rows || !rows[0]) return false;
            const latVal = rows[0][latCol], lonVal = rows[0][lonCol];
            if (latVal == null || latVal === '' || lonVal == null || lonVal === '') return false;
            const lat = parseFloat(String(latVal).trim()), lon = parseFloat(String(lonVal).trim());
            if (isNaN(lat) || isNaN(lon) || (Math.abs(lat) < 0.0001 && Math.abs(lon) < 0.0001)) return false;
            return true;
          });
          const without = addresses.length - withCoords.length;
          if (without > 0) {
            noCoordsNote.textContent = withCoords.length + ' address(es) with coordinates (shown on map). ' + without + ' without coordinates.';
            noCoordsNote.classList.remove('hidden');
          } else {
            noCoordsNote.classList.add('hidden');
          }
        } else {
          noCoordsNote.classList.add('hidden');
        }
      }
      if (window._batchTaggingMapState && window._batchTaggingMapState.map) {
        window._batchTaggingMapState.map.remove();
        window._batchTaggingMapState = null;
      }
      if (listView && mapView) {
        listView.classList.remove('hidden');
        mapView.classList.add('hidden');
      }
      const damageCol = findColumn(headers, 'damage');
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
      const rebuildCol = findColumn(headers, ['build', 'status'], ['intent']);
      const damageOpts = getFullDamageOptions();
      const addressPlanOpts = getFullAddressPlanOptions();
      const rebuildOpts = getFullRebuildStatusOptions();
      damageSelect.innerHTML = '<option value="">‚Äî</option>' + damageOpts.map(v => `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`).join('');
      addressPlanSelect.innerHTML = '<option value="">‚Äî</option>' + addressPlanOpts.map(v => `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`).join('');
      rebuildSelect.innerHTML = '<option value="">‚Äî</option>' + rebuildOpts.map(v => `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`).join('');
      listEl.innerHTML = '';
      if (addresses.length === 0) {
        listEl.innerHTML = '<p style="margin:0; color:var(--text-light);">No addresses match your current filters. Change filters on the Neighbors page to see addresses here.</p>';
      } else {
        addresses.forEach(addr => {
          const label = document.createElement('label');
          label.style.display = 'block';
          label.style.marginBottom = '6px';
          label.style.cursor = 'pointer';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.className = 'batch-tag-address-cb';
          cb.setAttribute('data-address', addr.replace(/"/g, '&quot;'));
          label.appendChild(cb);
          label.appendChild(document.createTextNode(' ' + addr));
          listEl.appendChild(label);
        });
      }
      if (selectAllBtn) selectAllBtn.onclick = () => listEl.querySelectorAll('.batch-tag-address-cb').forEach(cb => { cb.checked = true; });
      if (selectNoneBtn) selectNoneBtn.onclick = () => listEl.querySelectorAll('.batch-tag-address-cb').forEach(cb => { cb.checked = false; });

      function buildAddressToCoords() {
        const out = {};
        if (!hasLatLon || !sheetData || !sheetData.addressMap) return out;
        addresses.forEach(addr => {
          const rows = sheetData.addressMap.get(addr);
          if (!rows || !rows[0]) return;
          const latVal = rows[0][latCol], lonVal = rows[0][lonCol];
          if (latVal == null || latVal === '' || lonVal == null || lonVal === '') return;
          const lat = parseFloat(String(latVal).trim()), lon = parseFloat(String(lonVal).trim());
          if (isNaN(lat) || isNaN(lon) || (Math.abs(lat) < 0.0001 && Math.abs(lon) < 0.0001)) return;
          out[addr] = { lat, lon };
        });
        return out;
      }

      const CLOSE_POLYGON_CLICK_METERS = 25;
      const ADDRESS_DOT_DEFAULT = '#e5e5e5';
      const ADDRESS_DOT_SELECTED = '#bc455a';
      const ADDRESS_DOT_STROKE = '#1F2937';
      const ADDRESS_DOT_STROKE_WEIGHT = 1.5;

      function showMapView() {
        if (!mapContainer || typeof L === 'undefined') return;
        listView.classList.add('hidden');
        mapView.classList.remove('hidden');
        const addressToCoords = buildAddressToCoords();
        if (!window._batchTaggingMapState) {
          const defaultCenter = [34.19, -118.15];
          const bounds = Object.values(addressToCoords).map(({ lat, lon }) => [lat, lon]);
          const center = bounds.length ? bounds.reduce((a, b) => [a[0] + b[0], a[1] + b[1]], [0, 0]).map((v, i) => v / bounds.length) : defaultCenter;
          const map = L.map(mapContainer, { attributionControl: false }).setView(center, bounds.length ? 15 : 11);
          let batchTaggingTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { attribution: '¬© OpenStreetMap contributors, ¬© CARTO', maxZoom: 22 }).addTo(map);
          let isBatchTaggingSatellite = false;
          const SatelliteToggleControl = L.Control.extend({
            onAdd: function(m) {
              const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
              const button = L.DomUtil.create('a', 'satellite-toggle-btn', container);
              button.href = '#';
              button.title = 'Switch to satellite view';
              button.innerHTML = 'üõ∞Ô∏è';
              button.style.cssText = 'width: 30px; height: 30px; line-height: 30px; text-align: center; text-decoration: none; display: block; font-size: 18px;';
              L.DomEvent.on(button, 'click', (ev) => {
                L.DomEvent.preventDefault(ev);
                map.removeLayer(batchTaggingTileLayer);
                if (isBatchTaggingSatellite) {
                  batchTaggingTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { attribution: '¬© OpenStreetMap contributors, ¬© CARTO', maxZoom: 22 });
                  button.title = 'Switch to satellite view';
                  isBatchTaggingSatellite = false;
                } else {
                  batchTaggingTileLayer = L.tileLayer('https://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', { subdomains: ['0', '1', '2', '3'], attribution: '¬© Google', maxZoom: 22 });
                  button.title = 'Switch to street map';
                  isBatchTaggingSatellite = true;
                }
                batchTaggingTileLayer.addTo(map);
              });
              return container;
            }
          });
          new SatelliteToggleControl({ position: 'topleft' }).addTo(map);
          if (bounds.length > 1) map.fitBounds(bounds, { padding: [20, 20], maxZoom: 17 });
          const addressMarkersLayer = L.layerGroup().addTo(map);
          const addressMarkers = {};
          Object.entries(addressToCoords).forEach(([addr, { lat, lon }]) => {
            const marker = L.circleMarker([lat, lon], {
              radius: 6,
              fillColor: ADDRESS_DOT_DEFAULT,
              color: ADDRESS_DOT_STROKE,
              weight: ADDRESS_DOT_STROKE_WEIGHT,
              fillOpacity: 1
            }).addTo(addressMarkersLayer).bindTooltip(addr, { permanent: false, direction: 'top' });
            addressMarkers[addr] = marker;
          });
          const polygonLayer = L.layerGroup().addTo(map);
          const latlngs = [];
          function updatePolygonDisplay() {
            polygonLayer.clearLayers();
            latlngs.forEach((ll) => {
              L.circleMarker(ll, { radius: 8, fillColor: '#2563eb', color: '#1d4ed8', weight: 2, fillOpacity: 0.9 }).addTo(polygonLayer);
            });
            if (latlngs.length >= 2) {
              const lineLatlngs = latlngs.concat([latlngs[0]]);
              L.polyline(lineLatlngs, { color: '#2563eb', weight: 2, dashArray: '5,5' }).addTo(polygonLayer);
            }
            if (mapStatusEl) mapStatusEl.textContent = latlngs.length < 3 ? 'Click to add points (need at least 3). Click the first point again to close the shape.' : 'Click the first point again to close the shape, or add more points.';
          }
          function updateAddressMarkerColors(selectedAddressSet) {
            Object.entries(addressMarkers).forEach(([addr, marker]) => {
              const selected = selectedAddressSet.has(addr);
              marker.setStyle({
                fillColor: selected ? ADDRESS_DOT_SELECTED : ADDRESS_DOT_DEFAULT,
                color: ADDRESS_DOT_STROKE,
                weight: ADDRESS_DOT_STROKE_WEIGHT
              });
            });
          }
          map.on('click', (e) => {
            if (latlngs.length >= 3 && L.latLng(e.latlng).distanceTo(L.latLng(latlngs[0])) < CLOSE_POLYGON_CLICK_METERS) {
              closePolygonAndSelect();
              return;
            }
            latlngs.push(e.latlng);
            updatePolygonDisplay();
          });
          window._batchTaggingMapState = { map, polygonLayer, latlngs, addressToCoords, addressMarkers, updatePolygonDisplay, updateAddressMarkerColors };
        }
        window._batchTaggingMapState.latlngs.length = 0;
        window._batchTaggingMapState.polygonLayer.clearLayers();
        window._batchTaggingMapState.updateAddressMarkerColors(new Set());
        window._batchTaggingMapState.updatePolygonDisplay();
      }

      function closePolygonAndSelect() {
        const state = window._batchTaggingMapState;
        if (!state || state.latlngs.length < 3) {
          if (mapStatusEl) mapStatusEl.textContent = 'Add at least 3 points, then click the first point again to close, or use "Close polygon & select".';
          return;
        }
        const ring = state.latlngs.slice();
        ring.push(ring[0]);
        const addressesInPolygon = Object.entries(state.addressToCoords)
          .filter(([_, { lat, lon }]) => pointInPolygon(lat, lon, ring))
          .map(([addr]) => addr);
        const encodedSet = new Set(addressesInPolygon.map(a => a.replace(/"/g, '&quot;')));
        listEl.querySelectorAll('.batch-tag-address-cb').forEach(cb => { cb.checked = encodedSet.has(cb.getAttribute('data-address')); });
        state.updateAddressMarkerColors(new Set(addressesInPolygon));
        state.polygonLayer.clearLayers();
        L.polygon(ring, { color: '#2563eb', weight: 2, fillColor: '#2563eb', fillOpacity: 0.2 }).addTo(state.polygonLayer);
        state.latlngs.length = 0;
        if (mapStatusEl) mapStatusEl.textContent = addressesInPolygon.length + ' address(es) selected. Choose values below and click Apply to selected addresses when ready.';
        showAppToast('Selected ' + addressesInPolygon.length + ' address(es). Choose values and click Apply when ready.');
      }

      if (drawOnMapBtn && hasLatLon) drawOnMapBtn.onclick = showMapView;
      if (mapBackBtn) mapBackBtn.onclick = () => { if (listView) listView.classList.remove('hidden'); if (mapView) mapView.classList.add('hidden'); if (mapStatusEl) mapStatusEl.textContent = ''; };
      if (mapCloseBtn) mapCloseBtn.onclick = closePolygonAndSelect;
      if (mapClearBtn) mapClearBtn.onclick = () => {
        const state = window._batchTaggingMapState;
        if (state) {
          state.latlngs.length = 0;
          state.polygonLayer.clearLayers();
          state.updateAddressMarkerColors(new Set());
          state.updatePolygonDisplay();
          listEl.querySelectorAll('.batch-tag-address-cb').forEach(cb => { cb.checked = false; });
        }
        if (mapStatusEl) mapStatusEl.textContent = '';
      };

      applyBtn.onclick = async () => {
        const selected = Array.from(listEl.querySelectorAll('.batch-tag-address-cb:checked')).map(cb => cb.getAttribute('data-address'));
        if (selected.length === 0) {
          if (statusMsg) statusMsg.textContent = 'Select at least one address.';
          return;
        }
        const damageVal = (damageSelect.value || '').trim();
        const addressPlanVal = (addressPlanSelect.value || '').trim();
        const rebuildVal = (rebuildSelect.value || '').trim();
        if (!damageVal && !addressPlanVal && !rebuildVal) {
          if (statusMsg) statusMsg.textContent = 'Choose at least one value (Damage, Address Plan, or Build Status).';
          return;
        }
        const updates = [];
        const damageColIndex = damageCol != null ? headers.indexOf(damageCol) : -1;
        const addressPlanColIndex = addressPlanCol != null ? headers.indexOf(addressPlanCol) : -1;
        const rebuildColIndex = rebuildCol != null ? headers.indexOf(rebuildCol) : -1;
        selected.forEach(addr => {
          const rows = sheetData.addressMap.get(addr);
          if (!rows) return;
          rows.forEach(row => {
            const rowIndex = row.__originalIndex;
            if (rowIndex === undefined || rowIndex === -1) return;
            const rowNum = rowIndex + 2;
            if (damageVal && damageColIndex !== -1) {
              updates.push({ range: 'Sheet1!' + indexToColumnLetter(damageColIndex) + rowNum, values: [[damageVal]] });
            }
            if (addressPlanVal && addressPlanColIndex !== -1) {
              updates.push({ range: 'Sheet1!' + indexToColumnLetter(addressPlanColIndex) + rowNum, values: [[addressPlanVal]] });
            }
            if (rebuildVal && rebuildColIndex !== -1) {
              updates.push({ range: 'Sheet1!' + indexToColumnLetter(rebuildColIndex) + rowNum, values: [[rebuildVal]] });
            }
          });
        });
        if (updates.length === 0) return;
        applyBtn.disabled = true;
        if (statusMsg) statusMsg.textContent = 'Saving‚Ä¶';
        try {
          const res = await fetch('/api/sheets/batch-update', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              sheetId: currentSheetId,
              valueInputOption: 'USER_ENTERED',
              data: updates
            })
          });
          if (!res.ok) {
            const err = await res.json().catch(() => ({}));
            throw new Error(err.message || err.error || 'Failed to save');
          }
          if (statusMsg) statusMsg.textContent = '';
          showAppToast('Tags applied to ' + selected.length + ' address(es).');
          setTimeout(() => {
            if (currentSheetUrl) loadAddressData(currentSheetUrl);
          }, 400);
        } catch (e) {
          if (statusMsg) statusMsg.textContent = 'Error: ' + (e.message || e);
        } finally {
          applyBtn.disabled = false;
        }
      };
    }

    // ============================================
    // Contact List Creator Functions
    // ============================================
    
    let currentListType = null; // 'email', 'phone', or 'walk'
    let currentListSource = null; // 'canned' or 'custom'
    let currentListData = []; // Generated list data
    let contactListCreatorInitialized = false; // Track if listeners are set up
    
    // Initialize Contact List Creator when Tools view is shown
    function initializeContactListCreator() {
      const creator = document.getElementById('contactListCreator');
      if (!creator) {
        return;
      }
      
      // Reset initialization flag so listeners can be set up fresh each time
      contactListCreatorInitialized = false;
      
      // Check if we have an error message div, or create one
      let errorDiv = creator.querySelector('.contact-list-error');
      if (!errorDiv) {
        errorDiv = document.createElement('div');
        errorDiv.className = 'contact-list-error';
        hideElement(errorDiv);
        errorDiv.style.padding = '16px';
        errorDiv.style.margin = '16px 0';
        errorDiv.style.background = 'rgba(255, 0, 0, 0.1)';
        errorDiv.style.border = '2px solid #d32f2f';
        errorDiv.style.borderRadius = '8px';
        errorDiv.style.color = '#d32f2f';
        errorDiv.style.fontWeight = '600';
        const toolModuleHeader = creator.querySelector('.tool-module-header');
        if (toolModuleHeader && toolModuleHeader.nextSibling) {
          creator.insertBefore(errorDiv, toolModuleHeader.nextSibling);
        } else {
          creator.appendChild(errorDiv);
        }
      }
      
      if (!sheetData || !sheetData.addressMap) {
        errorDiv.textContent = 'Please load a spreadsheet first to use the Contact List Creator.';
        showElement(errorDiv);
        // Hide wizard and results
        const wizard = document.getElementById('listCreatorWizard');
        const resultsStep = document.getElementById('stepListResults');
        if (wizard) hideElement(wizard);
        if (resultsStep) hideElement(resultsStep);
        return;
      }
      
      // Hide error if data is available
      hideElement(errorDiv);
      
      // Populate street filter in custom builder
      populateCustomBuilderStreets();
      
      // Set up event listeners (will be set up fresh each time)
      setupContactListCreatorListeners();
      
      // Set up "All" checkbox handlers
      setupAllCheckboxHandlers();
      
      // Reset wizard interface
      resetContactListCreator();
    }
    
    function setupAllCheckboxHandlers() {
      // Damage Status "All" checkbox
      const damageAll = document.getElementById('damageAll');
      const damageOptions = document.querySelectorAll('.damage-option');
      
      if (damageAll) {
        damageAll.addEventListener('change', (e) => {
          damageOptions.forEach(option => {
            option.checked = e.target.checked;
          });
        });
        
        // When individual options change, update "All" checkbox
        damageOptions.forEach(option => {
          option.addEventListener('change', () => {
            const allChecked = Array.from(damageOptions).every(opt => opt.checked);
            damageAll.checked = allChecked;
          });
        });
      }
      
      // Address Plan "All" checkbox (customFilterStatus)
      const statusAll = document.getElementById('statusAll');
      const statusOptions = document.querySelectorAll('.status-option');
      
      if (statusAll) {
        statusAll.addEventListener('change', (e) => {
          statusOptions.forEach(option => {
            option.checked = e.target.checked;
          });
        });
        
        // When individual options change, update "All" checkbox
        statusOptions.forEach(option => {
          option.addEventListener('change', () => {
            const allChecked = Array.from(statusOptions).every(opt => opt.checked);
            statusAll.checked = allChecked;
          });
        });
      }
    }
    
    function setupContactListCreatorListeners() {
      // Only set up once
      if (contactListCreatorInitialized) return;
      contactListCreatorInitialized = true;
      
      // Wait a bit to ensure DOM is ready
      setTimeout(() => {
        // Quick Start buttons
        const quickStartButtons = document.querySelectorAll('.quick-start-btn');
        quickStartButtons.forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const action = btn.getAttribute('data-action');
            handleQuickStart(action);
          });
        });
        
        // Purpose radio buttons (email/phone/walk)
        const purposeRadios = document.querySelectorAll('input[name="listPurpose"]');
        purposeRadios.forEach(radio => {
          radio.addEventListener('change', () => {
            if (radio.checked) {
              currentListType = radio.value;
              updateSummary();
              checkGenerateButton();
            }
          });
        });
        
        // Who radio buttons (everyone/uncontacted/followup/oldcontact/custom)
        const whoRadios = document.querySelectorAll('input[name="listWho"]');
        whoRadios.forEach(radio => {
          radio.addEventListener('change', () => {
            if (radio.checked) {
              const whoValue = radio.value;
              // Show/hide custom filters
              const customFiltersSection = document.getElementById('customFiltersSection');
              if (customFiltersSection) {
                if (whoValue === 'custom') {
                  showElement(customFiltersSection);
                } else {
                  hideElement(customFiltersSection);
                }
              }
              updateSummary();
              checkGenerateButton();
            }
          });
        });
        
        // Generate button
        const generateBtn = document.getElementById('btnGenerateList');
        if (generateBtn) {
          generateBtn.addEventListener('click', (e) => {
            e.preventDefault();
            generateListFromWizard();
          });
        }
        
        // Back to builder button (from results)
        const backToBuilder = document.getElementById('btnBackToBuilder');
        if (backToBuilder) {
          backToBuilder.addEventListener('click', (e) => {
            e.preventDefault();
            resetContactListCreator();
          });
        }
        
        // Export and print buttons
        const exportBtn = document.getElementById('btnExportList');
        if (exportBtn) {
          exportBtn.addEventListener('click', (e) => {
            e.preventDefault();
            exportListToCSV();
          });
        }
        
        const printBtn = document.getElementById('btnPrintList');
        if (printBtn) {
          printBtn.addEventListener('click', (e) => {
            e.preventDefault();
            printList();
          });
        }
        
        // Set up "All" checkbox handlers for custom filters
        setupAllCheckboxHandlers();
      }, 200);
    }
    
    function handleQuickStart(action) {
      // Parse action: "email-everyone", "phone-uncontacted", "walk-standing"
      const parts = action.split('-');
      const purpose = parts[0]; // email, phone, walk
      const who = parts[1]; // everyone, uncontacted, standing
      
      // Set purpose
      currentListType = purpose;
      const purposeRadio = document.getElementById(`purpose${purpose.charAt(0).toUpperCase() + purpose.slice(1)}`);
      if (purposeRadio) {
        purposeRadio.checked = true;
      }
      
      // Set who
      let whoValue = who;
      if (who === 'standing') {
        whoValue = 'custom';
        // Set custom filters for standing homes
        setTimeout(() => {
          const damageStanding = document.querySelector('#customFilterDamage input[value="Standing"]');
          if (damageStanding) {
            damageStanding.checked = true;
            // Uncheck "All" if it's checked
            const damageAll = document.getElementById('damageAll');
            if (damageAll && damageAll.checked) {
              damageAll.checked = false;
            }
          }
        }, 100);
      }
      
      const whoRadio = document.getElementById(`who${whoValue.charAt(0).toUpperCase() + whoValue.slice(1)}`);
      if (whoRadio) {
        whoRadio.checked = true;
        // Trigger change event to show custom filters if needed
        whoRadio.dispatchEvent(new Event('change'));
      }
      
      // Update summary and generate
      updateSummary();
      checkGenerateButton();
      
      // Auto-generate after a short delay
      setTimeout(() => {
        generateListFromWizard();
      }, 300);
    }
    
    function updateSummary() {
      const summary = document.getElementById('listSummary');
      if (!summary) return;
      
      const purposeRadio = document.querySelector('input[name="listPurpose"]:checked');
      const whoRadio = document.querySelector('input[name="listWho"]:checked');
      
      if (!purposeRadio || !whoRadio) {
        hideElement(summary);
        return;
      }
      
      showElement(summary);
      
      const purposeText = {
        'email': 'Send Emails',
        'phone': 'Make Phone Calls',
        'walk': 'Visit In Person'
      };
      
      const whoText = {
        'everyone': 'Everyone',
        'uncontacted': 'Haven\'t Contacted Yet',
        'followup': 'Need Follow-up',
        'oldcontact': 'Not Contacted Recently',
        'custom': 'Custom Selection'
      };
      
      const purposeEl = document.getElementById('summaryPurpose');
      const whoEl = document.getElementById('summaryWho');
      const filtersEl = document.getElementById('summaryFilters');
      const filtersTextEl = document.getElementById('summaryFiltersText');
      
      if (purposeEl) purposeEl.textContent = purposeText[purposeRadio.value] || '-';
      if (whoEl) whoEl.textContent = whoText[whoRadio.value] || '-';
      
      // Show filters if custom is selected
      if (whoRadio.value === 'custom') {
        const activeFilters = getActiveCustomFilters();
        if (activeFilters.length > 0) {
          showElement(filtersEl);
          filtersTextEl.textContent = activeFilters.join(', ');
        } else {
          hideElement(filtersEl);
        }
      } else {
        hideElement(filtersEl);
      }
    }
    
    function getActiveCustomFilters() {
      const filters = [];
      
      // Damage status
      const damageChecked = Array.from(document.querySelectorAll('#customFilterDamage input:checked:not([value="__all__"])'))
        .map(cb => cb.nextElementSibling.textContent.trim());
      if (damageChecked.length > 0 && damageChecked.length < 5) {
        filters.push(`Damage: ${damageChecked.join(', ')}`);
      }
      
      // Address Plan (customFilterStatus)
      const addressPlanChecked = Array.from(document.querySelectorAll('#customFilterStatus input:checked:not([value="__all__"])'))
        .map(cb => cb.nextElementSibling.textContent.trim());
      if (addressPlanChecked.length > 0 && addressPlanChecked.length < 6) {
        filters.push(`Address Plan: ${addressPlanChecked.join(', ')}`);
      }
      
      // Contact status
      const contactSelect = document.getElementById('customFilterContact');
      if (contactSelect && contactSelect.value !== 'all') {
        filters.push(`Contact: ${contactSelect.options[contactSelect.selectedIndex].text}`);
      }
      
      // Follow-up
      const followupSelect = document.getElementById('customFilterFollowup');
      if (followupSelect && followupSelect.value !== 'all') {
        filters.push(`Follow-up: ${followupSelect.options[followupSelect.selectedIndex].text}`);
      }
      
      // Street
      const streetSelect = document.getElementById('customFilterStreet');
      if (streetSelect && streetSelect.value !== 'all') {
        filters.push(`Street: ${streetSelect.value}`);
      }
      
      return filters;
    }
    
    function checkGenerateButton() {
      const generateBtn = document.getElementById('btnGenerateList');
      if (!generateBtn) return;
      
      const purposeRadio = document.querySelector('input[name="listPurpose"]:checked');
      const whoRadio = document.querySelector('input[name="listWho"]:checked');
      
      if (purposeRadio && whoRadio) {
        generateBtn.disabled = false;
      } else {
        generateBtn.disabled = true;
      }
    }
    
    function generateListFromWizard() {
      const purposeRadio = document.querySelector('input[name="listPurpose"]:checked');
      const whoRadio = document.querySelector('input[name="listWho"]:checked');
      
      if (!purposeRadio || !whoRadio) {
        alert('Please select both "What do you want to do?" and "Who do you want to contact?"');
        return;
      }
      
      currentListType = purposeRadio.value;
      const whoValue = whoRadio.value;
      
      if (whoValue === 'custom') {
        // Use custom list generator
        generateCustomList();
      } else {
        // Use canned list generator
        generateCannedList(whoValue);
      }
    }
    
    function showStep(stepId) {
      // Hide all steps
      document.querySelectorAll('.list-creator-step').forEach(step => {
        hideElement(step);
      });
      
      // Show requested step
      const step = document.getElementById(stepId);
      if (step) {
        showElement(step);
      }
    }
    
    function populateCustomBuilderStreets() {
      if (!sheetData || !sheetData.addressMap) return;
      
      const streetSelect = document.getElementById('customFilterStreet');
      if (!streetSelect) return;
      
      const streets = getUniqueStreets(Array.from(sheetData.addressMap.keys()));
      streetSelect.innerHTML = '<option value="all">All Streets</option>';
      streets.forEach(street => {
        const option = document.createElement('option');
        option.value = street;
        option.textContent = street;
        streetSelect.appendChild(option);
      });
    }
    
    function generateCannedList(type) {
      if (!sheetData || !sheetData.addressMap) return;
      
      let contacts = [];
      const headers = sheetData.headers;
      const addressMap = sheetData.addressMap;
      
      // Find relevant columns
      const nameCol = headers.find(h => 
        h.toLowerCase().includes('resident name') || 
        (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name') && 
         !h.toLowerCase().includes('first') && !h.toLowerCase().includes('last') && 
         !h.toLowerCase().includes('middle'))
      );
      const phoneCol = headers.find(h => 
        h.toLowerCase().includes('phone') && !h.toLowerCase().includes('email')
      );
      const emailCol = headers.find(h => 
        h.toLowerCase().includes('email')
      );
      const contactDateCol = headers.find(h => 
        (h.toLowerCase().includes('contact') && h.toLowerCase().includes('date')) ||
        h.toLowerCase().includes('last contact')
      );
      const followupCol = headers.find(h => 
        h.toLowerCase().includes('follow') && (h.toLowerCase().includes('up') || h.toLowerCase().includes('-up'))
      );
      const notesCol = headers.find(h => 
        h.toLowerCase().includes('note') && !h.toLowerCase().includes('contact')
      );
      const damageCol = findColumn(headers, 'damage');
      
      addressMap.forEach((rows, address) => {
        // For walk lists, only include Standing homes
        if (currentListType === 'walk') {
          const damage = getAddressDamage(address);
          if (damage !== 'Standing') {
            return;
          }
        }
        
        rows.forEach(row => {
          let include = false;
          
          if (type === 'uncontacted') {
            // Check if this person/household is uncontacted
            const hasContactDate = contactDateCol && row[contactDateCol] && String(row[contactDateCol]).trim() !== '';
            include = !hasContactDate;
          } else if (type === 'followup') {
            // Check if this person needs follow-up
            if (followupCol) {
              const followupValue = (row[followupCol] || '').toString().trim().toLowerCase();
              include = followupValue === 'true' || followupValue === 'yes' || 
                        (followupValue !== '' && followupValue !== 'false' && followupValue !== 'no');
            }
          } else if (type === 'oldcontact') {
            // Check if last contact was 2+ months ago
            if (contactDateCol && row[contactDateCol]) {
              const contactDateStr = String(row[contactDateCol]).trim();
              if (contactDateStr) {
                const contactDate = parseDate(contactDateStr);
                if (contactDate) {
                  const twoMonthsAgo = new Date();
                  twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                  include = contactDate < twoMonthsAgo;
                }
              }
            }
          }
          
          if (include) {
            const name = nameCol ? (row[nameCol] || '').trim() : '';
            const phone = phoneCol ? (row[phoneCol] || '').trim() : '';
            const email = emailCol ? (row[emailCol] || '').trim() : '';
            const notes = notesCol ? (row[notesCol] || '').trim() : '';
            
            // Only include if they have the required contact method for the list type
            if (currentListType === 'email' && !email) return;
            if (currentListType === 'phone' && !phone) return;
            
            if (name || address) {
              contacts.push({
                name: name || 'Unknown',
                address: address,
                phone: phone,
                email: email,
                notes: notes
              });
            }
          }
        });
      });
      
      currentListData = contacts;
      displayListResults(type);
    }
    
    function generateCustomList() {
      if (!sheetData || !sheetData.addressMap) return;
      
      // Get checked values from checkbox groups (excluding "All" checkbox)
      const damageFilter = Array.from(document.querySelectorAll('#customFilterDamage input[type="checkbox"]:checked'))
        .filter(cb => cb.value !== '__all__')
        .map(cb => cb.value);
      const addressPlanFilter = Array.from(document.querySelectorAll('#customFilterStatus input[type="checkbox"]:checked'))
        .filter(cb => cb.value !== '__all__')
        .map(cb => cb.value);
      const contactFilter = document.getElementById('customFilterContact').value;
      const followupFilter = document.getElementById('customFilterFollowup').value;
      const streetFilter = document.getElementById('customFilterStreet').value;
      
      let contacts = [];
      const headers = sheetData.headers;
      const addressMap = sheetData.addressMap;
      
      // Find relevant columns
      const nameCol = headers.find(h => 
        h.toLowerCase().includes('resident name') || 
        (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name') && 
         !h.toLowerCase().includes('first') && !h.toLowerCase().includes('last') && 
         !h.toLowerCase().includes('middle'))
      );
      const phoneCol = headers.find(h => 
        h.toLowerCase().includes('phone') && !h.toLowerCase().includes('email')
      );
      const emailCol = headers.find(h => 
        h.toLowerCase().includes('email')
      );
      const notesCol = headers.find(h => 
        h.toLowerCase().includes('note') && !h.toLowerCase().includes('contact')
      );
      const damageCol = findColumn(headers, 'damage');
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
      const contactDateCol = headers.find(h => 
        (h.toLowerCase().includes('contact') && h.toLowerCase().includes('date')) ||
        h.toLowerCase().includes('last contact')
      );
      const followupCol = headers.find(h => 
        h.toLowerCase().includes('follow') && (h.toLowerCase().includes('up') || h.toLowerCase().includes('-up'))
      );
      
      addressMap.forEach((rows, address) => {
        // Filter by street
        if (streetFilter !== 'all') {
          const street = extractStreet(address);
          if (street !== streetFilter) return;
        }
        
        // For walk lists, only include Standing homes
        if (currentListType === 'walk') {
          const damage = getAddressDamage(address);
          if (damage !== 'Standing') {
            return;
          }
        }
        
        rows.forEach(row => {
          // Filter by damage status
          if (damageFilter.length > 0 && damageCol) {
            const damage = (row[damageCol] || '').trim();
            // Handle "(not set)" - empty string means no value set
            const damageValue = damage === '' || damage === '(not set)' ? '' : damage;
            if (!damageFilter.includes(damageValue)) return;
          }
          
          // Filter by address plan
          if (addressPlanFilter.length > 0 && addressPlanCol) {
            const val = (row[addressPlanCol] || '').trim();
            const valNorm = val === '' || val === '(not set)' ? '' : val;
            if (!addressPlanFilter.includes(valNorm)) return;
          }
          
          // Filter by contact status
          if (contactFilter !== 'all' && contactDateCol) {
            const hasContactDate = row[contactDateCol] && String(row[contactDateCol]).trim() !== '';
            if (contactFilter === 'contacted' && !hasContactDate) return;
            if (contactFilter === 'uncontacted' && hasContactDate) return;
          }
          
          // Filter by follow-up
          if (followupFilter !== 'all' && followupCol) {
            const followupValue = (row[followupCol] || '').toString().trim().toLowerCase();
            const needsFollowup = followupValue === 'true' || followupValue === 'yes' || 
                                 (followupValue !== '' && followupValue !== 'false' && followupValue !== 'no');
            if (followupFilter === 'yes' && !needsFollowup) return;
            if (followupFilter === 'no' && needsFollowup) return;
          }
          
          const name = nameCol ? (row[nameCol] || '').trim() : '';
          const phone = phoneCol ? (row[phoneCol] || '').trim() : '';
          const email = emailCol ? (row[emailCol] || '').trim() : '';
          const notes = notesCol ? (row[notesCol] || '').trim() : '';
          
          // Only include if they have the required contact method for the list type
          if (currentListType === 'email' && !email) return;
          if (currentListType === 'phone' && !phone) return;
          
          if (name || address) {
            contacts.push({
              name: name || 'Unknown',
              address: address,
              phone: phone,
              email: email,
              notes: notes
            });
          }
        });
      });
      
      currentListData = contacts;
      displayListResults('custom');
    }
    
    function displayListResults(listType) {
      // Hide wizard, show results
      const wizard = document.getElementById('listCreatorWizard');
      const resultsStep = document.getElementById('stepListResults');
      if (wizard) hideElement(wizard);
      if (resultsStep) showElement(resultsStep);
      
      const titleEl = document.getElementById('listResultsTitle');
      const countEl = document.getElementById('listResultsCount');
      const contentEl = document.getElementById('listResultsContent');
      
      if (!titleEl || !countEl || !contentEl) return;
      
      // Set title based on list type
      const typeNames = {
        'email': 'Email List',
        'phone': 'Phone List',
        'walk': 'Walk List'
      };
      
      const listNames = {
        'uncontacted': 'Uncontacted Households',
        'followup': 'Needs Follow-up',
        'oldcontact': 'Not Contacted in 2+ Months',
        'everyone': 'Everyone',
        'custom': 'Custom List'
      };
      
      const listTypeDisplay = typeNames[currentListType] || 'Contact List';
      titleEl.textContent = `${listTypeDisplay} - ${listNames[listType]}`;
      
      // Add list type indicator below title
      let listTypeIndicator = titleEl.parentElement.querySelector('.list-type-indicator');
      if (!listTypeIndicator) {
        listTypeIndicator = document.createElement('div');
        listTypeIndicator.className = 'list-type-indicator';
        listTypeIndicator.style.cssText = 'font-size: 0.9rem; color: var(--text-light); margin-top: 4px; font-weight: 500;';
        titleEl.parentElement.insertBefore(listTypeIndicator, titleEl.nextSibling);
      }
      listTypeIndicator.textContent = `List Type: ${listTypeDisplay}`;
      
      if (currentListData.length === 0) {
        contentEl.innerHTML = '<div class="contact-list-empty">No contacts match your criteria.</div>';
        countEl.textContent = '0 contacts';
        return;
      }
      
      // Group contacts by address
      const groupedByAddress = {};
      currentListData.forEach(contact => {
        const address = contact.address || 'Unknown Address';
        if (!groupedByAddress[address]) {
          groupedByAddress[address] = [];
        }
        groupedByAddress[address].push(contact);
      });
      
      const addressCount = Object.keys(groupedByAddress).length;
      const peopleCount = currentListData.length;
      countEl.textContent = `${peopleCount} contact${peopleCount !== 1 ? 's' : ''} at ${addressCount} address${addressCount !== 1 ? 'es' : ''}`;
      
      let html = '';
      Object.keys(groupedByAddress).sort().forEach(address => {
        const contacts = groupedByAddress[address];
        html += `
          <div class="contact-list-address-group">
            <div class="contact-list-address-header">
              <div class="contact-list-address-title">${escapeHtml(address)}</div>
              <div class="contact-list-address-count">${contacts.length} ${contacts.length === 1 ? 'person' : 'people'}</div>
            </div>
            <div class="contact-list-people">
        `;
        
        contacts.forEach(contact => {
          html += `
            <div class="contact-list-person">
              <div class="contact-list-person-name">${escapeHtml(contact.name)}</div>
              <div class="contact-list-item-details">
                ${currentListType === 'email' && contact.email ? `
                  <div class="contact-list-detail-item">
                    <div class="contact-list-detail-label">Email</div>
                    <div class="contact-list-detail-value">${escapeHtml(contact.email)}</div>
                  </div>
                ` : ''}
                ${currentListType === 'phone' && contact.phone ? `
                  <div class="contact-list-detail-item">
                    <div class="contact-list-detail-label">Phone</div>
                    <div class="contact-list-detail-value">${escapeHtml(contact.phone)}</div>
                  </div>
                ` : ''}
                ${currentListType === 'walk' ? `
                  ${contact.phone ? `
                    <div class="contact-list-detail-item">
                      <div class="contact-list-detail-label">Phone</div>
                      <div class="contact-list-detail-value">${escapeHtml(contact.phone)}</div>
                    </div>
                  ` : ''}
                  ${contact.email ? `
                    <div class="contact-list-detail-item">
                      <div class="contact-list-detail-label">Email</div>
                      <div class="contact-list-detail-value">${escapeHtml(contact.email)}</div>
                    </div>
                  ` : ''}
                ` : ''}
              </div>
              ${contact.notes ? `
                <div class="contact-list-item-notes">
                  <div class="contact-list-notes-label">Notes</div>
                  <div class="contact-list-notes-value">${escapeHtml(contact.notes)}</div>
                </div>
              ` : ''}
            </div>
          `;
        });
        
        html += `
            </div>
          </div>
        `;
      });
      
      contentEl.innerHTML = html;
    }
    
    function exportListToCSV() {
      if (currentListData.length === 0) {
        alert('No data to export');
        return;
      }
      
      const headers = ['Name', 'Address'];
      if (currentListType === 'email' || currentListType === 'walk') {
        headers.push('Email');
      }
      if (currentListType === 'phone' || currentListType === 'walk') {
        headers.push('Phone');
      }
      headers.push('Notes');
      
      const rows = currentListData.map(contact => {
        const row = [contact.name, contact.address];
        if (currentListType === 'email' || currentListType === 'walk') {
          row.push(contact.email || '');
        }
        if (currentListType === 'phone' || currentListType === 'walk') {
          row.push(contact.phone || '');
        }
        row.push(contact.notes || '');
        return row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',');
      });
      
      const csv = [headers.map(h => `"${h}"`).join(','), ...rows].join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `contact-list-${currentListType}-${Date.now()}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    
    function printList() {
      const printWindow = window.open('', '_blank');
      const typeNames = {
        'email': 'Email List',
        'phone': 'Phone List',
        'walk': 'Walk List'
      };
      
      // Group contacts by address
      const groupedByAddress = {};
      currentListData.forEach(contact => {
        const address = contact.address || 'Unknown Address';
        if (!groupedByAddress[address]) {
          groupedByAddress[address] = [];
        }
        groupedByAddress[address].push(contact);
      });
      
      const addressCount = Object.keys(groupedByAddress).length;
      const peopleCount = currentListData.length;
      
      // Build HTML grouped by address
      let groupedHtml = '';
      Object.keys(groupedByAddress).sort().forEach(address => {
        const contacts = groupedByAddress[address];
        groupedHtml += `
          <div class="address-group">
            <div class="address-header">${escapeHtml(address)} <span class="address-count">(${contacts.length} ${contacts.length === 1 ? 'person' : 'people'})</span></div>
            ${contacts.map(contact => `
              <div class="contact-item">
                <div class="contact-name">${escapeHtml(contact.name)}</div>
                ${currentListType === 'email' && contact.email ? `<div class="contact-detail"><strong>Email:</strong> ${escapeHtml(contact.email)}</div>` : ''}
                ${currentListType === 'phone' && contact.phone ? `<div class="contact-detail"><strong>Phone:</strong> ${escapeHtml(contact.phone)}</div>` : ''}
                ${currentListType === 'walk' ? `
                  ${contact.phone ? `<div class="contact-detail"><strong>Phone:</strong> ${escapeHtml(contact.phone)}</div>` : ''}
                  ${contact.email ? `<div class="contact-detail"><strong>Email:</strong> ${escapeHtml(contact.email)}</div>` : ''}
                ` : ''}
                ${contact.notes ? `<div class="contact-notes"><strong>Notes:</strong> ${escapeHtml(contact.notes)}</div>` : ''}
              </div>
            `).join('')}
          </div>
        `;
      });
      
      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Contact List - ${typeNames[currentListType]}</title>
          <style>
            body { font-family: Arial, sans-serif; padding: 20px; }
            h1 { color: #283618; }
            .address-group { margin-bottom: 30px; page-break-inside: avoid; }
            .address-header { font-weight: bold; font-size: 1.3em; color: #283618; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 2px solid #283618; }
            .address-count { font-size: 0.9em; color: #666; font-weight: normal; }
            .contact-item { margin-bottom: 15px; padding: 10px; padding-left: 20px; border-left: 3px solid #606C38; }
            .contact-name { font-weight: bold; font-size: 1.1em; margin-bottom: 5px; }
            .contact-detail { margin-top: 5px; }
            .contact-notes { margin-top: 8px; font-style: italic; color: #555; }
          </style>
        </head>
        <body>
          <h1>${typeNames[currentListType]}</h1>
          <p>Total: ${peopleCount} contact${peopleCount !== 1 ? 's' : ''} at ${addressCount} address${addressCount !== 1 ? 'es' : ''}</p>
          ${groupedHtml}
        </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.focus();
      setTimeout(() => {
        printWindow.print();
      }, 250);
    }
    
    function resetContactListCreator() {
      currentListType = null;
      currentListSource = null;
      currentListData = [];
      
      // Hide results, show wizard
      const resultsStep = document.getElementById('stepListResults');
      const wizard = document.getElementById('listCreatorWizard');
      if (resultsStep) hideElement(resultsStep);
      if (wizard) showElement(wizard);
      
      // Reset form
      const purposeRadios = document.querySelectorAll('input[name="listPurpose"]');
      purposeRadios.forEach(radio => radio.checked = false);
      
      const whoRadios = document.querySelectorAll('input[name="listWho"]');
      whoRadios.forEach(radio => radio.checked = false);
      
      // Hide custom filters
      const customFiltersSection = document.getElementById('customFiltersSection');
      if (customFiltersSection) hideElement(customFiltersSection);
      
      // Hide summary
      const summary = document.getElementById('listSummary');
      if (summary) hideElement(summary);
      
      // Disable generate button
      const generateBtn = document.getElementById('btnGenerateList');
      if (generateBtn) generateBtn.disabled = true;
      
      // Reset custom filters
      document.querySelectorAll('#customFilterDamage input, #customFilterStatus input').forEach(cb => {
        if (cb.value === '__all__') {
          cb.checked = true;
        } else {
          cb.checked = false;
        }
      });
      
      const contactSelect = document.getElementById('customFilterContact');
      if (contactSelect) contactSelect.value = 'all';
      
      const followupSelect = document.getElementById('customFilterFollowup');
      if (followupSelect) followupSelect.value = 'all';
      
      const streetSelect = document.getElementById('customFilterStreet');
      if (streetSelect) streetSelect.value = 'all';
    }
    
    // parseDate and escapeHtml moved to js/utils.js
    
    // ============================================
    // Zone Report Generator Functions
    // ============================================
    
    // Initialize Zone Report Generator
    function initializeZoneReportGenerator() {
      const generateBtn = document.getElementById('btnGenerateReport');
      const exportBtn = document.getElementById('btnExportReportPDF');
      
      if (generateBtn) {
        // Remove existing listeners to avoid duplicates
        const newGenerateBtn = generateBtn.cloneNode(true);
        generateBtn.parentNode.replaceChild(newGenerateBtn, generateBtn);
        newGenerateBtn.addEventListener('click', function(e) {
          e.preventDefault();
          generateZoneReport();
        });
      }
      
      if (exportBtn) {
        const newExportBtn = exportBtn.cloneNode(true);
        exportBtn.parentNode.replaceChild(newExportBtn, exportBtn);
        newExportBtn.addEventListener('click', function(e) {
          e.preventDefault();
          exportReportToPDF();
        });
      }
    }
    
    // Generate comprehensive zone report
    function generateZoneReport() {
      const statusEl = document.getElementById('zoneReportStatus');
      const container = document.getElementById('zoneReportContainer');
      const content = document.getElementById('zoneReportContent');
      
      if (!sheetData || !sheetData.addressMap) {
        if (statusEl) {
          statusEl.textContent = 'Please load a spreadsheet first.';
          statusEl.className = 'zone-report-status error';
        }
        alert('Please load a spreadsheet first to generate a zone report.');
        return;
      }
      
      if (statusEl) {
        statusEl.textContent = 'Generating report...';
        statusEl.className = 'zone-report-status loading';
      }
      
      try {
        const { html: report, stats } = buildZoneReport();
        if (content) {
          content.innerHTML = report;
        }
        if (container) {
          container.classList.remove('hidden');
          // Scroll to report
          container.scrollIntoView({ behavior: 'smooth', block: 'start' });
          // Create charts after a short delay to ensure DOM is ready
          setTimeout(() => {
            if (typeof Chart !== 'undefined') {
              createReportCharts(stats);
            } else {
              console.error('Chart.js is not loaded');
            }
          }, 200);
        }
        if (statusEl) {
          statusEl.textContent = 'Report generated successfully!';
          statusEl.className = 'zone-report-status';
          setTimeout(() => {
            statusEl.textContent = '';
          }, 3000);
        }
      } catch (error) {
        console.error('Error generating report:', error);
        if (statusEl) {
          statusEl.textContent = 'Error generating report: ' + error.message;
          statusEl.className = 'zone-report-status error';
        }
        alert('Error generating report: ' + error.message);
      }
    }
    
    // Build the complete zone report HTML
    function buildZoneReport() {
      const headers = sheetData.headers;
      const addressMap = sheetData.addressMap;
      const allRows = Array.from(addressMap.values()).flat();
      
      // Find all relevant columns
      const nameCol = headers.find(h => 
        h.toLowerCase().includes('resident name') || 
        (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name') && 
         !h.toLowerCase().includes('first') && !h.toLowerCase().includes('last') && 
         !h.toLowerCase().includes('middle'))
      );
      const phoneCol = headers.find(h => 
        h.toLowerCase().includes('phone') && !h.toLowerCase().includes('email')
      );
      const emailCol = findColumn(headers, 'email');
      const damageCol = findColumn(headers, 'damage');
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
      const contactDateCol = headers.find(h => 
        (h.toLowerCase().includes('contact') && h.toLowerCase().includes('date')) ||
        h.toLowerCase().includes('last contact')
      );
      const followupCol = headers.find(h => 
        h.toLowerCase().includes('follow') && (h.toLowerCase().includes('up') || h.toLowerCase().includes('-up'))
      );
      const notesCol = headers.find(h => 
        h.toLowerCase().includes('note') && !h.toLowerCase().includes('contact')
      );
      const contactNotesCol = headers.find(h => 
        h.toLowerCase().includes('contact') && h.toLowerCase().includes('note')
      );
      const ncNameCol = findColumn(headers, 'nc name');
      const ncPhoneCol = findColumn(headers, 'nc phone');
      const ncEmailCol = findColumn(headers, 'nc email');
      
      // Parse captains for display
      let captains = [];
      if (ncNameCol && allRows.length > 0) {
        const firstRow = allRows[0];
        const ncName = firstRow[ncNameCol] ? (firstRow[ncNameCol] || '').trim() : '';
        const ncPhone = ncPhoneCol ? (firstRow[ncPhoneCol] || '').trim() : '';
        const ncEmail = ncEmailCol ? (firstRow[ncEmailCol] || '').trim() : '';
        captains = parseCaptains(ncName, ncPhone, ncEmail);
      }
      
      // Calculate statistics
      const stats = calculateZoneStatistics(headers, addressMap);
      
      // Get current date
      const reportDate = new Date().toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      });
      
      // Get zone name for title
      const zoneName = currentZoneName ? currentZoneName.trim() : 'Zone';
      const reportTitle = `${zoneName} Report`;
      
      let html = `
        <div class="zone-report-header">
          <h1 class="zone-report-title">${escapeHtml(reportTitle)}</h1>
          <p class="zone-report-subtitle">Comprehensive Zone Analysis & Data Summary</p>
          <div class="zone-report-meta">Generated: ${reportDate}</div>
        </div>
        
        <!-- Executive Summary -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Executive Summary</h2>
          <div class="zone-report-stats-grid">
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.totalAddresses}</div>
              <div class="zone-report-stat-label">Total Addresses</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.totalPeople}</div>
              <div class="zone-report-stat-label">Total People</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.contactedAddresses}</div>
              <div class="zone-report-stat-label">Contacted Addresses</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.uncontactedAddresses}</div>
              <div class="zone-report-stat-label">Uncontacted Addresses</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.contactRate}%</div>
              <div class="zone-report-stat-label">Contact Rate</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.followupCount}</div>
              <div class="zone-report-stat-label">Follow-ups Needed</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.uniquePhoneCount}</div>
              <div class="zone-report-stat-label">Unique Phone Numbers</div>
            </div>
            <div class="zone-report-stat-card">
              <div class="zone-report-stat-value">${stats.uniqueEmailCount}</div>
              <div class="zone-report-stat-label">Unique Email Addresses</div>
            </div>
          </div>
        </div>
        
        <!-- Zone Information -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Zone Information</h2>
          <div class="zone-report-subsection">
            <h3 class="zone-report-subsection-title">Neighborhood Captain${captains.length > 1 ? 's' : ''}</h3>
            ${captains.length > 0 ? `
              <div style="display: flex; flex-direction: column; gap: 20px;">
                ${captains.map((captain, index) => `
                  <div style="padding: 16px; background: rgba(96, 108, 56, 0.05); border-radius: 8px; border: 2px solid rgba(96, 108, 56, 0.2);">
                    <div style="font-weight: 700; font-size: 1.1rem; color: var(--primary-dark); margin-bottom: 12px; font-family: 'Chivo', sans-serif;">
                      ${escapeHtml(captain.name)}
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 8px; font-size: 0.95rem;">
                      ${captain.phone !== 'N/A' ? `
                        <div style="display: flex; align-items: center; gap: 8px;">
                          <span style="color: var(--text-light); font-weight: 600;">Phone:</span>
                          <span style="color: var(--primary);">${escapeHtml(captain.phone)}</span>
                        </div>
                      ` : ''}
                      ${captain.email !== 'N/A' ? `
                        <div style="display: flex; align-items: center; gap: 8px;">
                          <span style="color: var(--text-light); font-weight: 600;">Email:</span>
                          <span style="color: var(--primary); word-break: break-word;">${escapeHtml(captain.email)}</span>
                        </div>
                      ` : ''}
                    </div>
                  </div>
                `).join('')}
              </div>
            ` : '<p>No neighborhood captains assigned to this zone</p>'}
          </div>
        </div>
        
        <!-- Damage Analysis -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Damage Status Analysis</h2>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 24px; align-items: start;">
            <div>
              <div class="zone-report-stats-grid">
                ${Object.entries(stats.damageBreakdown).map(([damage, count]) => `
                  <div class="zone-report-stat-card">
                    <div class="zone-report-stat-value">${count}</div>
                    <div class="zone-report-stat-label">${damage || 'Not Set'}</div>
                  </div>
                `).join('')}
              </div>
              <div class="zone-report-insight" style="margin-top: 20px;">
                <div class="zone-report-insight-title">üí° Insight</div>
                <div class="zone-report-insight-text">
                  ${stats.damageBreakdown['Standing'] || 0} addresses are standing (${stats.totalAddresses > 0 ? Math.round((stats.damageBreakdown['Standing'] || 0) / stats.totalAddresses * 100) : 0}% of total).
                  ${stats.damageBreakdown['Total Loss'] || 0} addresses are total losses (${stats.totalAddresses > 0 ? Math.round((stats.damageBreakdown['Total Loss'] || 0) / stats.totalAddresses * 100) : 0}% of total).
                </div>
              </div>
            </div>
            <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <h3 style="margin: 0 0 16px 0; color: var(--primary-dark); font-size: 1.2rem; text-align: center;">Damage Distribution</h3>
              <canvas id="reportDamageChart" style="max-height: 600px; max-width: 100%; height: 600px !important;"></canvas>
            </div>
          </div>
        </div>
        
        <!-- Address Plan Analysis -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Address Plan Analysis</h2>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 24px; align-items: start;">
            <div>
              <div class="zone-report-stats-grid">
                ${Object.entries(stats.addressPlanBreakdown || {}).map(([status, count]) => `
                  <div class="zone-report-stat-card">
                    <div class="zone-report-stat-value">${count}</div>
                    <div class="zone-report-stat-label">${status || 'Not Set'}</div>
                  </div>
                `).join('')}
              </div>
            </div>
            <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <h3 style="margin: 0 0 16px 0; color: var(--primary-dark); font-size: 1.2rem; text-align: center;">Address Plan Distribution</h3>
              <canvas id="reportStatusChart" style="max-height: 600px; max-width: 100%; height: 600px !important;"></canvas>
            </div>
          </div>
        </div>
        
        <!-- Build Status Analysis -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Build Status</h2>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 24px; align-items: start;">
            <div>
              <div class="zone-report-stats-grid">
                ${Object.entries(stats.rebuildBreakdown || {}).map(([rebuild, count]) => `
                  <div class="zone-report-stat-card">
                    <div class="zone-report-stat-value">${count}</div>
                    <div class="zone-report-stat-label">${rebuild || 'Not Set'}</div>
                  </div>
                `).join('')}
              </div>
            </div>
            <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <h3 style="margin: 0 0 16px 0; color: var(--primary-dark); font-size: 1.2rem; text-align: center;">Build Status Distribution</h3>
              <canvas id="reportRebuildChart" style="max-height: 800px; max-width: 100%; height: 800px !important;"></canvas>
            </div>
          </div>
        </div>
        
        <!-- Contact Analysis Chart -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Contact Analysis</h2>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 24px; align-items: start;">
            <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <h3 style="margin: 0 0 16px 0; color: var(--primary-dark); font-size: 1.2rem; text-align: center;">Contact Status</h3>
              <canvas id="reportContactChart" style="max-height: 600px; max-width: 100%; height: 600px !important;"></canvas>
            </div>
            <div>
              <div class="zone-report-subsection">
                <h3 class="zone-report-subsection-title">Contact Timeline</h3>
                <table class="zone-report-table">
                  <tr>
                    <th>Time Period</th>
                    <th>Addresses Contacted</th>
                  </tr>
                  ${Object.entries(stats.contactTimeline).map(([period, count]) => `
                    <tr>
                      <td>${period}</td>
                      <td>${count}</td>
                    </tr>
                  `).join('')}
                </table>
              </div>
            </div>
          </div>
        
          ${stats.followupPeople.length > 0 ? `
            <div class="zone-report-subsection" style="margin-top: 24px;">
              <h3 class="zone-report-subsection-title">Follow-up Needed (${stats.followupPeople.length} people)</h3>
              <ul class="zone-report-list">
                ${stats.followupPeople.slice(0, 20).map(person => `
                  <li class="zone-report-list-item">
                    <strong>${escapeHtml(person.name)}</strong> - ${escapeHtml(person.address)}
                  </li>
                `).join('')}
                ${stats.followupPeople.length > 20 ? `<li style="padding: 12px; font-style: italic; color: var(--text-light);">... and ${stats.followupPeople.length - 20} more</li>` : ''}
              </ul>
            </div>
          ` : ''}
        </div>
        
        <!-- Street Analysis -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Street-by-Street Breakdown</h2>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin-bottom: 24px; align-items: start;">
            <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <h3 style="margin: 0 0 16px 0; color: var(--primary-dark); font-size: 1.2rem; text-align: center;">Addresses by Street</h3>
              <canvas id="reportStreetChart" style="max-height: 500px; max-width: 100%; height: 500px !important;"></canvas>
            </div>
            <div>
              <table class="zone-report-table">
                <tr>
                  <th>Street</th>
                  <th>Addresses</th>
                  <th>People</th>
                  <th>Contacted</th>
                  <th>Contact Rate</th>
                </tr>
                ${Object.entries(stats.streetStats).sort((a, b) => b[1].addresses - a[1].addresses).map(([street, data]) => `
                  <tr>
                    <td><strong>${escapeHtml(street || 'Unknown')}</strong></td>
                    <td>${data.addresses}</td>
                    <td>${data.people}</td>
                    <td>${data.contacted}</td>
                    <td>${data.contactRate}%</td>
                  </tr>
                `).join('')}
              </table>
            </div>
          </div>
        </div>
        
        <!-- Data Completeness -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Data Completeness Analysis</h2>
          <table class="zone-report-table">
            <tr>
              <th>Field</th>
              <th>Complete</th>
              <th>Missing</th>
              <th>Completion Rate</th>
            </tr>
            ${Object.entries(stats.dataCompleteness).map(([field, data]) => `
              <tr>
                <td><strong>${field}</strong></td>
                <td>${data.complete}</td>
                <td>${data.missing}</td>
                <td>${data.rate}%</td>
              </tr>
            `).join('')}
          </table>
        </div>
        
        <!-- Additional Insights -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Key Insights & Recommendations</h2>
          ${generateInsights(stats)}
        </div>
        
        <!-- Detailed Address List -->
        <div class="zone-report-section">
          <h2 class="zone-report-section-title">Complete Address Directory</h2>
          ${Array.from(addressMap.keys()).sort().map(address => {
            const rows = addressMap.get(address);
            const damage = getAddressDamage(address);
            const addressPlan = getAddressPlan(address);
            const statusDisplay = addressPlan || '';
            const isContacted = rows.some(row => {
              if (contactDateCol && row[contactDateCol]) {
                return String(row[contactDateCol]).trim() !== '';
              }
              return false;
            });
            
            return `
              <div class="zone-report-subsection" style="margin-bottom: 24px; padding: 16px; background: rgba(96, 108, 56, 0.03); border-radius: 6px;">
                <h4 style="margin: 0 0 12px 0; color: var(--primary-dark); font-size: 1.2rem; font-family: 'Chivo', sans-serif;">
                  ${escapeHtml(address)}
                  ${damage ? `<span class="zone-report-badge ${damage.toLowerCase().replace(/\s+/g, '')}">${escapeHtml(damage)}</span>` : ''}
                  ${statusDisplay ? `<span class="zone-report-badge ${statusDisplay.toLowerCase().replace(/\s+/g, '').replace(/[‚Ä¢\/]/g, '')}">${escapeHtml(statusDisplay)}</span>` : ''}
                  ${isContacted ? '<span class="zone-report-badge" style="background: rgba(76, 175, 80, 0.2); color: #2e7d32;">Contacted</span>' : '<span class="zone-report-badge" style="background: rgba(244, 67, 54, 0.2); color: #b71c1c;">Uncontacted</span>'}
                </h4>
                <table class="zone-report-table" style="font-size: 0.85rem;">
                  <tr>
                    ${nameCol ? '<th>Name</th>' : ''}
                    ${phoneCol ? '<th>Phone</th>' : ''}
                    ${emailCol ? '<th>Email</th>' : ''}
                    ${contactDateCol ? '<th>Last Contact</th>' : ''}
                    ${followupCol ? '<th>Follow-up</th>' : ''}
                    ${notesCol ? '<th>Notes</th>' : ''}
                  </tr>
                  ${rows.map(row => `
                    <tr>
                      ${nameCol ? `<td>${escapeHtml(row[nameCol] || '')}</td>` : ''}
                      ${phoneCol ? `<td>${escapeHtml(row[phoneCol] || '')}</td>` : ''}
                      ${emailCol ? `<td>${escapeHtml(row[emailCol] || '')}</td>` : ''}
                      ${contactDateCol ? `<td>${escapeHtml(row[contactDateCol] || '')}</td>` : ''}
                      ${followupCol ? `<td>${(row[followupCol] || '').toString().toLowerCase().includes('yes') || (row[followupCol] || '').toString().toLowerCase().includes('true') ? 'Yes' : 'No'}</td>` : ''}
                      ${notesCol ? `<td style="max-width: 300px; word-wrap: break-word;">${escapeHtml(row[notesCol] || '')}</td>` : ''}
                    </tr>
                  `).join('')}
                </table>
                ${contactNotesCol && rows.some(r => r[contactNotesCol]) ? `
                  <div style="margin-top: 12px; padding: 12px; background: rgba(221, 161, 94, 0.1); border-radius: 4px;">
                    <strong>Contact Notes:</strong>
                    ${rows.filter(r => r[contactNotesCol]).map(r => escapeHtml(r[contactNotesCol])).join('; ')}
                  </div>
                ` : ''}
              </div>
            `;
          }).join('')}
        </div>
      `;
      
      return { html, stats };
    }
    
    // Calculate comprehensive zone statistics
    function calculateZoneStatistics(headers, addressMap) {
      const stats = {
        totalAddresses: addressMap.size,
        totalPeople: 0,
        contactedAddresses: 0,
        uncontactedAddresses: 0,
        contactRate: 0,
        followupCount: 0,
        followupPeople: [],
        damageBreakdown: {},
        addressPlanBreakdown: {},
        rebuildBreakdown: {},
        contactTimeline: {
          'Last 7 days': 0,
          'Last 30 days': 0,
          'Last 90 days': 0,
          'Over 90 days ago': 0,
          'Never contacted': 0
        },
        streetStats: {},
        dataCompleteness: {},
        uniquePhoneCount: 0,
        uniqueEmailCount: 0
      };
      
      // Find columns
      const nameCol = headers.find(h => 
        h.toLowerCase().includes('resident name') || 
        (h.toLowerCase().includes('name') && !h.toLowerCase().includes('nc name') && 
         !h.toLowerCase().includes('first') && !h.toLowerCase().includes('last') && 
         !h.toLowerCase().includes('middle'))
      );
      const phoneCol = headers.find(h => 
        h.toLowerCase().includes('phone') && !h.toLowerCase().includes('email')
      );
      const emailCol = findColumn(headers, 'email');
      const damageCol = findColumn(headers, 'damage');
      const addressPlanCol = findColumn(headers, ['address', 'plan'], ['note']);
      const rebuildCol = findColumn(headers, ['build', 'status'], ['intent']);
      const contactDateCol = headers.find(h => 
        (h.toLowerCase().includes('contact') && h.toLowerCase().includes('date')) ||
        h.toLowerCase().includes('last contact')
      );
      const followupCol = headers.find(h => 
        h.toLowerCase().includes('follow') && (h.toLowerCase().includes('up') || h.toLowerCase().includes('-up'))
      );
      
      const now = new Date();
      const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
      
      addressMap.forEach((rows, address) => {
        stats.totalPeople += rows.length;
        
        // Damage breakdown
        const damage = getAddressDamage(address);
        stats.damageBreakdown[damage || 'Not Set'] = (stats.damageBreakdown[damage || 'Not Set'] || 0) + 1;
        
        // Address Plan breakdown (for Partial/Total Loss addresses)
        const addressPlan = getAddressPlan(address);
        stats.addressPlanBreakdown = stats.addressPlanBreakdown || {};
        stats.addressPlanBreakdown[addressPlan || 'Not Set'] = (stats.addressPlanBreakdown[addressPlan || 'Not Set'] || 0) + 1;
        
        // Rebuild status breakdown
        if (rebuildCol && rows.length > 0) {
          const rebuildValue = (rows[0][rebuildCol] || '').trim();
          const rebuildStatus = rebuildValue || 'Not Started';
          stats.rebuildBreakdown[rebuildStatus] = (stats.rebuildBreakdown[rebuildStatus] || 0) + 1;
        } else {
          stats.rebuildBreakdown['Not Started'] = (stats.rebuildBreakdown['Not Started'] || 0) + 1;
        }
        
        // Contact analysis
        let isContacted = false;
        let lastContactDate = null;
        
        rows.forEach(row => {
          if (contactDateCol && row[contactDateCol]) {
            const dateStr = String(row[contactDateCol]).trim();
            if (dateStr) {
              isContacted = true;
              const contactDate = parseDate(dateStr);
              if (contactDate && (!lastContactDate || contactDate > lastContactDate)) {
                lastContactDate = contactDate;
              }
            }
          }
          
          // Follow-up tracking
          if (followupCol) {
            const followupValue = (row[followupCol] || '').toString().trim().toLowerCase();
            const needsFollowup = followupValue === 'true' || followupValue === 'yes' || 
                                 (followupValue !== '' && followupValue !== 'false' && followupValue !== 'no');
            if (needsFollowup) {
              stats.followupCount++;
              const personName = nameCol ? (row[nameCol] || '').trim() : '';
              if (personName) {
                stats.followupPeople.push({ name: personName, address: address });
              }
            }
          }
        });
        
        if (isContacted) {
          stats.contactedAddresses++;
          if (lastContactDate) {
            if (lastContactDate >= sevenDaysAgo) {
              stats.contactTimeline['Last 7 days']++;
            } else if (lastContactDate >= thirtyDaysAgo) {
              stats.contactTimeline['Last 30 days']++;
            } else if (lastContactDate >= ninetyDaysAgo) {
              stats.contactTimeline['Last 90 days']++;
            } else {
              stats.contactTimeline['Over 90 days ago']++;
            }
          }
        } else {
          stats.uncontactedAddresses++;
          stats.contactTimeline['Never contacted']++;
        }
        
        // Street statistics
        const street = extractStreet(address);
        if (!stats.streetStats[street]) {
          stats.streetStats[street] = { addresses: 0, people: 0, contacted: 0 };
        }
        stats.streetStats[street].addresses++;
        stats.streetStats[street].people += rows.length;
        if (isContacted) {
          stats.streetStats[street].contacted++;
        }
      });
      
      // Calculate contact rates
      stats.contactRate = stats.totalAddresses > 0 
        ? Math.round((stats.contactedAddresses / stats.totalAddresses) * 100) 
        : 0;
      
      Object.keys(stats.streetStats).forEach(street => {
        const streetData = stats.streetStats[street];
        streetData.contactRate = streetData.addresses > 0 
          ? Math.round((streetData.contacted / streetData.addresses) * 100) 
          : 0;
      });
      
      // Data completeness
      const allRows = Array.from(addressMap.values()).flat();
      const totalRows = allRows.length;
      
      if (nameCol) {
        const complete = allRows.filter(r => r[nameCol] && String(r[nameCol]).trim()).length;
        stats.dataCompleteness['Resident Name'] = {
          complete,
          missing: totalRows - complete,
          rate: totalRows > 0 ? Math.round((complete / totalRows) * 100) : 0
        };
      }
      
      if (phoneCol) {
        const complete = allRows.filter(r => r[phoneCol] && String(r[phoneCol]).trim()).length;
        stats.dataCompleteness['Phone'] = {
          complete,
          missing: totalRows - complete,
          rate: totalRows > 0 ? Math.round((complete / totalRows) * 100) : 0
        };
      }
      
      if (emailCol) {
        const complete = allRows.filter(r => r[emailCol] && String(r[emailCol]).trim()).length;
        stats.dataCompleteness['Email'] = {
          complete,
          missing: totalRows - complete,
          rate: totalRows > 0 ? Math.round((complete / totalRows) * 100) : 0
        };
      }
      
      if (damageCol) {
        const complete = allRows.filter(r => r[damageCol] && String(r[damageCol]).trim()).length;
        stats.dataCompleteness['Damage Status'] = {
          complete,
          missing: totalRows - complete,
          rate: totalRows > 0 ? Math.round((complete / totalRows) * 100) : 0
        };
      }
      
      if (addressPlanCol) {
        const complete = allRows.filter(r => r[addressPlanCol] && String(r[addressPlanCol]).trim()).length;
        stats.dataCompleteness['Address Plan'] = {
          complete,
          missing: totalRows - complete,
          rate: totalRows > 0 ? Math.round((complete / totalRows) * 100) : 0
        };
      }
      
      // Count unique phone numbers from all phone columns
      const allPhoneCols = headers.filter(h => {
        const lower = h.toLowerCase();
        return (lower.includes('phone') || lower.includes('cell') || lower.includes('mobile')) && 
               !lower.includes('nc phone') && 
               !lower.includes('email');
      });
      const uniquePhones = new Set();
      allRows.forEach(row => {
        allPhoneCols.forEach(col => {
          const phone = row[col] ? String(row[col]).trim() : '';
          if (phone) {
            // Normalize phone number (remove common formatting for better uniqueness)
            const normalized = phone.replace(/[\s\-\(\)\.]/g, '').toLowerCase();
            if (normalized.length >= 10) { // Only count valid-looking phone numbers
              uniquePhones.add(normalized);
            }
          }
        });
      });
      stats.uniquePhoneCount = uniquePhones.size;
      
      // Count unique email addresses from all email columns
      const allEmailCols = headers.filter(h => {
        const lower = h.toLowerCase();
        return lower.includes('email') && !lower.includes('nc email');
      });
      const uniqueEmails = new Set();
      allRows.forEach(row => {
        allEmailCols.forEach(col => {
          const email = row[col] ? String(row[col]).trim() : '';
          if (email && email.includes('@')) { // Basic email validation
            uniqueEmails.add(email.toLowerCase()); // Case-insensitive
          }
        });
      });
      stats.uniqueEmailCount = uniqueEmails.size;
      
      return stats;
    }
    
    // Generate insights based on statistics
    function generateInsights(stats) {
      const insights = [];
      
      if (stats.contactRate < 50) {
        insights.push({
          title: 'Low Contact Rate',
          text: `Only ${stats.contactRate}% of addresses have been contacted. Consider prioritizing outreach to uncontacted addresses.`
        });
      }
      
      if (stats.uncontactedAddresses > 0) {
        insights.push({
          title: 'Uncontacted Addresses',
          text: `There are ${stats.uncontactedAddresses} uncontacted addresses. These should be prioritized for initial outreach.`
        });
      }
      
      if (stats.followupCount > 0) {
        insights.push({
          title: 'Follow-ups Needed',
          text: `${stats.followupCount} people need follow-up contact. Review the follow-up list to ensure timely responses.`
        });
      }
      
      if (stats.contactTimeline['Over 90 days ago'] > 0) {
        insights.push({
          title: 'Stale Contacts',
          text: `${stats.contactTimeline['Over 90 days ago']} addresses were last contacted over 90 days ago. Consider re-engaging these households.`
        });
      }
      
      const standingCount = stats.damageBreakdown['Standing'] || 0;
      if (standingCount > 0 && standingCount < stats.totalAddresses * 0.5) {
        insights.push({
          title: 'Damage Distribution',
          text: `Only ${standingCount} addresses (${Math.round(standingCount / stats.totalAddresses * 100)}%) are standing. The zone has significant damage requiring attention.`
        });
      }
      
      const buildingCount = stats.addressPlanBreakdown?.['Building'] || stats.addressPlanBreakdown?.['Rebuilding'] || 0;
      if (buildingCount > 0) {
        insights.push({
          title: 'Building Activity',
          text: `${buildingCount} households are building. These may need ongoing support and resources.`
        });
      }
      
      return insights.map(insight => `
        <div class="zone-report-insight">
          <div class="zone-report-insight-title">${insight.title}</div>
          <div class="zone-report-insight-text">${insight.text}</div>
        </div>
      `).join('');
    }
    
    // Export report to PDF
    function exportReportToPDF() {
      const content = document.getElementById('zoneReportContent');
      if (!content) {
        alert('Please generate a report first.');
        return;
      }
      
      // Use html2pdf library if available, otherwise use browser print
      if (typeof html2pdf !== 'undefined') {
        // Wait a moment to ensure charts are fully rendered
        setTimeout(() => {
          // Clone the content to avoid modifying the original
          const clonedContent = content.cloneNode(true);
          
          // Convert Chart.js canvases to static images
          // This ensures charts appear in the PDF
          const canvases = content.querySelectorAll('canvas[id^="report"]');
          const canvasImages = new Map();
          
          canvases.forEach((canvas) => {
            try {
              const dataURL = canvas.toDataURL('image/png', 1.0);
              canvasImages.set(canvas.id, dataURL);
            } catch (e) {
              console.warn('Could not convert canvas to image:', e);
            }
          });
          
          // Replace canvas elements in cloned content with img elements
          canvasImages.forEach((dataURL, canvasId) => {
            const clonedCanvas = clonedContent.querySelector(`canvas#${canvasId}`);
            if (clonedCanvas) {
              const img = document.createElement('img');
              img.src = dataURL;
              img.style.maxWidth = '100%';
              img.style.height = 'auto';
              img.style.display = 'block';
              // Preserve the original canvas dimensions
              const computedStyle = window.getComputedStyle(clonedCanvas);
              if (computedStyle.width) img.style.width = computedStyle.width;
              if (computedStyle.height) img.style.height = computedStyle.height;
              clonedCanvas.parentNode.replaceChild(img, clonedCanvas);
            }
          });
          
          // Create a temporary container for the cloned content
          const tempContainer = document.createElement('div');
          tempContainer.style.cssText = 'position: absolute; left: -9999px; top: 0; width: 100%;';
          tempContainer.appendChild(clonedContent);
          document.body.appendChild(tempContainer);
          
          const opt = {
            margin: [10, 10, 10, 10],
            filename: `zone-report-${new Date().toISOString().split('T')[0]}.pdf`,
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { 
              scale: 1.5, // Reduced from 2 to prevent canvas size issues
              useCORS: true, 
              logging: false,
              allowTaint: true
            },
            jsPDF: { unit: 'mm', format: 'letter', orientation: 'landscape' },
            pagebreak: { 
              mode: ['avoid-all', 'css'],
              avoid: ['.zone-report-section', '.zone-report-section-title', '.zone-report-table']
            }
          };
          
          html2pdf().set(opt).from(clonedContent).save().then(() => {
            // Clean up temporary container
            if (tempContainer.parentNode) {
              document.body.removeChild(tempContainer);
            }
          }).catch((error) => {
            console.error('PDF export error:', error);
            // Clean up on error
            if (tempContainer.parentNode) {
              document.body.removeChild(tempContainer);
            }
          });
        }, 500); // Wait 500ms for charts to fully render
      } else {
        // Fallback to print dialog
        alert('PDF export library not available. Please use browser print instead.');
      }
    }
    
    // Create charts for the report
    function createReportCharts(stats) {
      if (typeof Chart === 'undefined') {
        console.error('Chart.js is not available');
        return;
      }
      
      if (!stats) {
        console.error('Stats object is missing');
        return;
      }
      
      // Damage Chart
      const damageCtx = document.getElementById('reportDamageChart');
      if (damageCtx && stats.damageBreakdown) {
        const damageLabels = Object.keys(stats.damageBreakdown);
        const damageData = Object.values(stats.damageBreakdown);
        const damageTotal = damageData.reduce((a, b) => a + b, 0);
        const damageLabelsWithPct = damageLabels.map((label, index) => {
          const value = damageData[index];
          const pct = damageTotal > 0 ? ((value / damageTotal) * 100).toFixed(1) : '0';
          return `${label || 'Not Set'} (${pct}%)`;
        });
        // Map damage status to map pin colors
        const getDamageColor = (label) => {
          const labelLower = (label || '').toLowerCase();
          if (labelLower.includes('total')) return '#bc455a'; // Red - total loss
          if (labelLower.includes('partial')) return '#fdba77'; // Yellow - partial loss
          if (labelLower.includes('standing')) return '#81bdc3'; // Blue - standing
          return '#e5e5e5'; // Pale green/gray - unknown
        };
        const damageColors = damageLabels.map(label => getDamageColor(label));
        
        new Chart(damageCtx, {
          type: 'pie',
          data: {
            labels: damageLabelsWithPct,
            datasets: [{
              data: damageData,
              backgroundColor: damageColors,
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 1,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 12,
                labels: {
                  padding: 12,
                  font: { size: 16 },
                  boxWidth: 20,
                  boxHeight: 20
                }
              },
              tooltip: {
                titleFont: { size: 18 },
                bodyFont: { size: 16 },
                padding: 12,
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }
      
      // Status Chart
      const statusCtx = document.getElementById('reportStatusChart');
      if (statusCtx && stats.addressPlanBreakdown) {
        const statusLabels = Object.keys(stats.addressPlanBreakdown);
        const statusData = Object.values(stats.addressPlanBreakdown);
        const statusTotal = statusData.reduce((a, b) => a + b, 0);
        const statusLabelsWithPct = statusLabels.map((label, index) => {
          const value = statusData[index];
          const pct = statusTotal > 0 ? ((value / statusTotal) * 100).toFixed(1) : '0';
          return `${label || 'Not Set'} (${pct}%)`;
        });
        const statusColors = ['#afc892', '#81bdc3', '#fdba77', '#f6cf98', '#bc455a', '#e5e5e5', '#f9d6d3'];
        
        new Chart(statusCtx, {
          type: 'pie',
          data: {
            labels: statusLabelsWithPct,
            datasets: [{
              data: statusData,
              backgroundColor: statusColors.slice(0, statusLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 1,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 12,
                labels: {
                  padding: 12,
                  font: { size: 16 },
                  boxWidth: 20,
                  boxHeight: 20
                }
              },
              tooltip: {
                titleFont: { size: 18 },
                bodyFont: { size: 16 },
                padding: 12,
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    const labelWithoutPct = context.label.replace(/\s*\([^)]*\)\s*$/, '');
                    return labelWithoutPct + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }
      
      // Build Status Chart (horizontal bar chart like homepage)
      const rebuildCtx = document.getElementById('reportRebuildChart');
      if (rebuildCtx && stats.rebuildBreakdown) {
        // Define rebuild stages in the same order as homepage
        const rebuildStages = [
          'Planning/Not Ready to Build Yet',
          'Permits & Pre-Construction',
          'Under Construction',
          'Finishing/Preparing to Move Back',
          'Moved In'
        ];
        
        // Process rebuild breakdown to include all stages in order
        const rebuildCounts = {};
        rebuildStages.forEach(stage => {
          rebuildCounts[stage] = 0;
        });
        rebuildCounts['Not Started'] = 0;
        rebuildCounts['Unknown'] = 0;
        
        // Populate counts from stats.rebuildBreakdown
        Object.entries(stats.rebuildBreakdown).forEach(([label, count]) => {
          if (rebuildCounts.hasOwnProperty(label)) {
            rebuildCounts[label] = count;
          } else {
            // Custom stage - add to rebuildCounts
            rebuildCounts[label] = count;
          }
        });
        
        // Collect all stages (predefined + custom)
        const allStagesSet = new Set(rebuildStages);
        Object.keys(rebuildCounts).forEach(key => {
          if (key !== 'Not Started' && key !== 'Unknown') {
            allStagesSet.add(key);
          }
        });
        
        // Build final labels array: Not Started first, then predefined stages, then custom stages, then Unknown
        const customStages = Array.from(allStagesSet).filter(s => !rebuildStages.includes(s) && s !== 'Not Started' && s !== 'Unknown');
        const allRebuildLabels = ['Not Started', ...rebuildStages, ...customStages, 'Unknown'];
        
        // Generate data array for all labels (use 0 if stage doesn't exist in rebuildCounts)
        const rebuildData = allRebuildLabels.map(label => rebuildCounts[label] || 0);
        
        const rebuildColors = ['#9e9e9e', '#bc455a', '#fdba77', '#f6cf98', '#afc892', '#81bdc3', '#e5e5e5', '#f9d6d3', '#e0e0e0', '#d4a574', '#c8a2c8', '#a8d8ea'];
        
        new Chart(rebuildCtx, {
          type: 'bar',
          data: {
            labels: allRebuildLabels,
            datasets: [{
              label: 'Count',
              data: rebuildData,
              backgroundColor: rebuildColors.slice(0, allRebuildLabels.length).map((color, i) => rebuildColors[i % rebuildColors.length]),
              borderColor: rebuildColors.slice(0, allRebuildLabels.length).map((color, i) => rebuildColors[i % rebuildColors.length]),
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                titleFont: { size: 18 },
                bodyFont: { size: 16 },
                padding: 12,
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed.x / total) * 100).toFixed(1) : '0';
                    const fullLabel = allRebuildLabels[context.dataIndex] || context.label;
                    return fullLabel + ': ' + context.parsed.x + ' (' + percentage + '%)';
                  }
                }
              }
            },
            scales: {
              x: {
                beginAtZero: true,
                ticks: {
                  stepSize: 1,
                  precision: 0,
                  font: {
                    size: 16
                  }
                },
                grid: {
                  display: true,
                  color: 'rgba(0, 0, 0, 0.05)'
                }
              },
              y: {
                ticks: {
                  font: {
                    size: 14
                  },
                  maxRotation: 0,
                  autoSkip: false,
                  callback: function(value, index) {
                    const label = allRebuildLabels[index];
                    // Truncate long labels and show full text in tooltip
                    if (label && label.length > 35) {
                      return label.substring(0, 32) + '...';
                    }
                    return label;
                  }
                },
                grid: {
                  display: false
                }
              }
            },
            layout: {
              padding: {
                right: 10
              }
            }
          }
        });
      }
      
      // Contact Chart
      const contactCtx = document.getElementById('reportContactChart');
      if (contactCtx && stats.contactedAddresses !== undefined) {
        const contacted = stats.contactedAddresses;
        const uncontacted = stats.uncontactedAddresses;
        const total = contacted + uncontacted;
        const contactedPct = total > 0 ? ((contacted / total) * 100).toFixed(1) : '0';
        const uncontactedPct = total > 0 ? ((uncontacted / total) * 100).toFixed(1) : '0';
        
        new Chart(contactCtx, {
          type: 'pie',
          data: {
            labels: [`Contacted (${contactedPct}%)`, `Uncontacted (${uncontactedPct}%)`],
            datasets: [{
              data: [contacted, uncontacted],
              backgroundColor: ['#afc892', '#bc455a'],
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                position: 'bottom',
                padding: 12,
                labels: {
                  padding: 12,
                  font: { size: 16 },
                  boxWidth: 20,
                  boxHeight: 20
                }
              },
              tooltip: {
                titleFont: { size: 18 },
                bodyFont: { size: 16 },
                padding: 12,
                callbacks: {
                  label: function(context) {
                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                    const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) : '0';
                    return context.label + ': ' + context.parsed + ' (' + percentage + '%)';
                  }
                }
              }
            }
          }
        });
      }
      
      // Street Chart (bar chart showing addresses per street)
      const streetCtx = document.getElementById('reportStreetChart');
      if (streetCtx && stats.streetStats) {
        const streetEntries = Object.entries(stats.streetStats)
          .sort((a, b) => b[1].addresses - a[1].addresses)
          .slice(0, 10); // Top 10 streets
        
        const streetLabels = streetEntries.map(([street]) => street || 'Unknown');
        const streetData = streetEntries.map(([, data]) => data.addresses);
        const streetColors = ['#afc892', '#81bdc3', '#fdba77', '#f6cf98', '#bc455a', '#e5e5e5', '#f9d6d3', '#d4a574', '#a8c090', '#e8c4a0'];
        
        new Chart(streetCtx, {
          type: 'bar',
          data: {
            labels: streetLabels,
            datasets: [{
              label: 'Addresses',
              data: streetData,
              backgroundColor: streetColors.slice(0, streetLabels.length),
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 2,
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                titleFont: { size: 18 },
                bodyFont: { size: 16 },
                padding: 12,
                callbacks: {
                  label: function(context) {
                    return 'Addresses: ' + context.parsed.y;
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  stepSize: 1,
                  font: {
                    size: 16
                  }
                }
              },
              x: {
                ticks: {
                  maxRotation: 45,
                  minRotation: 45,
                  font: {
                    size: 14
                  }
                }
              }
            }
          }
        });
      }
    }
    
    // Toggle tool module collapse/expand
    function toggleToolModule(moduleId) {
      const module = document.getElementById(moduleId);
      if (!module) return;
      
      // Only allow expansion for specific modules
      const expandableModules = ['contactListCreator', 'zoneReportGenerator', 'batchTaggingTool'];
      if (!expandableModules.includes(moduleId)) return;
      
      // If clicking the header of an expanded module, collapse it back to compact size
      if (module.classList.contains('expanded')) {
        module.classList.remove('expanded', 'collapsed');
        return;
      }
      
      // Otherwise, expand the module and collapse others
      const allModules = document.querySelectorAll('.tool-module');
      allModules.forEach(m => {
        if (m.id !== moduleId && expandableModules.includes(m.id)) {
          m.classList.remove('expanded', 'collapsed');
        }
      });
      
      // Add expanded class
      module.classList.add('expanded');
      module.classList.remove('collapsed');
      
      // Refresh Batch Tagging list when expanding so it reflects current filters
      if (moduleId === 'batchTaggingTool' && typeof initializeBatchTagging === 'function') {
        initializeBatchTagging();
      }
      
      // Smoothly scroll to the expanded module after a brief delay to allow layout to update
      requestAnimationFrame(() => {
        setTimeout(() => {
          module.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'start',
            inline: 'nearest'
          });
        }, 50);
      });
    }
    
    // Setup tool module expand functionality
    function setupToolModuleExpansion() {
      // Only these modules should be expandable
      const expandableModules = ['contactListCreator', 'zoneReportGenerator', 'batchTaggingTool'];
      
      document.querySelectorAll('.tool-module').forEach(module => {
        const moduleId = module.id;
        
        // Skip if not in expandable list or marked as no-expand
        if (!expandableModules.includes(moduleId) || module.dataset.noExpand === 'true') {
          return;
        }
        
        // Skip if already has expand listener
        if (module.dataset.expandSetup === 'true') return;
        module.dataset.expandSetup = 'true';
        
        // Header click handles expand/collapse toggle
        const header = module.querySelector('.tool-module-header');
        if (header) {
          // Remove inline onclick and use event listener instead
          header.removeAttribute('onclick');
          header.addEventListener('click', function(e) {
            e.stopPropagation();
            if (moduleId) {
              toggleToolModule(moduleId);
            }
          });
        }
        
        // Expand on click anywhere else in the module (if not expanded)
        module.addEventListener('click', function(e) {
          // Don't expand if clicking header (handled above), buttons, or interactive elements
          if (e.target.closest('.tool-module-header') || 
              e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || 
              e.target.tagName === 'A' || e.target.closest('button') || e.target.closest('a')) {
            return;
          }
          
          if (!module.classList.contains('expanded')) {
            if (moduleId) {
              toggleToolModule(moduleId);
            }
          }
        });
      });
    }
    
    // Make displayAddressList available globally for back button
    window.displayAddressList = displayAddressList;
    window.toggleToolModule = toggleToolModule;
    
  </script>
</body>
</html>
